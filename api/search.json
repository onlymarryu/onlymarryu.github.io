[{"id":"cea14d737db47f57fc4740d2a49418b4","title":"Errors","content":"所有文章的 cover 没有设置，再次访问的时候，自己设置一下\n格式：\n\n---\n***\ncover: 图床的链接 |  本地地址 (根目录是source)\n---\n\n","slug":"Errors","date":"2022-10-08T08:48:12.000Z","categories_index":"","tags_index":"","author_index":"雾都"},{"id":"4a207b7e885fdbcca8129599135e5f2e","title":"MySQL基础","content":"# MySQL 安装\n# 1、卸载原来的版本\n# 1、查看 mysql 的安装情况\nrpm -qa | grep -i mysql\n\n# 2、删除上图安装的软件\nrpm -ev --nodeps mysql57-community-release-el5-7.noarch\nrpm -ev --nodeps mysql-community-server-5.7.18-1.el5.x86_64\nrpm -ev --nodeps mysql-community-client-5.7.18-1.el5.x86_64\nrpm -ev --nodeps mysql-community-libs-5.7.18-1.el5.x86_64\nrpm -ev --nodeps mysql-community-common-5.7.18-1.el5.x86_64\nrpm -ev --nodeps mysql-5.7.18-1.el5.x86_64\nrpm -ev --nodeps mysql-community-libs-compat-5.7.18-1.el5.x86_64\n\n# 3、都删除成功之后，查找相关的 mysql 的文件\nfind / -name mysql\n\n# 4、删除全部文件\nrm -rf /etc/selinux/targeted/active/modules/100/mysql\nrm -rf /root/mysql\nrm -rf /root/mysql/data/mysql\nrm -rf /var/lib/mysql\nrm -rf /var/lib/mysql/mysql\nrm -rf /usr/share/mysql\n# 5、再次执行命令\nrpm -qa | grep -i mysql\n#如果没有显式则表示卸载完成\n# 2、删除 mariadb-libs (不可省略)\n# 检查mariadb-libs\nrpm -qa|grep mariadb\n# 卸载mariadb-libs\nyum remove -y mariadb-libs\n\n# 3、安装 MySQL\n# 1，输入\nwegt https://dev.mysql.com/get/mysql 版本号 - community-release-el 大版本 - 小版本.noarch.rpm\nwget https://dev.mysql.com/get/mysql57-community-release-el5-7.noarch.rpm\n\n# 2、安装数据源\nyum install -y mysql57-community-release-el5-7.noarch.rpm\n\n# 3、查看 mysql 源是否安装成功\nyum repolist enabled | grep \"mysql.*-community.*\"\n\n# 4、安装数据库\nyum install -y  mysql-community-server\n\n\n\n# 如果过期可以在运行安装程序之前导入密钥\nrpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022\n# 5、启动 mysql\n# centos7\nsystemctl restart mysqld\nsystemctl status mysqld\n\n\n# centos6\nservice mysqld start\nservice mysqld status\n\n# 6、显示 mysql 的随机密码\ngrep 'temporary password' /var/log/mysqld.log\n\n\n# 7、登录并修改 mysql 密码\n登录：mysql -u root -p     然后输入上面生成的密码\n修改自定义密码，设置自己想要的密码\n-- ALTER USER 'root'@'localhost' IDENTIFIED BY '密码';\n\nALTER USER 'root'@'localhost' IDENTIFIED BY 'root';\n失败了的话就修改策略，将策略降低一下就可以了\n查看密码策略：\nSHOW VARIABLES LIKE '%validate_password%';\n修改密码策略\n-- 修改密码长度：（长度）\nset global validate_password.length=1;\nset global validate_password_length=1;\n-- 修改密码等级：（等级）\nset global validate_password.policy=0;\nset global validate_password_policy=0;\n# 4、其他配置\n# 1. 开机自启\n# 开机启动\nsystemctl enable mysql\n# 关闭自动启动\nsystemctl disable mysqld\n\n# 2. 远程连接\n# 方法一、创建一个用户 支持远程连接\n①登录 ：mysql -u root -p\n②创建用户： create user ‘aaa’@’%’ identified by ‘123456’;\n③授权所有权限给 user 这个新用户 ：grant all on . to ‘aaa’@’%’;\n④退出 mysql：quit;\n# 方法二、设置 root 用户支持远程连接\n①登录：mysql -u root -p （ 注：系统提示输入数据库 root 用户的密码，输入完成后即进入 mysql 控制台，这个命令的第一个 mysql 是执行命令，第二个 mysql 是系统数据名称，不一样的。）\n②设置权限：\n赋予权限格式： grant 权限 on 数据库对象 to 用户 @IP (或者相应正则)\n-- 新建用户规则或者直接修改root用户的规则 ，2 选一\nuse mysql;\n\n-- 这里表示赋予该用户所有数据库所有表（*.*表示所有表），%表示所有IP地址。\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;\n-- 使root能再任何host访问\nupdate user set host = '%' where user = 'root';      \n\n-- 刷新\nFLUSH PRIVILEGES;\n③查看：\nuse mysql;\nSELECT HOST,USER FROM USER;\n\n④退出 mysql：quit;\n# 其他安装方式\n# docker\n# 1、查询镜像\ndocker search mysql\n# 2、拉取镜像\ndocker pull mysql:5.7\n# 3、构建容器\n先自己创建配置文件基础模板（要是后期要修改配置文件必须加入 模板中的两个元素，不然容器启动会出错）\nmkdir -p /root/mysql/conf\nvim  /root/mysql/conf/my.cnf\n模板内容：\n!includedir /etc/mysql/conf.d/\n!includedir /etc/mysql/mysql.conf.d/\n\n[mysql]\ndefault-character-set=utf8mb4\n[mysqld]\ncharacter_set_server=utf8mb4\ninit_connect='SET NAMES utf8'\nlower_case_table_names = 1\n\n构建容器\ndocker run \\\n-p 3306:3306 \\\n-v /root/mysql/data:/var/lib/mysql \\\n-v /root/mysql/logs:/logs \\\n-v /root/mysql/conf/my.cnf:/etc/mysql/my.cnf \\\n-e MYSQL_ROOT_PASSWORD=root \\\n--name mysql \\\n--hostname node1 \\\n--restart=always \\\n-d mysql:5.7\n注：出错时将本地映射文件检查一下，要是不需要配置，只需映射直接删掉就可，以后再改配置文件\n# 4、进入容器\ndocker exec -it mysql /bin/bash\n或者\ndocker exec -it mysql mysql -uroot -p\n# docker-compose\n\n\n\n\n\n\n\n\n\n前提安装了 docker-compose\n# 配置  docker-comose.yml 文件\n5.7：\nversion: \"3.0\"\nservices:\n  mysql8:\n    image: mysql:5.7.32\n    container_name: my_db57\n    restart: always\n    volumes:\n      - ./db:/var/lib/mysql\n      - ./conf/my.cnf:/etc/my.cnf\n      # 数据库初始化脚本，当Mysql容器首次启动时，会在 /docker-entrypoint-initdb.d目录下扫描 .sh，.sql，.sql.gz类型的文件。如果这些类型的文件存在，将执行它们来初始化一个数据库；\n      - ./init/:/docker-entrypoint-initdb.d/\n    environment:\n      - MYSQL_ROOT_PASSWORD=123456\n      # 指定初始化sql文件的数据库，简单来书就是新建一个数据库\n      - MYSQL_DATABASE=my_db\n      - TZ=Asia/Shanghai\n    ports:\n      - 3311:3306\n8.0\nversion: \"3.0\"\nservices:\n  mysql8:\n    image: mysql:8.0.25\n    container_name: my_db8\n    restart: always\n    volumes:\n      - ./db:/var/lib/mysql\n      - ./conf/my.cnf:/etc/my.cnf\n      # 数据库初始化脚本，当Mysql容器首次启动时，会在 /docker-entrypoint-initdb.d目录下扫描 .sh，.sql，.sql.gz类型的文件。如果这些类型的文件存在，将执行它们来初始化一个数据库；\n      - ./init/:/docker-entrypoint-initdb.d/\n    environment:\n      - MYSQL_ROOT_PASSWORD=123456\n      # 指定初始化sql文件的数据库，简单来书就是新建一个数据库\n      - MYSQL_DATABASE=my_db\n      - TZ=Asia/Shanghai\n    ports:\n      - 3301:3306\n# 配置文件 my.cnf\n5.7：\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8mb4\n\n[mysqld]\ndatadir=/var/lib/mysql\nsocket=/var/lib/mysql/mysql.sock\n\nsymbolic-links=0\n\nlog-error=/var/log/mysqld.log\npid-file=/var/run/mysqld/mysqld.pid\n# 服务端使用的字符集默认为8比特编码的latin1字符集\ncharacter-set-server=utf8mb4\n\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n8.0：\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8mb4\n[mysqld]\n# 允许最大连接数\nmax_connections=200\n\n# 服务端使用的字符集默认为8比特编码的latin1字符集\ncharacter-set-server=utf8mb4\n\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n# 问题\n1、Can’t create/write to file '/var/run/mysqld/mysqld.pid\n去配置文件中找到 errorlog 的地址，查看错误日志\n\n错误原因为：/var/run/mysqld/ 目录的拥有者为 root，mysql 不能在其中创建文件\n使用如下命令修改目录使用者\n# 先查看目录是否存在\nls -ld /var/run/mysqld/\n# 权限\nchown mysql.mysql /var/run/mysqld/\n# 修改后重启mysql服务\n/etc/init.d/mysqld start\n","slug":"MySQL_Create","date":"2022-10-08T07:10:28.016Z","categories_index":"数据库,MySQL","tags_index":"MySQL,数据库基础,数据库基本知识","author_index":"雾都"},{"id":"4a207b7e885fdbcca8129599135e5f2e","title":"MySQL基础","content":"# Docsify 搭建\n官网：https://docsify.js.org/#/zh-cn/\n前提\n\n\n\n\n\n\n\n\n\n要配置好  nodeJs  、 npm\n# 安装 Docsify 插件\n\n\n\n\n\n\n\n\n\n自己创建一个要下载到本地的文件夹，然后在这里直接利用命令下载\n推荐全局安装  docsify-cli  工具，可以方便地创建及在本地预览生成的文档。\nnpm i docsify-cli -g\n​\t下载完成之后，进入  ./node_modules/.bin  使用终端查看安装是否成功\ndocsify -v\n\n出现版本号，表明安装成功，自己再将该路径定义为 系统环境变量\n# 初始化项目\n如果想在项目的  ./docs  目录里写文档，直接通过  init  初始化项目。\n# init 初始化 + 初始化文件\ndocsify init ./docs\n初始化成功：\n\n\n# 开始写文档\n初始化成功后，可以看到  ./docs  目录下创建的几个文件\n\nindex.html  入口文件\nREADME.md  会做为主页内容渲染\n.nojekyll  用于阻止 GitHub Pages 忽略掉下划线开头的文件\n\n直接编辑  docs/README.md  就能更新文档内容，当然也可以添加更多页面。\n# 本地预览\n​\t通过运行  docsify serve  启动一个本地服务器，可以方便地实时预览效果。\ndocsify serve docs\n​\n​\t默认访问地址：   http://localhost:3000 。\n用  IDE  有可能遇到的问题。\n\n解决办法：\nhttps://blog.csdn.net/Bkhole/article/details/124636916\n访问结果：\n\n和  README.md  文件内容一致。\n\n\n\n\n\n\n\n\n\n我们在开发的时候 所有内容都是动态更新的\n# 功能开发\n\n\n\n\n\n\n\n\n\n主要内容还是参考 官网 ，这里只做简单描述。\n# 分页\n​\t如果需要创建多个页面，或者需要多级路由的网站，在 docsify 里也能很容易的实现。例如创建一个  guide.md  文件，那么对应的路由就是  /#/guide 。\n假设你的目录结构如下：\n.\n└── docs\n    ├── README.md\n    ├── guide.md\n    └── zh-cn\n        ├── README.md\n        └── guide.md\n那么对应的访问页面将是\ndocs/README.md        => http://domain.com\ndocs/guide.md         => http://domain.com/guide\ndocs/zh-cn/README.md  => http://domain.com/zh-cn/\ndocs/zh-cn/guide.md   => http://domain.com/zh-cn/guide\n# 定制侧边栏\n为了获得侧边栏，您需要创建自己的  _sidebar.md ，你也可以自定义加载的文件名。默认情况下侧边栏会通过 Markdown 文件自动生成，效果如当前的文档的侧边栏。\n首先配置  loadSidebar  选项，具体配置规则见配置项 #loadSidebar。\n&lt;!-- index.html -->\n\n&lt;script>\n  window.$docsify = &#123;\n      &lt;!-- 打开配置 -->\n    loadSidebar: true\n  &#125;\n&lt;/script>\n&lt;script src=\"//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js\">&lt;/script>\n接着创建  _sidebar.md  文件，内容如下\n&lt;!-- docs/_sidebar.md -->\n\n* [首页](zh-cn/)\n* [指南](zh-cn/guide)\n注：\n\n\n\n\n\n\n\n\n\n需要在  ./docs  目录创建  .nojekyll  命名的空文件，阻止 GitHub Pages 忽略命名是下划线开头的文件。\n###显示目录\n自定义侧边栏同时也可以开启目录功能。设置  subMaxLevel  配置项，具体介绍见 配置项 #subMaxLevel。\n&lt;!-- index.html -->\n\n&lt;script>\n  window.$docsify = &#123;\n    loadSidebar: true,\n    subMaxLevel: 2\n  &#125;\n&lt;/script>\n&lt;script src=\"//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js\">&lt;/script>\n# 自定义导航栏\n# HTML\n如果你需要定制导航栏，可以用 HTML 创建一个导航栏。\n注意：文档的链接都要以  #/  开头。\n&lt;!-- index.html -->\n\n&lt;body>\n  &lt;nav>\n    &lt;a href=\"#/\">EN&lt;/a>\n    &lt;a href=\"#/zh-cn/\">中文&lt;/a>\n  &lt;/nav>\n  &lt;div id=\"app\">&lt;/div>\n&lt;/body>\n# 配置文件\n那我们可以通过 Markdown 文件来配置导航。首先配置  loadNavbar ，默认加载的文件为  _navbar.md 。具体配置规则见配置项 #loadNavbar。\n&lt;!-- index.html -->\n\n&lt;script>\n  window.$docsify = &#123;\n    loadNavbar: true\n  &#125;\n&lt;/script>\n&lt;script src=\"//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js\">&lt;/script>\n&lt;!-- _navbar.md -->\n\n* [En](/)\n* [中文](/zh-cn/)\n注：\n\n\n\n\n\n\n\n\n\n你需要在  ./docs  目录下创建一个  .nojekyll  文件，以防止 GitHub Pages 忽略下划线开头的文件。\n_navbar.md  加载逻辑和  sidebar  文件一致，从每层目录下获取。例如当前路由为  /zh-cn/custom-navbar  那么是从  /zh-cn/_navbar.md  获取导航栏。\n# 封面\n通过设置  coverpage  参数，可以开启渲染封面的功能。具体用法见配置项 #coverpage。\n# 基本用法\n封面的生成同样是从 markdown 文件渲染来的。开启渲染封面功能后在文档根目录创建  _coverpage.md  文件。渲染效果如本文档。\nindex.html\n&lt;!-- index.html -->\n\n&lt;script>\n  window.$docsify = &#123;\n    coverpage: true\n  &#125;\n&lt;/script>\n&lt;script src=\"//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js\">&lt;/script>\n&lt;!-- techPage.md -->\n\n{% asset_img icon.svg logo %}\n\n# docsify &lt;small>3.5&lt;/small>\n\n> 一个神奇的文档网站生成器。\n\n- 简单、轻便 (压缩后 ~21kB)\n- 无需生成 html 文件\n- 众多主题\n\n[GitHub](https://github.com/docsifyjs/docsify/)\n[Get Started](#docsify)\n\n# 自定义背景\n目前的背景是随机生成的渐变色，我们自定义背景色或者背景图。在文档末尾用添加图片的 Markdown 语法设置背景。\n_coverpage.md\n&lt;!-- _coverpage.md --&gt;\n\n# docsify &lt;small&gt;3.5&lt;&#x2F;small&gt;\n\n[GitHub](https:&#x2F;&#x2F;github.com&#x2F;docsifyjs&#x2F;docsify&#x2F;)\n[Get Started](#quick-start)\n\n&lt;!-- 背景图片 --&gt;\n\n![](_media&#x2F;bg.png)\n\n&lt;!-- 背景色 --&gt;\n\n![color](#f0f0f0)\n# 封面作为首页\n通常封面和首页是同时出现的，当然你也是当封面独立出来通过设置 onlyCover 选项。\n# 部署\n和 GitBook 生成的文档一样，我们可以直接把文档网站部署到 GitHub Pages 或者 VPS 上。\n# GitHub Pages\nGitHub Pages 支持从三个地方读取文件\n\ndocs/  目录\nmaster 分支\ngh-pages 分支\n\n我们推荐直接将文档放在  docs/  目录下，在设置页面开启 GitHub Pages 功能并选择  master branch /docs folder  选项。\n# 配置过程\n1、创建一个 GitHub 仓库\n\n\n\n\n\n\n\n\n\n要求：\n1、仓库名格式必须符合：github_username.github.io\n2、配置 GithubPage\n\n\n\n\n\n\n\n\n\n随便选一个主题，毕竟我们也不用\n\n\n\n\n3、上传项目\n\n\n\n\n\n\n\n\n\n直接将我们的项目上传到这个库中即可。\n–考虑到是保姆级教程我们将上传步骤也写一下\n（1）首先我们将仓库中的信息拉取下来\n​\t这是第二步配置结束之后会产生 GitHubPage  的配置文件\n\n（2）将配置文件与我们的 docs 文件一起重新提交到仓库中\ngit add xx\n\ngit commit xx -m\"注释\"\n\ngit push xx 仓库地址 分支\n\n我这里直接使用工具  Sourcetree  提交。\n\n4、上传成功，部署成功\n直接访问：\nhttps://onlymarryu.github.io/#/\n\n\n\n\n\n\n\n\n\n\n​\t如果刷新不是想要的结果，只要确认之前所有本地测试结果正取，只是部署之后结果不对，这就是部署时间的问题，我们等一会刷新即可。\n","slug":"Docsify","date":"2022-10-08T07:10:27.998Z","categories_index":"基础使用","tags_index":"博客,环境搭建","author_index":"雾都"},{"id":"deffdaaa2a24a19ee257667b3b36743c","title":"设计模式","content":"# 谈谈你对设计模式的理解\n1. 首先谈设计模式的作用：经验的传承，提高了软件复用的水平，最终达到提高软件开发效率\n五大原则\n\n\n\n设计原则\n简单说明\n\n\n\n\n单一职责\n一个类只负责一项职责\n\n\n里氏替换原则\n子类可以扩展父类的功能，但不能改变父类原有的功能\n\n\n依赖倒置原则\n要依赖于抽象，不要依赖于具体，核心思想是面向接口编程\n\n\n接口隔离原则\n建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少\n\n\n迪米特法则 （最少知道原则）\n一个对象应该对其他对象保持最少的了解\n\n\n开闭原则\n对扩展开放，对修改关闭\n\n\n\n2. 设计模式的分类\n\n3. 创建型模式：都是用来帮助我们创建对象的！\n\n4. 结构性模式：关注对象和类的组织\n\n5. 行为型模式：关注系统中对象之间的相互交换，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责，共有 11 中模式\n\n# 一、创建型模式\n# 1. 单例模式\n作用：单例模式的核心是保证一个类只有一个实例，并且提供一个访问实例的全局访问点。\n\n\n\n实现方式\n优缺点\n\n\n\n\n饿汉式\n线程安全，调用效率高 ，但是不能延迟加载\n\n\n懒汉式\n线程安全，调用效率不高，能延迟加载\n\n\n双重检测锁式\n在懒汉式的基础上解决并发问题\n\n\n静态内部类式\n线程安全，资源利用率高，可以延时加载\n\n\n枚举单例\n线程安全，调用效率高，但是不能延迟加载\n\n\n\n# 饿汉式\n也就是类加载的时候立即实例化对象，实现的步骤是先私有化构造方法，对外提供唯一的静态入口方法，实现如下\n/**\n * 单例模式：饿汉式\n *\n */\npublic class SingletonInstance1 &#123;\n\t// 声明此类型的变量，并实例化，当该类被加载的时候就完成了实例化并保存在了内存中\n\tprivate final static SingletonInstance1 instance = new SingletonInstance1();\n\n\t// 私有化所有的构造方法,防止直接通过new关键字实例化\n\tprivate SingletonInstance1()&#123;&#125;\n\t// 对外提供一个获取实例的静态方法\n\tpublic static SingletonInstance1 getInstance()&#123;\n\t\treturn instance;\n\t&#125;\n&#125;\n\n饿汉式单例模式代码中，static 变量会在类装载时初始化，此时也不会涉及多个线程对象访问该对象的问题。虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题。因此，可以省略 synchronized 关键字\n问题：如果只是加载本类，而不是要调用 getInstance ()，甚至永远没有调用，则会造成资源浪费！\n/**\n * 单例模式：饿汉式\n *\n */\npublic class SingletonInstance1 &#123;\n    private byte[] b1 = new byte[1024*1024];\n    private byte[] b2 = new byte[1024*1024];\n    private byte[] b3 = new byte[1024*1024];\n\t// 声明此类型的变量，并实例化，当该类被加载的时候就完成了实例化并保存在了内存中\n\tprivate final static SingletonInstance1 instance = new SingletonInstance1();\n\n\t// 私有化所有的构造方法,防止直接通过new关键字实例化\n\tprivate SingletonInstance1()&#123;&#125;\n\t// 对外提供一个获取实例的静态方法\n\tpublic static SingletonInstance1 getInstance()&#123;\n\t\treturn instance;\n\t&#125;\n&#125;\n# 懒汉式\n/**\n * 单例模式：懒汉式\n *\n */\npublic class SingletonInstance2 &#123;\n\t// 声明此类型的变量,但没有实例化\n\tprivate static SingletonInstance2 instance = null;\n\n\t// 私有化所有的构造方法,防止直接通过new关键字实例化\n\tprivate SingletonInstance2()&#123;&#125;\n\t// 对外提供一个获取实例的静态方法，为了数据安全添加synchronized关键字\n\tpublic static synchronized SingletonInstance2 getInstance()&#123;\n\t\tif(instance == null)&#123;\n\t\t\t// 当instance不为空的时候才实例化\n\t\t\tinstance = new SingletonInstance2();\n\t\t&#125;\n\t\treturn instance;\n\t&#125;\n&#125;\n\n  此种方式在类加载后如果我们一直没有调用 getInstance 方法，那么就不会实例化对象。实现了延迟加载，但是因为在方法上添加了 synchronized 关键字，每次调用 getInstance 方法都会同步，所以对性能的影响比较大。\n# 双重检测锁\n/**\n * 单例模式：懒汉式\n * 双重检测机制\n *\n */\npublic class SingletonInstance3 &#123;\n\t// 声明此类型的变量,但没有实例化\n\tprivate static volatile  SingletonInstance3 instance = null;\n\n\t// 私有化所有的构造方法,防止直接通过new关键字实例化\n\tprivate SingletonInstance3()&#123;&#125;\n\t// 对外提供一个获取实例的静态方法，\n\tpublic static  SingletonInstance3 getInstance()&#123;\n\t\tif(instance == null)&#123;\n\t\t\tsynchronized(SingletonInstance3.class)&#123;\n\t\t\t\tif(instance == null)&#123;\n                    // 1.分配内存空间  2. 执行构造方法，实例化对象 3.把这个对象赋值给这个空间\n                    // 如果不加volatile 会执行重排序 1 3 2 \n\t\t\t\t\tinstance = new SingletonInstance3();\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn instance;\n\t&#125;\n&#125;\n\n不加 volatile 有指令重排序的问题。添加后可以解决。\n# 静态内部类\n/**\n * 静态内部类实现方式\n *\n */\npublic class SingletonInstance4 &#123;\n\t// 静态内部类\n\tpublic static class SingletonClassInstance&#123;\n\t\t// 声明外部类型的静态常量\n\t\tpublic static final SingletonInstance4 instance = new SingletonInstance4();\n\t&#125;\n\t// 私有化构造方法\n\tprivate SingletonInstance4()&#123;&#125;\n\n\t// 对外提供的唯一获取实例的方法\n\tpublic static SingletonInstance4 getInstance()&#123;\n\t\treturn SingletonClassInstance.instance;\n\t&#125;\n&#125;\n\n# 枚举单例\n/**\n * 单例模式：枚举方式实现\n *\n */\npublic enum SingletonInstance5 &#123;\n\n\t// 定义一个枚举元素，则这个元素就代表了SingletonInstance5的实例\n\tINSTANCE;\n\n\tpublic void singletonOperation()&#123;\n\t\t// 功能处理\n\t&#125;\n&#125;\n\n# 2. 怎么解决反射爆破单例\n  在单例中我们定义的私有的构造器，但是我们知道反射是可以操作私有的属性和方法的，这时我们应该怎么处理？\npublic static void main(String[] args) throws Exception, IllegalAccessException &#123;\n\tSingletonInstance1 s1 = SingletonInstance1.getInstance();\n\t// 反射方式获取实例\n\tClass c1 = SingletonInstance1.class;\n\tConstructor constructor = c1.getDeclaredConstructor(null);\n\tconstructor.setAccessible(true);\n\tSingletonInstance1 s2 = (SingletonInstance1)constructor.newInstance(null);\n\tSystem.out.println(s1);\n\tSystem.out.println(s2);\n&#125;\n\n输出结果\ncom.dpb.single.SingletonInstance1@15db9742\ncom.dpb.single.SingletonInstance1@6d06d69c\n\n产生了两个对象，和单例的设计初衷违背了。\n解决的方式是在无参构造方法中手动抛出异常控制，或者声明一个全局变量来控制。\n// 私有化所有的构造方法,防止直接通过new关键字实例化\nprivate SingletonInstance2()&#123;\n\tif(instance != null)&#123;\n\t\t// 只能有一个实例存在，如果再次调用该构造方法就抛出异常，防止反射方式实例化\n\t\tthrow new RuntimeException(\"单例模式只能创建一个对象\");\n\t&#125;\n&#125;\n\n上面这种方式我们还可以通过反序列化的方式来破解\npublic static void main(String[] args) throws Exception, IllegalAccessException &#123;\n\tSingletonInstance2 s1 = SingletonInstance2.getInstance();\n\t// 将实例对象序列化到文件中\n\tObjectOutputStream oos = new ObjectOutputStream(\n\t\t\tnew FileOutputStream(\"c:/tools/a.txt\"));\n\toos.writeObject(s1);\n\toos.flush();\n\toos.close();\n\t// 将实例从文件中反序列化出来\n\tObjectInputStream ois = new ObjectInputStream(\n\t\t\tnew FileInputStream(\"c:/tools/a.txt\"));\n\tSingletonInstance2 s2 = (SingletonInstance2) ois.readObject();\n\tois.close();\n\tSystem.out.println(s1);\n\tSystem.out.println(s2);\n&#125;\n\n我们只需要在单例类中重写 readResolve 方法并在该方法中返回单例对象即可，如下:\npackage com.dpb.single;\n\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\n\n/**\n * 单例模式：懒汉式\n *\n */\npublic class SingletonInstance2 implements Serializable&#123;\n\n\t// 声明此类型的变量,但没有实例化\n\tprivate static SingletonInstance2 instance = null;\n\n\t// 私有化所有的构造方法,防止直接通过new关键字实例化\n\tprivate SingletonInstance2()&#123;\n\t\tif(instance != null)&#123;\n\t\t\t// 只能有一个实例存在，如果再次调用该构造方法就抛出异常，防止反射方式实例化\n\t\t\tthrow new RuntimeException(\"单例模式只能创建一个对象\");\n\t\t&#125;\n\t&#125;\n\t// 对外提供一个获取实例的静态方法，为了数据安全添加synchronized关键字\n\tpublic static synchronized SingletonInstance2 getInstance()&#123;\n\t\tif(instance == null)&#123;\n\t\t\t// 当instance不为空的时候才实例化\n\t\t\tinstance = new SingletonInstance2();\n\t\t&#125;\n\t\treturn instance;\n\t&#125;\n\t// 重写该方法，防止序列化和反序列化获取实例\n\tprivate Object readResolve() throws ObjectStreamException&#123;\n\t\treturn instance;\n\t&#125;\n&#125;\n\n说明:readResolve 方法是基于回调的，反序列化时，如果定义了 readResolve () 则直接返回此方法指定的对象，而不需要在创建新的对象！\n# 3. 说说你在哪些框架中看到了单例的设计\n1.Spring 中的 Bean 对象，默认是单例模式\n2. 相关的工厂对象都是单例，比如：MyBatis 中的 SqlSessionFactory，Spring 中的 BeanFactory\n3. 保存相关配置信息的都是单例，比如：MyBatis 中的 Configuration 对象，SpringBoot 中的各个 XXXAutoConfiguration 对象等\n4. 应用程序的日志应用，一般都会通过单例来实现\n5. 数据库连接池的设计也是单例模式\n# 4. 工厂模式\n  工厂模式的作用是帮助我们创建对象，我们不用自己来创建，根据需要创建的对象的复杂度我们可以把工厂模式分为简单工厂，工厂方法和抽象工厂。\n\n# 4.1 简单工厂\n  简单工厂模式又称为静态工厂方法，他可以根据不同的参数而返回不同的实例，简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。\nJDK 中的简单工厂应用：DataFormat\n\n自己写一个简单工厂的案例\n\n/**\n * 简单工厂\n */\npublic class SimpleFactory &#123;\n\n    public static void main(String[] args) &#123;\n        // 根据对应的类型返回相关产品\n        CarFactory.createCar(\"奥迪\").run();\n        CarFactory.createCar(\"Byd\").run();\n    &#125;\n&#125;\n\n// 定义公共的接口\ninterface Car&#123;\n    void run();\n&#125;\n\nclass Audi implements Car&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(\"奥迪在跑...\");\n    &#125;\n&#125;\n\nclass Byd implements Car&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(\"Byd在跑...\");\n    &#125;\n&#125;\n\n// 创建对应的简单工厂类\nclass CarFactory&#123;\n    public static Car createCar(String type)&#123;\n        if(\"奥迪\".equals(type))&#123;\n            return new Audi();\n        &#125;else if(\"Byd\".equals(type))&#123;\n            return new Byd();\n        &#125;else&#123;\n            throw new RuntimeException(\"该产品不能生产\");\n        &#125;\n    &#125;\n&#125;\n我们可以发现简单工厂对于新增产品是无能为力的！不修改原有代码根本就没办法扩展！！！\n# 4.2 工厂方法\n  针对于简单工厂的短板，引出了工厂方法模式，定义一个用户创建对象的接口，让子类决定实例化哪个类，工厂方法使一个类的实例化延迟到了其子类中。\n\n代码实现：\n/**\n * 工厂方法模式\n */\npublic class FactoryMethod &#123;\n\n    public static void main(String[] args) &#123;\n        new AudiCarFactory().createCar().run();\n        new BydCarFactory().createCar().run();\n    &#125;\n\n\n    public static interface  Car&#123;\n        public void run();\n    &#125;\n\n    public static class Byd implements Car&#123;\n        @Override\n        public void run() &#123;\n            System.out.println(\"比亚迪...\");\n        &#125;\n    &#125;\n\n    public static class Audi implements Car&#123;\n        @Override\n        public void run() &#123;\n            System.out.println(\"奥迪...\");\n        &#125;\n    &#125;\n\n    public static interface CarFactory&#123;\n        public Car createCar();\n    &#125;\n\n    // 扩展的工厂\n    public static class AudiCarFactory implements CarFactory&#123;\n        @Override\n        public Car createCar() &#123;\n            return new Audi();\n        &#125;\n    &#125;\n\n    public static class BydCarFactory implements CarFactory&#123;\n        @Override\n        public Car createCar() &#123;\n            return new Byd();\n        &#125;\n    &#125;\n&#125;\n简单工厂和工厂方法模式的对比\n\n简单工厂只有一个工厂，而工厂方法有多个工厂\n简单工厂不支持扩展，而工厂方法支持扩展，扩展的方式就是添加对应的工厂类即可\n简单工厂代码复杂度低，工厂方法代码复杂度高\n…\n\n# 4.3 抽象工厂\n  上面的两种方式实现的工厂都是生产同一大类的产品，如果要实现生产不同类型的产品这时我们就可以用抽象工厂模式来实现。\n\n代码实现：\n/**\n * 抽象工厂：多个产品族\n */\npublic class AbstractFactory &#123;\n\n    public static void main(String[] args) &#123;\n        Car car = new LuxuryEngineCarFacory().createCar();\n        Engine engine = new LuxuryEngineCarFacory().createEngine();\n        car.run();\n        engine.run();\n    &#125;\n\n    // 抽象工厂\n    public static interface AbstarctComponentFactory&#123;\n        Car createCar();\n        Engine createEngine();\n    &#125;\n\n    public static class LuxuryEngineCarFacory implements AbstarctComponentFactory&#123;\n        @Override\n        public Engine createEngine() &#123;\n            return new LuxuryEngineFactory().createEngine();\n        &#125;\n\n        @Override\n        public Car createCar() &#123;\n            return new BydCarFactory().createCar();\n        &#125;\n    &#125;\n\n    public static class LowEngineCarFacory implements AbstarctComponentFactory&#123;\n        @Override\n        public Car createCar() &#123;\n            return new AudiCarFactory().createCar();\n        &#125;\n\n        @Override\n        public Engine createEngine() &#123;\n            return new LowEngineFactory().createEngine();\n        &#125;\n    &#125;\n\n    // 汽车产品族\n    public static interface  Car&#123;\n        public void run();\n    &#125;\n\n    public static class Byd implements Car &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(\"比亚迪...\");\n        &#125;\n    &#125;\n\n    public static class Audi implements Car &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(\"奥迪...\");\n        &#125;\n    &#125;\n\n    public static interface CarFactory&#123;\n        public Car createCar();\n    &#125;\n\n    // 扩展的工厂\n    public static class AudiCarFactory implements CarFactory &#123;\n        @Override\n        public Car createCar() &#123;\n            return new Audi();\n        &#125;\n    &#125;\n\n    public static class BydCarFactory implements  CarFactory&#123;\n        @Override\n        public Car createCar() &#123;\n            return new Byd();\n        &#125;\n    &#125;\n\n    // 发动机产品族\n    public static interface Engine&#123;\n        public void run();\n    &#125;\n\n    public static class LuxuryEngine implements Engine&#123;\n        @Override\n        public void run() &#123;\n            System.out.println(\"豪华版发动机...\");\n        &#125;\n    &#125;\n\n    public static class LowEngine implements Engine&#123;\n        @Override\n        public void run() &#123;\n            System.out.println(\"低配版发动机...\");\n        &#125;\n    &#125;\n\n    public static interface EngineFactory&#123;\n        public Engine createEngine();\n    &#125;\n\n    public static class LuxuryEngineFactory implements EngineFactory&#123;\n        @Override\n        public Engine createEngine() &#123;\n            return new LuxuryEngine();\n        &#125;\n    &#125;\n\n    public static class LowEngineFactory implements EngineFactory&#123;\n        @Override\n        public Engine createEngine() &#123;\n            return new LowEngine();\n        &#125;\n    &#125;\n&#125;\n\n三者的对比：\n\n简单工厂模式 (静态工厂模式) ：虽然某种程度不符合设计原则，但实际使用最多。\n工厂方法模式：不修改已有类的前提下，通过增加新的工厂类实现扩展。\n抽象工厂模式：不可以增加产品，可以增加产品族！\n\n# 5. 建造者模式\n  实际开发中，我们所需要的对象构建时非常复杂，且有很多步骤需要处理时，这时建造者模式就很适合。比如 MyBatis 中的 SqlSessionFactory 对象的创建，我们不光要创建 SqlSessionFactory 本身的对象，还有完成 MyBatis 的全局配置文件和映射文件的加载解析操作，之后把解析出来的信息绑定在 SqlSessionFactory 对象中，\n\n直接参考 MyBatis 的代码即可\n\n所以建造者模式的作用就是帮助我们解决了复杂对象的创建\n建造者模式和工厂模式的区别：\n\n关注的维度是不一样的\n工厂模式创建对象 new 出来\n建造者模式关注的是对象创建的本身\n\n# 6. 原型模式\n  在 java 中我们知道通过 new 关键字创建的对象是非常繁琐的 (类加载判断，内存分配，初始化等)，在我们需要大量对象的情况下，原型模式就是我们可以考虑实现的方式。\n  原型模式我们也称为克隆模式，即一个某个对象为原型克隆出来一个一模一样的对象，该对象的属性和原型对象一模一样。而且对于原型对象没有任何影响。原型模式的克隆方式有两种：浅克隆和深度克隆.\n\n\n\n原型模式\n说明\n\n\n\n\n浅克隆\n只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，`` 还是指向原生对象的内部元素地址\n\n\n深度克隆\n深复制把要复制的对象所引用的对象都复制了一遍\n\n\n\n# 6.1 浅克隆\n  被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。 Object 类提供的方法 clone = 只是拷贝本对象 = ， = 其对象内部的数组、引用对象等都不拷贝 = ，还是指向原生对象的内部元素地址.\n  被克隆的对象必须 Cloneable,Serializable 这两个接口；\npackage com.bobo.prototype;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\npublic class User implements Cloneable, Serializable &#123;\n\n    private String name;\n\n    private Date birth;\n\n    private int age;\n\n    /**\n     * 实现克隆的方法\n     * @return\n     * @throws CloneNotSupportedException\n     */\n    @Override\n    protected Object clone() throws CloneNotSupportedException &#123;\n        return super.clone();\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public Date getBirth() &#123;\n        return birth;\n    &#125;\n\n    public void setBirth(Date birth) &#123;\n        this.birth = birth;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public static void main(String[] args) throws Exception &#123;\n        // 创建一个普通对象\n        Date date =  new Date(666666);\n        User user = new User();\n        user.setName(\"波波烤鸭\");\n        user.setAge(18);\n        user.setBirth(date);\n        System.out.println(\"原型对象的属性：\" + user);\n        // 克隆对象\n        User cloneUser = (User) user.clone();\n        System.out.println(\"克隆的对象的属性：\" + cloneUser);\n        // 修改原型对象的属性\n        date.setTime(12345677);\n        // 修改克隆对象的属性\n        cloneUser.setName(\"波哥\");\n        System.out.println(\"原型对象的属性：\" + user);\n        System.out.println(\"克隆的对象的属性：\" + cloneUser);\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"User&#123;\" +\n                \"name='\" + name + '\\'' +\n                \", birth=\" + birth +\n                \", age=\" + age +\n                '&#125;';\n    &#125;\n&#125;\n\n输出结果\n\n浅克隆的问题：虽然产生了两个完全不同的对象，但是被复制的对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。\n# 6.2 深度克隆\n  被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。\n实现的效果是:\n\n深度克隆 (deep clone) 有两种实现方式，第一种是在浅克隆的基础上实现，第二种是通过序列化和反序列化实现，我们分别来介绍\n方式一：在浅克隆的基础上实现\n/**\n * 实现克隆的方法\n * @return\n * @throws CloneNotSupportedException\n */\n@Override\nprotected Object clone() throws CloneNotSupportedException &#123;\n    User user = (User) super.clone();\n    // 实现深度克隆\n    user.birth = (Date) this.birth.clone();\n    return user;\n&#125;\n\n方式二：序列化和反序列化\n\n\n\n名称\n说明\n\n\n\n\n序列化\n把对象转换为字节序列的过程。\n\n\n反序列化\n把字节序列恢复为对象的过程。\n\n\n\npublic static void main(String[] args) throws CloneNotSupportedException, Exception &#123;\n\tDate date =  new Date(1231231231231l);\n\tUser user = new User();\n\tuser.setName(\"波波烤鸭\");\n\tuser.setAge(18);\n\tuser.setBirth(date);\n\tSystem.out.println(\"-----原型对象的属性------\");\n\tSystem.out.println(user);\n\n\t//使用序列化和反序列化实现深复制\n\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\tObjectOutputStream    oos = new ObjectOutputStream(bos);\n\toos.writeObject(user);\n\tbyte[] bytes = bos.toByteArray();\n\n\tByteArrayInputStream  bis = new ByteArrayInputStream(bytes);\n\tObjectInputStream\t  ois = new ObjectInputStream(bis);\n\n\t//克隆好的对象！\n\tUser user1 = (User) ois.readObject();   \n\n\t// 修改原型对象的值\n\tdate.setTime(221321321321321l);\n\tSystem.out.println(user.getBirth());\n\n\tSystem.out.println(\"------克隆对象的属性-------\");\n\tSystem.out.println(user1);\n&#125;\n\n# 7. 谈谈你对创建型模式的理解\n  Java 的 23 种设计模式分为 3 类，分别是\n\n而创建型模式中有包含的如下的相关模式：\n\n而每个设计模式的作用如下：\n\n# 二、结构性模式\n# 1. 代理模式\n# 1.1 代理模式的作用\n  代理模式的作用是通过代理对象来增强目标对象的功能。利用的是 AOP 横切的思想。\n# 1.2 代理模式的实现方式\n  代理模式的实现方式有三种：静态代理，动态代理 (JDK 动态代理和 CGLIB 动态代理)\n\n# 1.2.1 静态代理\n我们先声明接口和目标实现类\n/**\n * 定义公共接口\n */\npublic interface SomeService &#123;\n    String doSome();\n&#125;\n目标类\n/**\n * 目标对象 target\n */\npublic class SomeServiceImpl implements SomeService &#123;\n    @Override\n    public String doSome() &#123;\n        System.out.println(\"目标对象：doSome()\" );\n        return \"hello ...\";\n    &#125;\n&#125;\n然后创建对应的代理类\n/**\n * 代理类\n *     增强实现类\n *     和实现类实现同一个接口\n */\npublic class SomeProxy implements SomeService&#123;\n\n    private SomeService target;\n\n    public SomeProxy(SomeService target)&#123;\n        this.target = target;\n    &#125;\n\n    /**\n     * 增强的方法\n     * @return\n     */\n    @Override\n    public String doSome() &#123;\n        System.out.println(\"目标方法执行之前...\");\n        String s = target.doSome();\n        System.out.println(\"目标方法执行之后...\");\n        return s.toUpperCase();\n    &#125;\n&#125;\n然后测试实现\npublic class MainTest &#123;\n    public static void main(String[] args) &#123;\n        SomeService some = new SomeServiceImpl();\n        SomeProxy proxy = new SomeProxy(some);\n        System.out.println(proxy.doSome());\n    &#125;\n&#125;\n对应的输出结果\n目标方法执行之前...\n目标对象：doSome()\n目标方法执行之后...\nHELLO ...\n可以看到代理对象实现了目标对象的调用，同时增强了目标对象的功能。\n# 1.2.2 JDK 动态代理\n  上面的静态代理我们需要手动的创建一个对应的代理来实现，不是太灵活，针对目标对象有实现相关接口的情况，我们可以使用 JDK 动态代理。\npublic class JdkDynamicProxy &#123;\n\n    /**\n     * JDK动态代理：目标对象必须实现相关的接口\n     * @param args\n     */\n    public static void main(String[] args) &#123;\n        SomeService target = new SomeServiceImpl();\n        SomeService proxy = (SomeService) Proxy.newProxyInstance(JdkDynamicProxy.class.getClassLoader(), // 类加载器\n                target.getClass().getInterfaces() // 目标对象实现的相关接口\n                , new InvocationHandler() &#123; // 代理对象的回调方法\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n                        System.out.println(\"before...\");\n                        Object invoke = method.invoke(target, args);\n                        System.out.println(\"end...\");\n                        if (invoke != null) &#123;\n                            return invoke.toString().toUpperCase();\n                        &#125;\n                        return null;\n                    &#125;\n                &#125;);\n        // 通过代理对象来执行\n        System.out.println(\"proxy.doSome() = \" + proxy.doSome());\n\n    &#125;\n&#125;\n输出结构\nbefore...\n目标对象：doSome()\nend...\nproxy.doSome() &#x3D; HELLO ...\n# 1.2.3 CGLIB 动态代理\n  如果目标对象实现了对应的接口我们可以通过 JDK 动态代理的方式来实现，但如果目标对象没有实现任何的接口，这时我们只能通过 CGLIB 动态代理来实现了，这时我们需要单独引入 cglib 的依赖\npublic class CGLIBDynamicProxy &#123;\n\n    /**\n     * CGLIB动态代理\n     * @param args\n     */\n    public static void main(String[] args) &#123;\n        SomeService target = new SomeServiceImpl();\n        SomeServiceImpl proxy = new MethodInterceptor() &#123;\n\n            /**\n             * 创建 CGLIB 代理对象的方法\n             * @return\n             */\n            public SomeServiceImpl createProxy() &#123;\n                // 创建增强器\n                Enhancer e = new Enhancer();\n                // 指定父类\n                e.setSuperclass(target.getClass());\n                // 指定回调接口对象\n                e.setCallback(this);\n                // 创建CGLIB代理对象\n                return (SomeServiceImpl) e.create();\n            &#125;\n\n            /**\n             * 拦截回调的方法\n             */\n            @Override\n            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;\n                System.out.println(\"cglib -- befor\" );\n                Object res = method.invoke(target, args);\n                System.out.println(\"cglib -- end\");\n                return res.toString().toUpperCase();\n            &#125;\n        &#125;.createProxy();\n        System.out.println(\"proxy.doSome() = \" + proxy.doSome());\n    &#125;\n&#125;\n输出的结果\ncglib -- befor\n目标对象：doSome()\ncglib -- end\nproxy.doSome() &#x3D; HELLO ...\n# 2. 适配器模式\n# 2.1 适配器的作用\n  适配器模式的作用是把两个不兼容的对象通过适配器能够连接起来工作。\n\n# 2.2 具体案例分析\n  以 MyBatis 中的日志模块为例来介绍。常见的日志框架有 log4j,log4j2,slf4j,logbak 等，但是每种日志框架中的日志级别都有差异。\nlog4j2 的接口：\n\nslf4j 的接口\n\n也就是可以看到不同的日志框架里面所定义的日志级别和对应的方法都有区别，那么我们的框架怎么来统一使用这些日志框架呢？在 MyBatis 中通过定义了一个日志接口，定义了日志具有的级别和方法。\n\n那这时候我们就发现具体的日志框架和这个接口其实是没有办法直接来使用的。\n\n这时我们就需要通过对应的适配器来处理这种情况，以 Slf4J 为例。\n\n# 3. 装饰者模式\n# 3.1 装饰者模式的作用\n  装饰者模式又称为包装模式 (Wrapper), 作用是用来动态的为一个对象增加新的功能。装饰模式是一种用于代替继承的技术， 无须通过继承增加子类就能扩展对象的新功能 。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。\n\n# 3.2 装饰者模式的应用\n  装饰者模式的应用场景还是非常多的，比如\n\nIO 流中的 FileInputStream，FileOutputStream 等\nSpring 中的各种 Wrapper\nMyBatis 中的缓存设计\n\n我们以 MyBatis 中的缓存实例为例来看看其具体的实现。\n首先是 Cache 接口\n\n然后是 PerpetualCache 实现：仅仅实现了数据基于内存的读写操作。功能单一。\n\n装饰类：然后在 MyBatis 中给我们提供了很多的装饰类。\n\n每个装饰类都有自己的作用\n\nBlockingCache：阻塞的\nLruCache: 根据 Lru 规则来淘汰缓存数据\nFifoCache：根据 FIFO 规则来淘汰缓存数据\n…\n\n源码中的装饰：\n\n\n\n\n\n比较\n说明\n\n\n\n\n优点\n1. 扩展对象功能，比继承灵活，不会导致类个数急剧增加 &lt;br /&gt;2. 可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更加强大的对象 &lt; br /&gt;3. 具体构建类和具体装饰类可以独立变化，&lt;br /&gt; 用户可以根据需要自己增加新的具体构件子类和具体装饰子类。\n\n\n缺点\n1.  产生很多小对象。大量小对象占据内存，一定程度上影响性能。&lt;br /&gt;2. 装饰模式易于出错，调试排查比较麻烦。\n\n\n\n# 4. 组合模式\n# 4.1 组合模式的作用\n  其实解决的是对象与对象之间的包含关系。也就是 部分 - 整体 的层次结构。\n# 4.2 组合模式的应用\n  组合模式在配置文件的加载解析中其实会用的相对比较多。以 SpringSecurity 的配置文件为例\n\n上面是具体的定义\n\n应用\n\n# 5. 门面模式\n  门面模式也称为外观模式，他隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。这种类型的设计模式属于结构性模式。为子系统中的一组接口提供了一个统一的访问接口，这个接口使得子系统更容易被访问或者使用。\n\n  具体的例子比如：MyBatis 中的 SqlSession 接口，对外提供了数据库操作的相关功能，具体的实现细节对调用者是隐藏的，这种模式在实际项目和框架中很频繁\n# 6. 桥接模式\n  桥接模式的出现是替代掉多层继承的问题。提高了系统的扩展性。\n\n具体的应用比如 JDBC 中的 DriverManager 其实有用到桥接模式，不同的数据库厂商对应不同的驱动和连接\n# 7. 享元模式\n  这个问题相对来说比较冷门，用到的也比较少，主要是针对内存这块的节省处理，如果有很多个完全相同或相似的对象，我们可以通过享元模式，节省内存.\n享元模式以共享的方式高效地支持大量细粒度对象的重用。\n享元对象能做到共享的关键是区分了内部状态和外部状态。\n•  内部状态 ：可以共享，不会随环境变化而改变\n・外部状态 ：不可以共享，会随环境变化而改变\n比如以围棋为例:\n\n\n# 三、行为型模式\n  行为型模式关注的是对象之间的通信，也就是描述多个类或者对象之间，通过协作共同完成一个任务。主要涉及的是 对象 和 算法之间职责的分配。\n行为型模式分为两类：\n\n类行为模式： 通过继承机制来在类间分派行为。 主要是通过多态来分配父类和子类的职责\n对象行为模式： 通过组合或聚合，在对象间分派行为。通过对象关联等方式来分配类的职责。\n\n\n# 1. 解释器模式\n# 1.1 解释器模式的作用\n  解释器模式在业务开发面是很少接触到的。主要的作用是定义的解释器来解析各种表达式，比如 SQL 语句，SPEL 表达式，权限注解中的表达式 hasAnyRole (‘ROLE_ADMIN’) 等。\n# 1.2 解释器的应用\n  比较常见的应用比如 Spring 中的针对 SPEL 表达式做的解析处理\npublic static void main(String[] args) &#123;\n    SpelExpressionParser parser = new SpelExpressionParser();\n    Expression expression = parser.parseExpression(\"500-100*2+60\");\n    Object value = expression.getValue();\n    System.out.println(\"value = \" + value);\n&#125;\n# 2. 模板模式\n# 2.1 模板模式的作用\n  模板模式是一种相对简单的设计模式。作用是在父类中固定程序的执行顺序，具体的实现在子类中实现。比如银行定义每个人去银行开户的流程，\n\n取号\n填写单子\n等待\n办理业务\n结束\n\n然后每个人来开户都会走这个流程，只是每个人的具体操作内容会有区别\n# 2.2 模板模式的应用\n  模板模式的应用就比较多如下：\n\nServlet 中的 doGet 和 doPost 方法\nSpring 中的 JdbcTemplate\nMyBatis 中的 Executor 处理\n…\n\n# 3. 责任链模式\n# 3.1 责任链模式的作用\n  将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理，如果不能则传递给链上的下一个对象处理。\n\n# 3.2 责任链模式的应用\n  责任链模式的应用场景比较多，对大家来说印象比较深刻的应该是 SpringSecurity 中的处理请求的过滤器链了。\n\n  可以和面试官具体聊下 SpringSecurity 中的这块设计。当然还有一些其他的也可聊比如：\n\nJava 中，异常机制就是一种责任链模式。一个 try 可以对应多个 catch，当第一个 catch 不匹配类型，则自动跳到第二个 catch.\nJavascript 语言中，事件的冒泡和捕获机制。Java 语言中，事件的处理采用观察者模式。\nSpringMVC 中，拦截器的调用也是典型的责任链模式\n同样的 Servlet 中的过滤器链同样是责任链模式的实现。\n\n# 4. 观察者模式\n# 4.1 观察者模式的作用\n  建立对象与对象之间的依赖关系，一个对象发生改变时，会自动通知其他对象。这个场景中，发生改变的对象被称为观察目标，被通知的对象称为观察者。一个观察目标可以有多个观察者，而这些观察者之间可以没有联系，可以根据需要增加或删除观察者。\n\n# 4.2 观察者模式的应用\n  观察者模式在 Java 编程中用到最多的可能就是事件模块的处理，可以和面试官详细的聊下 Spring 的事件管理机制或者 SpringBoot 的事件处理机制。我们以 SpringBoot 的事件机制为例来说明\nhttps://blog.csdn.net/qq_38526573/article/details/122143258 单独通过一篇文章来说明事件的本质。\n# 5. 策略模式\n# 5.1 策略模式的作用\n  策略模式的作用就是我们想要实现某个目的，实现的方式可以有很多种，那么这里的每一种实现方式都可以称为一种策略。比如：\n\n  我们可以将每一种交通方式都封装为一个独立的类，这就是一种策略。为了保证策略的一致性，还可以用一个抽象的交通方式类 来 做交通方式的定义。\n# 5.2 策略模式的应用\n  策略模式在实际开发中用到的同样会比较多。\n\nAOP 中根据不同的策略可以通过 JDK 动态代理或者 CGLIB 代理来创建代理对象\nSpring 框架中的 Resources 接口，资源访问的策略\nServlet 中的 service 方法，会根据客户端的不同提交方式来调用对应的 doGet 或者 doPost 方法来处理请求\nShiro 中的多 Realm 认证中，根据我们不同的配置可以使用所有 Realm 认证通过或者其中一个认证通过等\nSpringSecurity 中的 Authentication 对象的存储方式\n…\n\n# 6. 迭代器模式\n# 6.1 迭代器模式的作用\n场景：访问聚合对象中的各个元素的时候，比如链表的遍历。我们一般是将遍历的方法也放在链表类中。但是如果需要修改遍历方法，就需要修改链表类的代码，违背了开闭原则。\n迭代器模式就是在客户访问和聚合类之间插入一个迭代器，这样就将聚合对象 和 遍历方法解耦了，并且对外隐藏其实现细节。\n\n# 6.2 迭代器模式的应用\n\nJDK 中的 List/Set 集合中的迭代器\n…\n\n# 7. 中介者模式\n# 7.1 中介则模式的作用\n  对象之间具有很强的关联性，而且有大量的相互调用，这种情况下，如果一个对象发生了变化，就需要追踪该对象关联的其他对象，并进行相应的处理，这就变得很复杂。而中介者模式，就是用一个中介者对象来封装一系列的对象交互，中介者使各对象不需要显式的相互引用，这就使得系统变得低耦合。比如：\n\n假如没有总经理。下面三个部门：财务部、市场部、研发部。财务部要发工资，让大家核对公司需要跟市场部和研发部都通气；市场部要接个新项目，需要研发部处理技术、需要财务部出资金。市场部跟各个部门打交道。 虽然只有三个部门，但是关系非常乱。\n\n实际上，公司都有总经理。各个部门有什么事情都通报到总经理这里，总经理再通知各个相关部门。\n# 7.2 中介则模式的应用\n\nMVC 模式中的 C，控制器就是一个中介者对象，M 和 V 都和 C 打交道\n代理对象中的 invoke 方法，客户端和目标对象都是通过 invoke 来打交到的。\n…\n\n# 8. 状态模式\n场景： 如果一个对象的行为会根据 其某个属性的变化而不同，那这个属性就可以被称为该对象的状态。这样的对象也被称为有状态对象（stateful）。如果这样的对象因为某些事件，其内部状态发生了改变，那么系统的行为也要随之发生变化的话，就可以使用状态模式。\n# 9. 命令模式\n场景：请求的发送者和接收者之间解耦，让对象之间的调用关系更加灵活。发送者和接收者之间没有直接的引用关系，发送请求的对象只需要知道如何发送，而不必关心如何完成请求。\n# 10. 备忘录模式\n场景：记录一个对象的内部状态，当用户后悔时能撤销当前的操作，是数据恢复到它原来的状态。比如我们编程的时候，ctrl+z 就是撤销当前操作，恢复到修改前的状态。又叫快照模式。\n# 11. 访问者模式\n场景：有些集合对象中会有多种不同的元素，每种元素都有不同的访问者 和 处理方式。这种被处理的数据元素相对稳定，但是处理方式比较多样的情况，可以用访问者模式来处理。\n访问者模式将数据结构中的各元素的操作分离出来，封装成独立的类，使其在不改变数据结构的前提下，可以添加作用于这些元素的新操作。为数据结构中的每个元素提供多种访问方式。\n","slug":"DesignMode","date":"2022-10-07T15:52:00.000Z","categories_index":"设计模式","tags_index":"","author_index":"雾都"},{"id":"0ca9a116507ce2deadb100db49d2064a","title":"Dubbo","content":"# Dubbo\n# 主要内容\n\nDubbo 简介\nDubbo 架构讲解\nDubbo 支持的协议\nDubbo 支持的注册中心\n第一个 Dubbo 的 Provider\nAdmin 管理界面搭建\n成 Dubbo 的 Consumer\n负载均衡\n完整 Dubbo 项目演示\n\n# 学习目标\n\n\n\n知识点\n要求\n\n\n\n\nDubbo 简介\n掌握\n\n\nDubbo 架构讲解\n精通\n\n\nDubbo 支持的协议\n掌握\n\n\nDubbo 支持的注册中心\n掌握\n\n\n第一个 Dubbo 的 Provider\n掌握\n\n\nAdmin 管理界面搭建\n掌握\n\n\n完成 Dubbo 的 Consumer\n掌握\n\n\n负载均衡\n掌握\n\n\n完整 Dubbo 项目演示\n掌握\n\n\n\n# 一、Dubbo 简介\n# 1, 官方说明\n\n​\tApache Dubbo 是一个高可用的，基于 Java 的开源 RPC 框架。\n​\tDubbo 框架不仅仅是具备 RPC 访问功能，还包含服务治理功能。\n# 2. 发展历史\n​\tDubbo 是最开始是阿里巴巴内部使用的 RPC 框架。\n​\t2011 年对外提供。\n​\t2012 年停止更新。\n​\t2017 年开始继续更新。\n​\t2019 年捐献给 Apache，由 Apache 维护 2.7 以上版本。\n# 3.Dubbo 架构讲解\n# 3.1 架构图\n\n# 3.2 架构说明\n# 3.2.1 虚线\n​\t虚线表示异步，实线表示同步。异步不阻塞线程性能高，同步阻塞线程必须等待响应结果才能继续执行，相对性能低。\n# 3.2.2Provider\n​\t提供者。编写持久层和事务代码。\n# 3.2.3Container\n​\t容器（Spring 容器），Dubbo 完全基于 Spring 实现的。\n# 3.2.4Registry\n​\t注册中心。放置所有 Provider 对外提供的信息。包含 Provider 的 IP，访问端口，访问遵守的协议，对外提供的接口，接口中有哪些方法等相关信息。\n# 3.2.5Consumer\n​\t消费者（RPC 调用者，SOA 调用服务的项目）开发中也是一个项目，编写 service 和 controller（还可以报页面等）。调用 XXXXServiceImpl 中的方法。\n# 3.2.6Monitor\n​\t监控中心。监控 Provider 的压力情况等。每隔 2 分钟 Consumer 和 Provider 会把调用次数发送给 Monitor，由 Monitor 进行统计。\n# 4. 执行流程\n\nstart：启动 Spring 容器时会把 Provider 启动。\nregister：把 Provider 相关信息注册到 Registry 里\nsubscribe：Consumer 从 Registry 中订阅 Provider 的信息\nnotify：通知给 Consumer\ninvoke：Consumer 根据 Registry 通知的信息进行调用 Provider 中方法。\ncount:Consumer 和 Provider 把调用次数信息异步发送给 Monitor 进行统计。\n\n# 二、Dubbo 支持的协议\n# 1.Dubbo 协议 (官方推荐协议)\n​\t优点：\n​\t\t采用 NIO 复用单一长连接，并使用线程池并发处理请求，减少握手和加大并发效率，性能较好（推荐使用）\n​\t缺点：\n​\t\t大文件上传时，可能出现问题 (不使用 Dubbo 文件上传)\n# 2.RMI (Remote Method Invocation) 协议\n​\t优点:\n​\t\tJDK 自带的能力。\n​\t缺点:\n​\t\t偶尔连接失败.\n# 3.Hessian 协议\n​\t优点:\n​\t\t可与原生 Hessian 互操作，基于 HTTP 协议\n​\t缺点:\n​\t\t需 hessian.jar 支持，http 短连接的开销大\n# 三、Dubbo 支持的注册中心\n# 1.Zookeeper (官方推荐)\n​\t1) 优点:\n​\t\t支持分布式。很多周边产品.\n​\t2) 缺点:\n​\t\t受限于 Zookeeper 软件的稳定性.Zookeeper 专门分布式辅助软件，稳定较优\n# 2.Multicast\n​\t1) 优点:\n​\t\t去中心化，不需要单独安装软件.\n​\t2) 缺点:\n​\t\t2.2.1 Provider 和 Consumer 和 Registry 不能跨机房 (路由)\n# 3.Redis\n​\t1) 优点:\n​\t\t支持集群，性能高\n​\t2) 缺点:\n​\t\t要求服务器时间同步。否则可能出现集群失败问题.\n# 4.Simple\n​\t1) 优点:\n​\t\t标准 RPC 服务。没有兼容问题\n​\t2) 缺点:\n​\t\t不支持集群.\n# 四、第一个 Dubbo 的 Provider\n​\t新建父项目 Parent1。最终结构如下：\n\n​\t编写 pom.xml 继承 SpringBoot 父项目。\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.1.10.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt; \n# 1. 新建 api 项目\n# 1.1 创建接口\n​\t创建 com.msb.dubbo.service.DemoDubboService 接口\npublic interface DemoDubboService &#123;\n    String demo();\n&#125;\n# 2. 新建 provider 项目\n# 2.1 编写 pom.xml\n​\t注意：不需要依赖 web，如果依赖 spring-boot-start-web 还需要考虑端口问题。\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;artifactId&gt;api&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.msb&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.1.10.RELEASE&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.7.3&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;curator-recipes&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;4.2.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;4.2.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;   \n# 2.2 编写配置文件\n​\t新建 application.yml\ndubbo:\n  application:\n    name: dubbo-provider\n  registry:\n    address: zookeeper:&#x2F;&#x2F;192.168.32.128:2181\n# 2.3 新建实现类\n​\t新建 com.msb.dubbo.service.impl.DemoDubboServiceImpl\n​\t注意：注解是 apache 的注解。\nimport com.msb.dubbo.service.DemoDubboService;\nimport org.apache.dubbo.config.annotation.Service;\n\n@Service\npublic class DemoDubboServiceImpl implements DemoDubboService &#123;\n    @Override\n    public String demo() &#123;\n        System.out.println(&quot;demo方法&quot;);\n        return &quot;123&quot;;\n    &#125;\n&#125;\n# 2.4 新建启动类\n​\t新建 com.msb.ProviderApplication。\n​\t必须要有 @EnableDubbo 注解，否则 Dubbo 不生效。\n@SpringBootApplication\n@EnableDubbo\npublic class ProviderApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(ProviderApplication.class,args);\n    &#125;\n&#125;\n# 五、完成 Dubbo 的 Consumer\n​\t创建 consumer 项目\n# 1. 编写 pom.xml\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;artifactId&gt;api&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.msb&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.1.10.RELEASE&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.7.3&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;curator-recipes&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;4.2.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;4.2.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;   \n# 2. 新建配置文件\n​\t新建 application.yml\ndubbo:\n  application:\n    name: dubbo-consumer\n  registry:\n    address: zookeeper:&#x2F;&#x2F;192.168.32.128:2181\n# 3. 新建 service 及实现类\n​\t新建 com.msb.service.DemoService\n​\t新建 com.msb.service.impl.DemoServiceImpl\n​\t调用服务使用 @Reference 注解，不要倒错包了，有两个。\npublic interface DemoService &#123;\n    String consumerDemo();\n&#125;\nimport com.msb.dubbo.service.DemoDubboService;\nimport com.msb.service.DemoService;\nimport org.apache.dubbo.config.annotation.Reference;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class DemoServiceImpl implements DemoService &#123;\n\n    @Reference\n    private DemoDubboService demoDubboService;\n\n    @Override\n    public String consumerDemo() &#123;\n        return demoDubboService.demo();\n    &#125;\n&#125;\n# 4. 新建控制器\n​\t新建控制器 com.msb.controller.DemoController\n@Controller\npublic class DemoController &#123;\n    @Autowired\n    private DemoService demoService;\n\n    @RequestMapping(&quot;&#x2F;demo&quot;)\n    @ResponseBody\n    public String demo()&#123;\n        return demoService.consumerDemo();\n    &#125;\n&#125;\n# 5. 新建启动器\n​\t新建 com.msb.ConsumerApplication\n@SpringBootApplication\n@EnableDubbo\npublic class ConsumerApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(ConsumerApplication.class,args);\n    &#125;\n&#125;\n# 六、Admin 管理界面搭建\n​\t资料中把 dubbo-admin-0.2.0.jar\\BOOT-INF\\classes 中 application.properties 里面注册中心的 ip 设置正确\n​\t使用 java -jar dubbo-admin-0.2.0.jar 运行即可。\n​\t注意：占用 8080 端口，不要冲突了。\n# 七、负载均衡\n​\t集群：一个内容，部署多次，形成的整体称为集群。集群中每个个体应该部署到不同的服务器上。\n​\t伪集群：集群中内容部署到同一台服务器上，通过不同端口区分不同个体。\n​\t负载均衡是在集群前提下，当访问整个集群时，集群中每个节点被访问次数或频率的规则。\n​\tDubbo 内置了四个负载均衡策略。默认为 Random\n# 1. 内置策略\n# 1.1Random\n​\t随机。随机访问集群中节点。访问概率和权重有关。\n# 1.2RoundRobin\n​\t轮询。访问频率和权重有关。\n​\t权重（weight）：占有比例。集群中每个项目部署的服务器的性能可能是不同，性能好的服务器权重应该高一些。\n# 1.3LeastActive\n​\t活跃数相同的随机，不同的活跃数高的放前面。\n# 1.4ConsistentHash\n​\t一致性 Hash。相同参数请求总是发到一个提供者。\n# 2.Provider 集群\n​\t新建四个启动类。\n​\t每次启动启动类修改配置文件 dubbo.protocal.port\n# 3. 设置负载均衡\n# 3.1@Reference\n​\t调用的服务采用的负载均衡\n@Reference(loadbalance &#x3D; &quot;roundrobin&quot;)\nprivate DemoDubboService demoDubboService;\n# 3.2 @Service\n​\t当前服务采用的负载均衡算法\n@Service(loadbalance &#x3D; &quot;random&quot;)\npublic class DemoDubboServiceImpl implements DemoDubboService &#123;\n​\t设置权重\n@Service(weight &#x3D; 4)\n# 3.3 配置文件\n​\t\t\t全局设置所有 provider 和 consumer 的负载均衡效果。\ndubbo:\n  application:\n    name: dubbo-provider\n  registry:\n    address: zookeeper:&#x2F;&#x2F;192.168.32.128:2181\n  protocol:\n    port: 20884\n  provider:\n    loadbalance: random\n  consumer:\n    loadbalance: random\n# 八、完整 Dubbo 项目演示\n# 1. 原型\n# 1.1 部门显示\n​\t显示全部部门信息\n\n# 1.2 员工新增\n\n# 1.3 查看部门员工\n\n# 2. 按照分布式架构进行设计项目\n​\t\t设定员工管理和部门管理不在同一个模块中，需要有一个员工管理项目和一个部门管理项目。\n​\t为了方便，不去每个项目使用一个窗口，而是使用聚合项目。\n\n# 3. 创建数据库表\ncreate table dept(\nid int(11) primary key auto_increment,\nname varchar(20)\n);\n\ninsert into dept values(default,&#39;开发部&#39;);\ninsert into dept values(default,&#39;产品部&#39;);\n\ncreate table emp(\nid int(11) primary key auto_increment,\nname varchar(20),\nphoto varchar(200),\ndid int(11),\nCONSTRAINT fk_emp_dept FOREIGN key (did) REFERENCES dept(id)\n);\n# 4. 创建父项目\n​\t创建项目 parent。\n\n编写 pom.xml\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.1.10.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;\n&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.1.10.RELEASE&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.1.10.RELEASE&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.1.10.RELEASE&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.7.3&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;curator-recipes&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;4.2.0&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;4.2.0&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.1.1&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;5.1.6&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.6&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n         &lt;dependency&gt;\n             &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n             &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n             &lt;version&gt;1.18.12&lt;&#x2F;version&gt;\n             &lt;scope&gt;provided&lt;&#x2F;scope&gt;\n         &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;dependencyManagement&gt;\n# 5. 创建 pojo 项目\n# 6. 创建 mapper 项目\n# 6.1 编写 pom.xml\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;artifactId&gt;pojo&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.msb&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;    \n# 6.2 新建配置文件\n​\t新建 application-mybatis.yml\nspring:\n  datasource:\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;maven\n    username: root\n    password: root\n\nmybatis:\n  mapper-locations: classpath:mybatis&#x2F;*.xml\n  type-aliases-package: com.msb.pojo\n# 7. 新建 api 项目\n# 7.1 编写 pom.xml\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;artifactId&gt;pojo&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.bjsxt&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;    \n# 8. 新建 provider\n# 8.1 编写 pom.xml\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;artifactId&gt;mapper&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.msb&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;artifactId&gt;api&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.msb&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;curator-recipes&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n# 8.2 新建配置文件\n​\t新建 application.yml\ndubbo:\n  application:\n    name: dubbo-provider\n  registry:\n    address: zookeeper:&#x2F;&#x2F;192.168.52.128:2181\n\n# 加载其他配置文件,加载其他application-*.yml文件，多个名称之间使用逗号分隔\nspring:\n  profiles:\n    active: mybatis\n# 8.3 新建启动类\n​\t新建 com.msb.ProviderApplication\n@SpringBootApplication\n@EnableDubbo\n@MapperScan(&quot;com.msb.mapper&quot;)\npublic class ProviderApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(ProviderApplication.class,args);\n    &#125;\n&#125;\n# 9. 完成 Dept 查询功能\n# 9.1 在 api 中新建接口\n​\tcom.msb.dubbo.service.DeptDubboService\npublic interface DeptDubboService &#123;\n    List&lt;Dept&gt; selectAll();\n&#125;\n# 9.2 在 provider 中新建实现类\n​\tcom.msb.dubbo.service.impl.DeptDubboServiceImpl\n@Service\npublic class DeptDubboServiceImpl implements DeptDubboService &#123;\n    @Autowired\n    private DeptMapper deptMapper;\n    @Override\n    public List&lt;Dept&gt; selectAll() &#123;\n        return deptMapper.selectByExample(null);\n    &#125;\n&#125;\n# 9.3 新建项目 dept\n# 9.3.1 添加依赖\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;artifactId&gt;api&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.msb&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;curator-recipes&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;   \n# 9.3.2 编写配置文件\n​\t新建 application.yml\ndubbo:\n  application:\n    name: dubbo-dept-consumer\n  registry:\n    address: zookeeper:&#x2F;&#x2F;192.168.52.128:2181\n# 9.3.3 新建启动类\n​\tcom.msb.DeptApplication\n@SpringBootApplication\n@EnableDubbo\npublic class DeptApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(DeptApplication.class,args);\n    &#125;\n&#125;\n# 9.3.4 新建接口及实现类\n​\t接口：com.msb.service.DeptService\n​\t实现类：com.msb.service.impl.DeptServiceImpl\npublic interface DeptService &#123;\n    List&lt;Dept&gt; showAll();\n&#125;\n@Service\npublic class DeptServiceImpl implements DeptService &#123;\n    @Reference\n    private DeptDubboService deptDubboService;\n    @Override\n    public List&lt;Dept&gt; showAll() &#123;\n        return deptDubboService.selectAll();\n    &#125;\n&#125;\n# 9.3.5 新建控制器\n​\tcom.msb.controller.DeptController\n@Controller\npublic class DeptController &#123;\n\n    @Autowired\n    private DeptService deptService;\n\n    @GetMapping(&quot;&#x2F;dept&quot;)\n    public String shwoDept(Model model)&#123;\n        model.addAttribute(&quot;list&quot;,deptService.showAll());\n        return &quot;dept&quot;;\n    &#125;\n&#125;\n# 9.3.6  新建页面\n​\t在 resources /templates 新建 dept.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;table border&#x3D;&quot;1&quot; width&#x3D;&quot;500&quot;&gt;\n        &lt;tr&gt;\n            &lt;th&gt;编号&lt;&#x2F;th&gt;\n            &lt;th&gt;部门名称&lt;&#x2F;th&gt;\n            &lt;th&gt;查看&lt;&#x2F;th&gt;\n        &lt;&#x2F;tr&gt;\n        &lt;tr th:each&#x3D;&quot;dept : $&#123;list&#125;&quot;&gt;\n            &lt;td th:text&#x3D;&quot;$&#123;dept.id&#125;&quot;&gt;&lt;&#x2F;td&gt;\n            &lt;td th:text&#x3D;&quot;$&#123;dept.name&#125;&quot;&gt;&lt;&#x2F;td&gt;\n            &lt;td&gt; &lt;a th:href&#x3D;&quot;@&#123;&#x2F;showEmp(did&#x3D;$&#123;dept.id&#125;)&#125;&quot;&gt;查看&lt;&#x2F;a&gt; &lt;&#x2F;td&gt;\n        &lt;&#x2F;tr&gt;\n    &lt;&#x2F;table&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;             \n","slug":"Dubbo","date":"2022-10-06T16:00:00.000Z","categories_index":"分布式,Dubbo","tags_index":"分布式,Dubbo","author_index":"雾都"},{"id":"0c9b416069b21ba4788b7e5bb7998df5","title":"FastDFS","content":"# 分布式文件存储系统 FastDFS\n# 一、分布式文件存储\n# 1. 分布式文件存储的由来\n  在我们的项目中有很多需要存储的内容出现，比如图片，视频，文件等等，在早期的时候用户量不大，产生的文件也不是很多，这时我们可以把文件和服务程序放在一个服务器中。\n\n  后面随着文件越来越多，服务器的资源会被文件资源大量占据，从而影响到服务器的稳定，这时我们可以单独的把文件服务器拆出来。\n\n  拆解出来后，文件服务的使用不会影响到我们的系统服务的稳定，但是当用户量越来越大，存储的文件就会越来越多，这时如果还是单台的文件服务，比如 100T 的文件，这时是存储不下去的，这时就产生了我们将的分布式文件存储，\n\n  也就是我们解决如何将这 100T 的文件分散的存储到各个节点上，然后当我们需要读取文件的时候又能非常快的帮我们把文件找到。这个就是分布式文件系统帮我们解决的问题了。\n# 2. 常见的分布式存储框架\n  接下来我们看看在国内常用的分布式存储的框架选择有哪些\n\n\n\n分布式框架\n说明\n\n\n\n\nFastDFS\n我们介绍的主角，国产\n\n\nHDFS\nHadoop 组件中分布式存储框架\n\n\nMinIO\nMinIO 是在 Apache 下的产品，最适合存储非结构化的数据，比如照片，视频，日志文件，备份和容器等。\n\n\n阿里云对象存储\n当然我们还可以花费一点费用来使用其他厂商提供的对象存储服务\n\n\n\n  好了就介绍这么几个，其他的我们也用不到了。\n# 二、FastDFS 介绍\n  FastDFS 是余庆国人开发的一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。\n  FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。\nFastDFS 的特点：\n\nFastDFS 是一个轻量级的开源分布式文件系统\nFastDFS 主要解决了大容量的文件存储和高并发访问的问题，文件存取时实现了负载均衡\nFastDFS 实现了软件方式的 RAID，可以使用廉价的 IDE 硬盘进行存储\n支持存储服务器在线扩容\n支持相同内容的文件只保存一份，节约磁盘空间\nFastDFS 只能通过 Client API 访问，不支持 POSIX 访问方式\nFastDFS 特别适合大中型网站使用，用来存储资源文件（如：图片、文档、音频、视频等等）\n\n架构图：\n\n相关术语讲解：\n\n\n\n名词\n描述\n\n\n\n\nTracker Server\n跟踪服务器，主要做调度工作，在访问上起负载均衡的作用。记录 storage server 的状态，是连接 Client 和 Storage server 的枢纽\n\n\nStorage Server\n存储服务器，文件和 meta data 都保存到存储服务器上\n\n\ngroup\n组，也可称为卷。同组内服务器上的文件是完全相同的\n\n\n文件标识\n包括两部分：组名和文件名（包含路径）\n\n\nmeta-data\n文件相关属性，键值对（Key Value Pair）方式，如：width=1024,heigth=768\n\n\n\n架构解读：\n\n只有两个角色，tracker server 和 storage server，不需要存储文件索引信息。\n所有服务器都是对等的，不存在 Master-Slave 关系。\n存储服务器采用分组方式，同组内存储服务器上的文件完全相同（RAID 1）。\n不同组的 storage server 之间不会相互通信。\n由 storage server 主动向 tracker server 报告状态信息，tracker server 之间不会相互通信。\n\n# 三、FastDFS 安装\n\n  FastDFS 的安装我们还是通过 Docker 来安装实现吧，直接在 Linux 上还装还是比较繁琐的，但就学习而言 Docker 安装还是非常高效的。Docker 环境请自行安装哦，不清楚的可以看看我的 Docker 专题的内容。https://blog.csdn.net/qq_38526573/category_9619681.html\n# 1. 拉取镜像文件\n  首先我们可以通过  docker search fastdfs  来查询下有哪些镜像文件。\n\n  我们看到搜索到的镜像还是蛮多的，这里我们使用  delron/fastdfs  你也可以尝试使用其他的镜像来安装，你也可以制作自己的镜像来给别人使用哦，只是不同的镜像在使用的时候配置会有一些不一样，有些镜像没有提供 Nginx 的相关配置，使用的时候会繁琐一点。接下来通过  docker pull delron/fastdfs  命令把镜像拉取下来。\ndocker pull delron/fastdfs\n\n# 2. 构建 Tracker 服务\n  首先我们需要通过 Docker 命令来创建 Tracker 服务。命令为\ndocker run -d --name tracker --network=host -v /mydata/fastdfs/tracker:/var/fdfs delron/fastdfs tracker\n  tracker 服务默认的端口为 22122，-v 实现了容器和本地目录的挂载操作。\n\n# 3. 构建 Storage 服务\n  接下来创建 Storage 服务，具体的执行命令如下\ndocker run -d --name storage --network=host  -e TRACKER_SERVER=192.168.1.195:22122 -v /mydata/fastdfs/storage:/var/fdfs -e GROUP_NAME=group1 delron/fastdfs storage\n  在执行上面命令的时候要注意对应的修改下，其中 TRACKER_SERVER 中的 ip 要修改为你的 Tracker 服务所在的服务 IP 地址。\n\n  默认情况下在 Storage 服务中是帮我们安装了 Nginx 服务的，相关的端口为\n\n\n\n服务\n默认端口\n\n\n\n\ntracker\n22122\n\n\nstorage\n23000\n\n\nNginx\n8888\n\n\n\n  当然如果你发现这些相关的端口被占用了，或者想要对应的修改端口信息也可以的。要修改你可以先进入容器中查看下相关的配置文件信息。\n\n  然后查看 storage.conf 文件\n\n  这个是 storage 监听的 Nginx 的端口 8888，如果要修改那么我们还需要修改 Nginx 中的服务配置，这块的配置在  /usr/local/nginx/conf  目录下\n\n  查看下文件\n\n所以要修改端口号的话，这两个位置都得修改了。当然本文我们就使用默认的端口号来使用了。\n# 4. 测试图片上传\n  好了，安装我们已经完成了，那么到底是否可以使用呢？我们来测试下。首先在虚拟机的 /mydata/fastdfs/storage 下保存一张图片。\n\n  然后我们再进入到 storage 容器中。并且进入到  /var/fdfs  目录下，可以看到我们挂载的文件了\n\n  然后执行如下命令即可完成图片的上传操作\n/usr/bin/fdfs_upload_file /etc/fdfs/client.conf 1.jpg\n\n  通过上面的提示我们看到文件上传成功了，而且返回了文件在 storage 中存储的信息。这时我们就可以通过这个信息来拼接访问的地址在浏览器中访问了：http://192.168.56.100:8888/group1/M00/00/00/wKg4ZGHcKLSAXibaAAezMuUrlS8235.jpg\n\n  好了到这儿 FastDFS 的服务安装成功了。\n# 四、客户端操作\n# 1.Fastdfs-java-client\n  首先我们来看下如何实现 FastDFS 中提供的 JavaAPI 来直接实现对应的文件上传和下载操作。\n# 1.1 文件上传\n  先来看下文件上传的流程\n\n  上传流程的文字梳理为：\n\n客户端访问 Tracker\nTracker 返回 Storage 的 ip 和端口\n客户端直接访问 Storage，把文件内容和元数据发送过去。\nStorage 返回文件存储 id。包含了组名和文件名\n\n  首先创建一个普通的 maven 项目，然后引入对应的依赖\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>cn.bestwu&lt;/groupId>\n        &lt;artifactId>fastdfs-client-java&lt;/artifactId>\n        &lt;version>1.27&lt;/version>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>org.apache.commons&lt;/groupId>\n        &lt;artifactId>commons-lang3&lt;/artifactId>\n        &lt;version>3.4&lt;/version>\n    &lt;/dependency>\n&lt;/dependencies>\n  然后编写 FastDFS 的配置文件，内容如下：注意 ip 修改为你自己对应的 ip 即可\nconnect_timeout = 10\nnetwork_timeout = 30\ncharset = UTF-8\nhttp.tracker_http_port = 8080\ntracker_server = 192.168.56.100:22122\n\n  然后导入对应的工具类，在工具类中完成了 StorageClient 的实例化，并提供了相关的上传和下载的方法。\npackage com.bobo.fastdfs.config;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.csource.common.NameValuePair;\nimport org.csource.fastdfs.*;\n\nimport java.io.*;\n\npublic class FastDFSClient &#123;\n    private static final String CONF_FILENAME = Thread.currentThread().getContextClassLoader().getResource(\"\").getPath() + \"fdfs_client.conf\";\n\n    private static StorageClient storageClient = null;\n\n    /**\n     * 只加载一次.\n     */\n    static &#123;\n        try &#123;\n            ClientGlobal.init(CONF_FILENAME);\n            TrackerClient trackerClient = new TrackerClient(ClientGlobal.g_tracker_group);\n            TrackerServer trackerServer = trackerClient.getConnection();\n            StorageServer storageServer = trackerClient.getStoreStorage(trackerServer);\n            storageClient = new StorageClient(trackerServer, storageServer);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    /**\n     *\n     * @param inputStream\n     *    上传的文件输入流\n     * @param fileName\n     *    上传的文件原始名\n     * @return\n     */\n    public static String[] uploadFile(InputStream inputStream, String fileName) &#123;\n        try &#123;\n            // 文件的元数据\n            NameValuePair[] meta_list = new NameValuePair[2];\n            // 第一组元数据，文件的原始名称\n            meta_list[0] = new NameValuePair(\"file name\", fileName);\n            // 第二组元数据\n            meta_list[1] = new NameValuePair(\"file length\", inputStream.available()+\"\");\n            // 准备字节数组\n            byte[] file_buff = null;\n            if (inputStream != null) &#123;\n                // 查看文件的长度\n                int len = inputStream.available();\n                // 创建对应长度的字节数组\n                file_buff = new byte[len];\n                // 将输入流中的字节内容，读到字节数组中。\n                inputStream.read(file_buff);\n            &#125;\n            // 上传文件。参数含义：要上传的文件的内容（使用字节数组传递），上传的文件的类型（扩展名），元数据\n            String[] fileids = storageClient.upload_file(file_buff, getFileExt(fileName), meta_list);\n            return fileids;\n        &#125; catch (Exception ex) &#123;\n            ex.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n\n    /**\n     *\n     * @param file\n     *            文件\n     * @param fileName\n     *            文件名\n     * @return 返回Null则为失败\n     */\n    public static String[] uploadFile(File file, String fileName) &#123;\n        FileInputStream fis = null;\n        try &#123;\n            NameValuePair[] meta_list = null; // new NameValuePair[0];\n            fis = new FileInputStream(file);\n            byte[] file_buff = null;\n            if (fis != null) &#123;\n                int len = fis.available();\n                file_buff = new byte[len];\n                fis.read(file_buff);\n            &#125;\n\n            String[] fileids = storageClient.upload_file(file_buff, getFileExt(fileName), meta_list);\n            return fileids;\n        &#125; catch (Exception ex) &#123;\n            return null;\n        &#125;finally&#123;\n            if (fis != null)&#123;\n                try &#123;\n                    fis.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    /**\n     * 根据组名和远程文件名来删除一个文件\n     *\n     * @param groupName\n     *            例如 \"group1\" 如果不指定该值，默认为group1\n     * @param remoteFileName\n     *            例如\"M00/00/00/wKgxgk5HbLvfP86RAAAAChd9X1Y736.jpg\"\n     * @return 0为成功，非0为失败，具体为错误代码\n     */\n    public static int deleteFile(String groupName, String remoteFileName) &#123;\n        try &#123;\n            int result = storageClient.delete_file(groupName == null ? \"group1\" : groupName, remoteFileName);\n            return result;\n        &#125; catch (Exception ex) &#123;\n            return 0;\n        &#125;\n    &#125;\n\n    /**\n     * 修改一个已经存在的文件\n     *\n     * @param oldGroupName\n     *            旧的组名\n     * @param oldFileName\n     *            旧的文件名\n     * @param file\n     *            新文件\n     * @param fileName\n     *            新文件名\n     * @return 返回空则为失败\n     */\n    public static String[] modifyFile(String oldGroupName, String oldFileName, File file, String fileName) &#123;\n        String[] fileids = null;\n        try &#123;\n            // 先上传\n            fileids = uploadFile(file, fileName);\n            if (fileids == null) &#123;\n                return null;\n            &#125;\n            // 再删除\n            int delResult = deleteFile(oldGroupName, oldFileName);\n            if (delResult != 0) &#123;\n                return null;\n            &#125;\n        &#125; catch (Exception ex) &#123;\n            return null;\n        &#125;\n        return fileids;\n    &#125;\n\n    /**\n     * 文件下载\n     *\n     * @param groupName 卷名\n     * @param remoteFileName 文件名\n     * @return 返回一个流\n     */\n    public static InputStream downloadFile(String groupName, String remoteFileName) &#123;\n        try &#123;\n            byte[] bytes = storageClient.download_file(groupName, remoteFileName);\n            InputStream inputStream = new ByteArrayInputStream(bytes);\n            return inputStream;\n        &#125; catch (Exception ex) &#123;\n            return null;\n        &#125;\n    &#125;\n\n    public static NameValuePair[] getMetaDate(String groupName, String remoteFileName)&#123;\n        try&#123;\n            NameValuePair[] nvp = storageClient.get_metadata(groupName, remoteFileName);\n            return nvp;\n        &#125;catch(Exception ex)&#123;\n            ex.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n\n    /**\n     * 获取文件后缀名（不带点）.\n     *\n     * @return 如：\"jpg\" or \"\".\n     */\n    private static String getFileExt(String fileName) &#123;\n        if (StringUtils.isBlank(fileName) || !fileName.contains(\".\")) &#123;\n            return \"\";\n        &#125; else &#123;\n            return fileName.substring(fileName.lastIndexOf(\".\") + 1); // 不带最后的点\n        &#125;\n    &#125;\n\n&#125;\n\n  然后我们就可以来测试上传的操作了。\npublic static void main(String[] args) &#123;\n    try &#123;\n        File file = new File(\"D:/2.jpg\");\n        InputStream is = new FileInputStream(file);\n        String fileName = UUID.randomUUID().toString()+\".jpg\";\n        String[] result = FastDFSClient.uploadFile(is, fileName);\n        System.out.println(Arrays.toString(result));\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n访问即可：http://192.168.56.100:8888/group1/M00/00/00/wKg4ZGHcUE6AZA2UAAW8dIX5p50374.jpg\n  返回后的字符串的结构说明\n\n# 1.2 文件下载\n  文件下载的流程，如下\n\n  文件下载的流程为：\n\nclient 询问 tracker 需要下载的文件的 storage，参数为文件的标识 (group 加文件名)。\ntracker 根据客户端的参数返回一台可用的 storage。\nclient 根据返回的 storage 直接完成对应的文件的下载。\n\n  有了上面的基础，文件下载就非常简单了，我们只需要根据前面上传的文件的 group 和文件的存储路径就可以通过 StorageClient 中提供的 downloadFile 方法把对应的文件下载下来了，具体的代码如下\n/**\n * 文件下载\n */\npublic static void downloadFile()&#123;\n    try &#123;\n        InputStream is = FastDFSClient\n                .downloadFile(\"group1\", \"M00/00/00/wKg4ZGHcUE6AZA2UAAW8dIX5p50374.jpg\");\n        OutputStream os = new FileOutputStream(new File(\"D:/12.jpg\"));\n        int index = 0 ;\n        while((index = is.read())!=-1)&#123;\n            os.write(index);\n        &#125;\n        os.flush();\n        os.close();\n        is.close();\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n注意：StorageClient 是线程不安全的。那么我们的解决方案\n\n对文件的操作的每个方法我们做同步处理\n每次操作文件的时候我们都获取一个新的 StorageClient 对象\n\n第一种方式效率肯定是最低的，第二种方式每次都要建立新的连接效率同样的会受到影响，这时最好的方式其实是把 StorageClient 交给我们自定义的连接池来管理\n# 2.SpringBoot 整合\n  我们在实际工作中基本都是和 SpringBoot 整合在一起来使用的，那么我们就来看看 FastDFS 是如何在 SpringBoot 项目中来使用的。首先创建一个普通的 SpringBoot 项目，然后导入 fastdfs-spring-boot-starter 这个依赖。\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n    &lt;/dependency>\n\n    &lt;dependency>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n        &lt;scope>test&lt;/scope>\n    &lt;/dependency>\n\n    &lt;dependency>\n        &lt;groupId>com.luhuiguo&lt;/groupId>\n        &lt;artifactId>fastdfs-spring-boot-starter&lt;/artifactId>\n        &lt;version>0.2.0&lt;/version>\n    &lt;/dependency>\n&lt;/dependencies>\n  既然是一个 starter，那么必然会在 spring.factories 文件中提供对应的自动配置类。\n\n  可以看到给我们提供的配置类为 FdfsAutoConfiguration 进入后可以看到帮我们注入了很多的核心对象。\n\n  然后可以看到系统提供的配置信息，前缀为  fdfs\n\n  然后我们就可以在 application.properties 中配置 FastDFS 的配置信息了。\n\n  配置完成后我们就可以测试文件的上传下载操作了\n@SpringBootTest\nclass FastDfsSpringBootApplicationTests &#123;\n\n    @Autowired\n    public FastFileStorageClient storageClient;\n\n\n    @Test\n    void contextLoads() throws Exception&#123;\n        File file = new File(\"d:\\\\2.jpg\");\n        StorePath path = storageClient.uploadFile(null,new FileInputStream(file),file.length(),file.getName());\n        System.out.println(path.getFullPath());\n    &#125;\n\n&#125;\n文件操作成功\n\n","slug":"FastDFS","date":"2022-10-06T16:00:00.000Z","categories_index":"分布式,FastDFS","tags_index":"分布式,FastDFS","author_index":"雾都"},{"id":"b18709f70acfe8b26f3bb9db87cffd48","title":"MySQL高级部分","content":"# MySQL 性能调优\n\n\n\n\n\n\n\n\n\n环境：CentOS7.5\t\t\t\t\t Version：MySQL57.39\n# 主要内容\n1、MySQL 的架构介绍\n2、索引优化分析\n3、查询截取分析\n4、MySQL 的锁机制\n\n# MySQL 文件目录结构\n\n\n\n路径\n解释\n备注\n\n\n\n\n/var/lib/mysql/\nmysql 数据库文件的存放路径\n/var/lib/mysql/atguidgu.cloud.pid\n\n\n/usr/share/mysql\n配置文件目录\nmysql.server 命令及配置及文件\n\n\n/usr/bin/\n相关命令目录\nmysqladmin 、mysqldump 等相关命令\n\n\n/ect/init.d/mysql\n启停相关脚本\n\n\n\n\n# 主要配置文件\n1、二进制日志 log-bin ：主从复制\n2、错误日志 log-error ：默认是关闭的，记录严重的警告和错误信息，每次启动和关闭的详细信息等\n3、查询日志 log ：默认关闭，记录查询的 SQL 语句，如果开启就会降低 mysql 的整体性能\n4、数据文件 :\n\n\n系统\n\nWindows：本地安装的目录下 /data  目录下可以挑选很多库\nWindows：本地安装的目录下 /data  目录下可以挑选很多库\n\n\n\nfrm 文件： 存放表结构\n\n\nmyd 文件：存放表数据\n\n\nmyi 文件： 存放表索引\n\n\n# 逻辑架构\n\n# 1. 连接层\n​\t最上层是一些客户端和连接服务，包含本地 sock 通信和大多数基于客户端 / 服务端工具实现的类似于 tcplip 的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于 SSL 的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。\n# ⒉服务层\n​\t第二层架构主要完成大多少的核心服务功能，如 SQL 接口，并完成缓存的查询，SQL 的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是 select 语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。\n# 3. 引擎层\n​\t存储引擎层，存储引擎真正的负责了 MySQL 中数据的存储和提取，服务器通过 API 与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍 MylSAM 和 InnoDB\n常用的存储引擎：MyISAM、InnoDB (最常用)\n\n\n\n对比项\nMylSAM\nInnoDB\n\n\n\n\n主外键\n不支持\n支持\n\n\n事务\n不馳\n支持\n\n\n行表锁\n表锁，即使操作一条记录也会锁住整 个表，不适合高并发的操作\n行锁，操作时只锁某一行，不对其它 行有影响， 适合高并发的操作\n\n\n緩存\n只緩存索引，不缓存真实数据\n不仅缓存索引还要缓存真实数据，对 内存要求较高，而且内存大小对性能 有决定性的影响\n\n\n表空间\n小\n大\n\n\n关注点\n性能\n事务\n\n\n默认安装\nY\nY\n\n\n\n# 4. 存储层\n​\t数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。\n\n# 连接器\n▪  连接器负责跟客户端建立连接，获取权限、维持和管理连接\n– 用户名密码验证\n– 查询权限信息，分配对应的权限\n– 可以使用 show processlist 查看现在的连接\n– 如果太长时间没有动静，  就会自动断开，通过 wait_timeout 控制，默认 8 小时\n▪  连接可以分为两类：\n– 长连接：推荐使用，但是要周期性的断开长连接\n– 短链接：\n# 查询缓存\n▪  当执行查询语句的时候，会先去查询缓存中查看结果，之前执行 过的 sql 语句及其结果可能以 key-value 的形式存储在缓存中，如 果能找到则直接返回，如果找不到，就继续执行后续的阶段。\n▪  但是，不推荐使用查询缓存：\n– 1、查询缓存的失效比较频繁，只要表更新，缓存就会清空\n– 2、缓存对应新更新的数据命中率比较低\n# 分析器\n▪  词法分析：  Mysql 需要把输入的字符串进行识别每个部分代表什 么意思\n– 把字符串 T 识别成 表名 T\n– 把字符串 ID 识别成 列 ID\n▪  语法分析：\n▪  根据语法规则判断这个 sql 语句是否满足 mysql 的语法，如果不符 合就会报错 “You have an error in your SQL synta”\n# 优化器\n▪  在具体执行 SQL 语句之前，要先经过优化器的处理\n– 当表中有多个索引的时候，决定用哪个索引\n– 当 sql 语句需要做多表关联的时候，  决定表的连接顺序\n– 等等\n▪ 不同的执行方式对 SQL 语句的执行效率影响很大\n– RBO: 基于规则的优化\n– CBO: 基于成本的优化\n# SQL 性能下降原因\n\n查询语句写的烂\n索引失效\n关联查询太多 join\n服务器调优及各个参数设置（缓冲、线程数）\n…etc\n\n# SQL 语句机读过程\n人工：\n   SELECT DISTINCT\n       &lt;SELECT_list>\n   FROM\n       &lt;left_table> &lt;join_type>\n   Join &lt;right_table> on &lt;join_condition>\n   WHERE \n   \t&lt;WHERE_Condition>\n   GROUP BY\n   \t&lt;group_by_list>\n   HAVING\n   \t&lt;having_condition>\n   ORDER BY\n   \t&lt;order_by_condition>\nLIMIT &lt;limit_num>\n机器：\n\n注意第一步是 from --&gt; on --&gt; join --&gt;where --&gt;group by --&gt;having --&gt;select --&gt;order by --&gt;limit\nfrom &lt;left table>\n on &lt;on_condition>\n&lt;join_type> join &lt;join_table>\nwhere &lt;where_condition>\ngroup by &lt;group_by_list>\n\t&lt;sum()avg()等聚合函数>\nhaving &lt;having_condition>\nselect &lt;select_list>\ndistinct\norder by &lt;order_by_condition>\nlimit &lt;limit_number>\n# on 和 where 的区别？\n​\t简单地说，当有外关联表时，on 主要是针对外关联表进行筛选，主表保留，当没有关联表时，二者作用相同。\n例如在左外连时，首先执行 on，筛选掉外连表中不符合 on 表达式的数据，而 where 的筛选是对主表的筛选。\n# MySql 执行顺序理解\n第一步：加载 from 子句的前两个表计算笛卡尔积，生成虚拟表 vt1；\n第二步：筛选关联表符合 on 表达式的数据，保留主表，生成虚拟表 vt2；\n第三步：如果使用的是外连接，执行 on 的时候，会将主表中不符合 on 条件的数据也加载进来，做为外部行\n第四步：如果 from 子句中的表数量大于 2，则重复第一步到第三步，直至所有的表都加载完毕，更新 vt3；\n第五步：执行 where 表达式，筛选掉不符合条件的数据生成 vt4；\n第六步：执行 group by 子句。group by 子句执行过后，会对子句组合成唯一值并且对每个唯一值只包含一行，生成 vt5,。一旦执行 group by，后面的所有步骤只能得到 vt5 中的列（group by 的子句包含的列）和聚合函数。\n第七步：执行聚合函数，生成 vt6；\n第八步：执行 having 表达式，筛选 vt6 中的数据。having 是唯一一个在分组后的条件筛选，生成 vt7;\n第九步：从 vt7 中筛选列，生成 vt8；\n第十步：执行 distinct，对 vt8 去重，生成 vt9。其实执行过 group by 后就没必要再去执行 distinct，因为分组后，每组只会有一条数据，并且每条数据都不相同。\n第十一步：对 vt9 进行排序，此处返回的不是一个虚拟表，而是一个游标，记录了数据的排序顺序，此处可以使用别名；\n第十二步：执行 limit 语句，将结果返回给客户端\n\n# 索引\n​\tMySQL 官方对索引的定义为：索引 (Index）是帮助 MySQL 高效获取数据的数据结构。可以得到索引的本质: 索引是数据结构。\n可以简单理解为 “排好序的快速查找数据结构”\n一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上\n我们平常所说的索引，如果没有特别指明，都是指 B 树 (多路搜索树，并不一定是二叉的) 结构组织的索引。其中聚集索引，次要索引，复合索引，前缀索引，唯一索引默认都是使用 B + 树索引，统称索引。当然，除了 B + 树这种类型的索引之外还有哈稀索引 (hash，index) 等。\n简单来说最大的作用就是 排序 和 查询\n# 目的\n提高查询效率，可以类比字典，\n如果要查 “mysql” 这个单询，我们肯定需要定位到 m 字母，然后从下往下找到 y 字母，再找到剩下的 sql。\n如果没有索引，那么你可能需要 a----z，如果我想找到 Java 开头的单词呢？或者 Oracle 开头的单词呢？\n 是不是觉得如果没有索引，这个事情根本无法完成？\n# 详解\n​\t在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。\n下图就是一种可能的索引方式示例:\n\n​\t\t\t\t左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址\n​\t为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录.\n# 优劣\n优势：\n​\t类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的 IO 成本\n​\t 通过索引列对数据进行排序，降低数据排序的成本，降低了 CPU 的消耗\n劣势：\n​\t1、实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间\n​\t2、虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT、UPDATE 和 DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，\n都会调整因为更新所带来的键值变化后的索引信息\n​\t3、索引只是提高效率的一个因素，如果你的 MySQL 有大数据量的表，就需要花时间研究建立最优秀的索引\n# 分类\n\n单值索引：即一个索引只包含单个列，一个表可以有多个单列索引\n唯一索引：索引列的值必须唯一，但允许有空值\n复合索引：即一个索引包含多个列\n\n# 基本语法\n\n\n创建：\n\nCREATE\t [UNIQUE ]INDEX  \tindexName   \tON   \tmytable(columnname(length));\nCREATE\t [UNIQUE ]INDEX      indexName   \tON   \tmytable(columnname(length));\n\n\n\n删除\n\nDROP \tINDEX \t[indexName] \tON \tmytable;\n\n\n\n查看\n\nSHOW \t\tINDEX \t\tFROM \t\ttable_name\\G\n\n\n\n使用 ALTER 命令\n\n\n# MySQL 索引结构\n\n\nBTree 索引\n\n\nHash 索引\n\n\nFull-Text 全文索引\n\n\nR-Tree 索引\n\n\n# 哪些情况下需要创建索引\n\n\n主键自动建立唯一索引\n\n\n频繁作为查询条件的字段应该创建索引\n\n\n查询中与其它表关联的字段，外键关系建立索引\n\n\n频繁更新的字段不适合创建索引 or 因为每次更新不单单是更新了记录还会更新索引\n\n\nWhere 条件里用不到的字段不创建索引\n\n\n单键 / 组合索引的选择问题，who?(在高并发下倾向创建组合索引)\n\n\n查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度\n\n\n查询中统计或者分组字段\n\n\n# 哪些情况不建索引\n\n\n表记录太少\n\n\n经常增删改的表\nWhy: 提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT、UPDATE 和 DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件\n\n\n数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。\n\n\n# 性能分析\n# MySql Query Optimizer\n\n\nMysql 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间)\n\n\n当客户端向 MySQL 请求一条 Query，命令解析器模块完成请求分类，区别出是 SELECT 并转发给 MySQLQuery Optimizer 时，MySQL Query Optimizer 首先会对整条 Query 进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query 中的 Hint 信息 (如果有），看显示 Hint 信息是否可以完全确定该 Query 的执行计划。如果没有 Hint 或 Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。\n\n\n# MysQL 常见瓶颈\nCPU:CPU 在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候\nIO: 磁盘 I/O 瓶颈发生在装入数据远大于内存容量的时候\n服务器硬件的性能瓶颈: top,free, iostat 和 vmstat 来查看系统的性能状态\n# Explain\n# 作用\n​\t查看执行计划\n​\t使用 EXPLAIN 关键字可以模拟优化器执行 sQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈\n# 作用范围\n\n\n表的读取顺序   __ id__\n\n\n数据读取操作的操作类型哪些索引可以使用  possible key\n\n\n哪些索引被实际使用表之间的引用  key\n\n\n每张表有多少行被优化器查询    rows\n\n\n表之间的引用 table\n\n\n每张表有多少行被优化     rows\n\n\n# 使用方法\nexplain + SQL 语句\n# 执行计划包含的信息\nMySQL ：： MySQL 5.7 参考手册 ：： 8.8.2 EXPLAIN 输出格式\n\n\n\n列\nJSON 名称\n意义\n\n\n\n\nid\nselect_id\n标识符 SELECT\n\n\nselect type\n没有\n类型 SELECT\n\n\ntable\ntable_name\n输出行的表\n\n\npartitions\npartitions\n匹配的分区\n\n\ntype\naccess_type\n联接頰\n\n\npossible keys\npossible_keys\n可供选择的可能索引\n\n\nkey\nkey\n实际选择的索引\n\n\nkey 丄 en\nkey_length\n所选密钥的长度\n\n\nref\nref\n与索引相比的列\n\n\nrows\nrows\n要检查的行的估计值\n\n\nfiltered\nfiltered\n符合某条件的记录数百分比。\n\n\nExtra\nNone\n附加信息\n\n\n\n# 字段解释\n# id\nid 相同，执行顺序由上至下\nid 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行\nnull 为结果集的整合\n总结：\n\nid 如果相同，可以认为是一组，从上往下顺序执行；\nid 值越大，优先级越高，越先执行\n\n# select_type\n见下方附录\n# type\n\n\n\n类型\n性能\n注释\n\n\n\n\nsystem\n1\n表只有一行记录 (等于系统表), 这是 const 类型的特例，平时不会出现，可忽略\n\n\nconst\n2\n表示该表最多有一个匹配行通过索引一次就找到了，const 用于比较 primary key 或者unique 索引。因为只匹配一行数据，所以很快如将主键置于 where 列表中MySQL 就能将该查询转换为一个常量\n\n\neq_ref\n3\n唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描\n\n\nref\n4\n非唯一性索引扫描，返回匹配某个单独值的所有行.本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而， 它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体\n\n\nrange\n5\n只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的 where 语句中出现了 between、&lt;、&gt;、in 等的查询  这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引\n\n\nindex\n6\n联接类型与  ALL  相同，只是扫描了索引树。这以两种方式发生： index  Full Index Scan，index 与 ALL 区别为 index 类型只遍历索引树。这通常比 ALL 快，因为索引文件通常比数据文件小。(也就是说虽然 all 和 Index 都是读全表，但 index 是从索引中读取的，而 all 是从硬盘中读的)\n\n\nall\n7\n将遍历全表以找到匹配的行\n\n\n\n一般来说，得保证查询至少要达到 range 级别，最好能达到 ref \n# possible_key\n显示可能应用在这张表中的索引，一个或多个\n查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。\n# key\n实际使用的索引。如果为 NULL，则没有使用索引\n查询中若使用了覆盖索引，则该索引仅出现在 key 列表中\n引申：\n覆盖索引：简单来说就是你查询到的字段数目和你建立索引所对应字段相同且数量相同\n# key_len\n​\t表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好\n​\tkey_len 显示的值为索刳字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的\n# ref\n​\t显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值\n# rows\n​\t根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数\n# extra\n包含不适合在其他列中显示但十分重要的额外信息\n\n\nUsing filesort(索引本来就是排序和查找，这种等于只用了一半，而且排序本身就比较耗时)\n说明 mysq | 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。\nMySQL 中无法利用索引完成的排序操作称为 “文件排序 &quot;\n\n\nUsing temporay(严重影响性能)\n使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表。\n常见于排序 orderby 和分组查询 groupby。\n\n\nUsing  index\n表示相应的 select 操作中使用了覆盖索引 (Covering Index)，避免访问了表的数据行，效率不错！如果同时出现\nusing where，表明索引被用来执行索引键值的查找；\n如果没有同时出现 using where，表明索引用来读取数据而非执行查找动作。\n覆盖索引 (Covering Index)\n理解方式：就是 select 的数据列只用从索引中就能够取得，不必读取数据行，MySQL 可 以利用索引返回 select 列表中的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。\n注意:\n 如果要使用覆盖索引，一 - 定 要注意 select 列表中只取出需要的列，不可   Select   *\n 因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。\n\n\n# 索引优化\n# 单表优化\n准备\nCREATE TABLE IF NOT EXISTS article (\nid INT(10) UNSIGNED NOT NULL PRIMARY KEY auto_INCREMENT,\nauthor_id INT(10) UNSIGNED NOT NULL,\ncategory_id INT(10) UNSIGNED NOT NULL,\nviews INT(10) UNSIGNED NOT NULL,\ncomments INT(10) UNSIGNED NOT NULL,\ntitle VARBINARY(255) NOT NULL,\ncontent TEXT NOT NULL\n);\n\nINSERT INTO article ( author_id ,category_id ,views ,comments ,title,content ) VALUES\n(1, 1, 1, 1,'1','1'),\n(2,2, 2,2, '2','2'),\n(1, 1,3,3, '3','3');\n\n\n-- ----------------------------------------------\n-- 01\nexplain select id,author_id\nfrom article \nwhere category_id =1 and comments >1 \norder by views desc \nlimit 1\\G\n-- 01-1\ncreate index idx_id_article_ccv on article(category_id,comments,views);\ndrop index idx_id_article_ccv on article;\ncreate index idx_id_article_cv on article(category_id,views);\ndrop index idx_id_article_cv on article;\n-- 查看之后发现因为 > 1 的原因导致我们索引失效 我们直接放弃这个字段从三个改为两个字段的索引，性能更优\nexplain select id,author_id from article where category_id =1 and comments >1  order by views desc limit 1 ;\nexplain select id,author_id from article where category_id =1 and comments =1  order by views desc limit 1 ;\n# 双表优化\nCREATE TABLE IF NOT EXISTS `class`(\n`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,\n`card`INT(10) UNSIGNED NOT NULL,\n PRIMARY KEY (id)\n );\ncreate TABLE IF NOT EXISTS `book` (\n`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,\n`card`  INT(10) UNSIGNED NOT NULL,\n PRIMARY KEY (bookid)\n);\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO class(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\nINSERT INTO book(card) VALUES(FLOOR(1 + (rand() * 20)));\n-- ----------------------------------------------\nselect * from book;\nselect * from class;\n\n-- type=all\nshow index from book;\nshow index from class;\n\ncreate index idx_card on  book(card);\ncreate index idx_card on  class(card);\ndrop index idx_card on  book;\ndrop index idx_card on  class;\n\nexplain select * from  book left join class on class.card=book.card;\n\nexplain select * from  class left join book on class.card=book.card;\n左连接\n\n结果显示，在没有用索引的状况下我们的索引类型均为 ALL。\n因为是左连接的缘故我们的左表是根据右表搜索行的，左边一定都有，所以右边是我们的关键点，一定需要建立索引。\n\n可以看到第二行的 type 变为了 ref，rows 也变成了优化比较明显。这是由左连接特性决定的。LEFT  JOIN 条件用于确定如何从右表搜索行。所以右边是我们的关键点，- 定需要建立索引。\n同理可证右连接\n因为 RIGHTJOIN 条件用于确定如何从左表搜索行，右边一定都有，所以左边是我们的关键点，一定需要建立索引。\n# 三表优化\nCREATE TABLE IF NOT EXISTS phone(\n\tphoneid INT(10) UNSIGNED NOT null AUTO_INCREMENT,\n\tcard INT(10) UNSIGNED NOT NULL,\n\tPRIMARY KEY (phoneid)\n) ENGINE = INNODB;\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\nINSERT INTO phone(card) VALUES(FLOOR(1 + (RAND() * 20)));\n-- --------===============================================\nselect * from phone;\n\nalter table class add index X (card); \nalter table phone add index Y (card); \ndrop index X on class;\ndrop index Y on phone;\n\nexplain select * from class left join book on class.card = book.card join phone on book.card = phone.card;\n\nshow index from phone;\nshow index from book;\nshow index from class;\n初始结果\n\n优化后\n\n后 2 行的 type 都是 ref 且总 rows 优化很好效果不错。\n因此索引最好设置在需要经常查询的字段中\n解释：不论是 class 还是 phone 都是需要 book.card 来确定而且在第二个 join 中还需要全部扫描 book 所以尽管他是一个与 class 的左连接，理论上要给 book 建立一个索引，但是因为 phone 的关系我们倒不如给 phone 和 class 做索引，减少可以减少的，book 反正要全表无所谓。\n总结就是小结果集推动大结果集就可以起到优化作用\n# [结论]\nJoin 语句的优化\n尽可能减少 Join 语句中的 NestedL oop 的循环总次数；“永远用小结果集驱动大的结果集”。\n优先优化 Nested L oop 的内层循环；\n保证 Join 语句中被驱动表上 Join 条件 字段已经被索引；\n当无法保证被驱动表的 Join 条件字段被索引且内存资源充足的前提下，不要太吝惜 JoinBuffer 的设置；\n# 索引失效\n\n全值匹配我最爱\n\n\n\n\n\n\n\n\n\n\n​\t每个索引字段都存在\n\n最佳左前缀法则 (where 条件)\n\n\n\n\n\n\n\n\n\n\n​\t如果索引了多列 (3 个及以上)，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。\n​\t简单来说就是每个字段的带头大哥不能丢，中间兄弟不能断\n>drop table if exists tbl_user;\n>create table if not exists tbl_user(\nid int(10) primary key auto_increment,\n>name varchar(20) not null,\n>age int(10),\n\tsex int(2) check( sex in (1,2)),\n>email varchar(20)\n>);\n>-- 添加测试数据\n>delete from  tbl_user;\n>insert into tbl_user(name,age,sex,email) values \n>('aa11aa',12,1,'123@qq.com'),('aa22aa',22,2,'456@qq.com'),('aa33aa',32,2,'789@qq.com');\n>('aa11aa',22,1,'123@qq.com'),('aa22aa',22,1,'456@qq.com'),('aa33aa',32,1,'789@qq.com');\n>-- 走索引且key_len越来越长\n>explain select * from tbl_user where name = 'aa11aa';\n>explain select * from tbl_user where name = 'aa11aa' and age = 11;\n>explain select * from tbl_user where name = 'aa11aa' and age = 11 and sex = 1;\n\n>-- 走索引\n>explain select * from tbl_user where name = 'aa11aa'  and sex = 1;\n>-- 不走索引带头大哥没了\n>explain select * from tbl_user where age = 11 and sex = 1;\n\n\n不在索引列上做任何操作 (计算、函数 (自动 or 手动) 类型转换)，会导致索引失效而转向全表扫描\n\n\n存储引擎 不能使用索引中范围条件右边的列 (自己是最后一个)\n -- 范围条件\nalter table tbl_user add index idx_tbl_user_age_sex_email (age,sex,email);\n-- 全部走了索引\nexplain select age from tbl_user ;\nexplain select age,sex from tbl_user ;\nexplain select age,sex,email from tbl_user ;\n-- 部分走了索引\nexplain select age from tbl_user where sex > 1;\nexplain select age,sex from tbl_user where sex > 1;\nexplain select age,sex,email from tbl_user where sex > 1;\n\n\n尽量使用覆盖索引 (只访问索引的查询 (索引列和查询列一致))， 减少 select  *\n\n\nmysql 在使用不等于 (!= 或者 &lt;&gt; ) 的时候无法使用索引会导致全表扫描团\n\n\nis null ,is not null 也无法使用索引\n\n\nlike 以通配符开头 (’%abc…)mysq| 索引失效会变成全表扫描的操作。(放右边可以)\n问题：解决 like’% 字符串 %' 时索引不被使用的方法？？\n -- 建立索引\nalter table tbl_user add index idx_tbl_user_name_age (name,age);\n\n-- 测试\nselect * from tbl_user;\n-- 走索引\nexplain select id from tbl_user where name like '%aa%';\nexplain select name from tbl_user where name like '%aa%';\nexplain select age from tbl_user where name like '%aa%';\n-- 走索引\nexplain select id,name from tbl_user where name like '%aa%';\nexplain select id,name,age from tbl_user where name like '%aa%';\nexplain select name,age from tbl_user where name like '%aa%';\n-- 不走索引\nexplain select * from tbl_user where name like '%aa%';\nexplain select id,name,email from tbl_user where name like '%aa%';\nexplain select id,name,age,email from tbl_user where name like '%aa%';\n\n\n字符串不加单引号索引失效\n\n\n少用 or，用它来连接时会索引失效\n\n\n# 面试题\n-- indexc1234\nselect * from test03 where c1='a1' and c2='a2' and c5='a5' order by c3,c2;\nselect * from test03 where c1='a1' and c5='a5' order by c3,c2;\n这两种 SQL 的区别在哪？\n\n\n\n\n\n\n\n\n\n都走了索引，但是在第 2 条 SQL 会产生文件的内排序，为什么呢？这是因为本来应该是自动的顺序排列，即 c1,c2,c3… 默认，但是我们写了 order by 所以产生了内排。但是同样第 1 条 SQL 为什么没有呢？因为我们在 where 条件中使用了他让他固定成了一个常量 constant ，即 c3 虽然一直在动，但是 c2 已经固定没有了排序的过程所以不会产生内排的步骤\ndrop table if exists t1;\ncreate table t1(\n\tid int(10) primary key auto_increment,\n\tc1 int(10),\n\tc2 int(10),\n\tc3 int(10),\n\tc4 int(10),\n\tc5 int(10)\n);\ninsert into t1(c1,c2,c3,c4,c5) values\n(1,1,1,1,1)\n(2,2,2,2,2),\n(3,3,3,3,3),\n(4,4,4,4,4),\n(5,5,5,5,5);\n\nalter table t1 add index idx_c1234 (c1,c2,c3,c4); \nexplain select * from t1 where c1 =1 and c2 = 1 and c4 = 1 ORDER BY c3,c2 desc;\nexplain select * from t1 where c1 =1 and c4 = 1 ORDER BY c3,c2 ;  \n结果：\n\n同理论证 gourp by\n\n分组之前比排序，可能会产生临时表的产生\n\n\n# 建议\n\n\n对于单键索引，尽量选择针对当前 query 过滤性更好的索引\n\n\n在选择组合索引的时候，当前 Query 中过滤性最好的字段在索引字段顺序中，位置越靠前越好。\n\n\n在选择组合索引的时候，尽量选择可以能够包含当前 query 中的 where 字句中更多字段的索引\n\n\n尽可能通过分析统计信息和调整 query 的写法来达到选择合适索引的目的\n\n\n# 口诀\n全值匹配我最爱\t，最左前缀要遵守；\n帶头大哥不能死\t，中间兄弟不能断；\n索引列上少计算\t，范围之后全失效；\nLIKE 百分写最右\t，覆盖索引不写星；\n不等空值还有 or     ，索引失效要少用；\nVAR 的引号不可丢，SQL 高级也不难！\n\n# 查询截取分析\n# 内容：\n​\t查询优化\n​\t慢查询日志\n​\t批量数据脚本\n​\tshow profile\n​\t全局查询日志\n# 工作一般流程 (分析过程)\n\n观察，至少跑 1 天，看看生产的慢 SQL 情况。\n开启慢查询日志，设置阙值，比如超过 5 秒钟的就是慢 SQL，并将它抓取出来。\nexplain + 慢 SQL 分析\nshow profile\n运维经理 or DBA，进行 SQL 数据库服务器的参数调优。。\n\n总结\n\n\n慢查询的开启并捕获\n\n\nexplain + 慢 SQL 分析\n\n\nshow profile 查询 SQL 在 Mysql 服务器里面的执行细节和生命周期情况\n\n\nSQL 数据库服务器的参数调优。\n\n\n# 查询优化\n# 永远小表驱动大表，即小的数据集驱动大的数据集\n小表驱动大表，类似嵌套循环 Nested Loop\n# Case 1：\nfor(int i =5;;)&#123;\n    for(int j = 1000;;)&#123;\n        \n    &#125;\n&#125;\nfor(int i =1000;;)&#123;\n    for(int j = 5;;)&#123;\n        \n    &#125;\n&#125;\n两个简单的 for 循环，但是在 SQL 中我们就应该选择 第一个循环而不是第二个\n\n小的循环在外层，表连接需要 5 次\n大的循环在外层，表连接需要 1000 次，浪费数据库资源\n\n总结: 小表驱动大表的主要目的是通过减少表连接创建的次数，加快查询速度.\n# Case 2\nselect * from A where  id in (select id from B)\n-- 等价于\nfor select id from B\nfor select * from A where A.id = B.id\nfor（B)&#123;\n\tfor(A)&#123;\n\t\tA.id=B.id\n\t&#125;\n&#125;\n当 B 表的数据集小于 A 表的数据集时，用 in 优于 exists。\nselect * from A where exists (select 1 from B where B.id = A.id)\n-- 等价于\nfor select* from A\nfor select * from B where B.id = A.id\nfor（A)&#123;\n\tfor(B)&#123;\n\t\tA.id=B.id\n\t&#125;\n&#125;\n当 A 表的数据集小于 B 表的数据集时，用 exists 优于 in。\n注意：A 表与 B 表的 ID 字段应建立索引。\n\nEXISTS\n\n\n\n\n\n\n\n\n\n\n语法：SELECT .…… FROM table WHERE EXISTS (subquery)\n​\t该语法可以理解为。将主查询的数据，放到子查询中做条件验证，根据验证结果（TRUE 或 FALSE) 来决定主查询的数据结果是否得以保留。\n\n提示\n\nEXSTS (stbuey) 只返回 TRUE 或 FALSE，因此子查询中的 SELECT * 也可以是 SELECT  1 或是 SELECT ‘X’。官方说法是：实际执行时会忽略 SELECT 清单，因此没有区别\nEXSTS 子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担忧效率问题，可进行实际检验以确定是否有效率问题。\nEXISTS 子查询往往也可以用条件表达式、其他子查询或者 JOIN 来替代，何种最优需要具体问题具体分析\n\n\n\n# 为排序使用索引 OrdeBy 优化\nMySQL 支持二种方式的排序，FileSort 和 Index，Index 效率高。\n它指 MySQL 扫描索引本身完成排序。FileSort 方式效率较低。\nORDER BY 满足两情况，会使用 Index 方式排序：\n\n\nORDER BY 语句使用索引最左前列\n\n\n使用 where 字句与 Order By 字句条件列组合满足索引最左前列\n\n\n建议：\n​\t尽量使用 Index 方式排序，避免使用 FileSort 方式排序尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀\n如果不在索引列上，filesort 有两种算法：mysql 就要启动双路排序和单路排序\n双路排序\n\n\n\n\n\n\n\n\n\nMySQL 4.1 之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，\n读取行指针和 orderby 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出\n从磁盘取排序字段，在 buffer 进行排序，再从磁盘取其他字段。\n取一批数据， 要对磁盘进行了两次扫描，众所周知，I\\O 是很耗时的，所以在 mysql4.1 之后，出现了第二种改进的算法，就是单路排序\n单路排序\n\n\n\n\n\n\n\n\n\n从磁盘读取查询需要的所有列，按照 order by 列在 buffer 对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 I0, 但是它会使用更多的空间，因为它把每一行都保存在内存中了。\n结论：\n​\t由于单路是后出的，总体而言好过双路！\n引申出来的问题：\n\n\n\n\n\n\n\n\n\n​\t在 sort_buffer 中，方法 B 比方法 A 要多占用很多空间，因为方法 B 是把所有字段都取出，所以有可能取出的数据的总大小超出了 sort_buffer 的容量，导致每次只能取 sort_buffer 容量大小的数据，进行排序（创建 tmp 文件，多路合并〉，排完再取取 sort_buffer 容量大小，再排…… 从而多次 I/O。本来想省一次 I/O 操作，反而导致了大量的 I/O 操作，反而得不偿失。\n优化策略\n\n增大 sort_buffer_size 参数的设置\n增大 max_length_for_sort_data 参数的设置\n\n提高 Order By 的速度\n\n\nOrder by 时 select 是一个大忌只 Query 需要的字段，这点非常重要。在这里的影响是:\n\n当 Query 的字段共小总和小于 max_length_for_sort_data 而且排序字段不是 TEXTIBLOB 类型时，会用改进后的算法 —— 单路排序，否则用老算法 —— 多路排序。\n两种算法的数据都有可能超出 sort_buffer 的容量，超出之后，会创建 tmp 文件进行合并排序，导致多次 IO，但是用单路排序算法的风险会更大一些，所以要提高 sort_buffer_size.\n\n\n\n尝试提高 sort_buffer_size\n 不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的\n\n\n尝试提高 max_length_for_sort_data\n 提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大，明显症状是高的磁盘 I/O 活动和低的处理器使用率.\n\n\n# Group By\ngroup by 实质是先排序后进行分组，遵照索引建的最佳左前缀\n当无法使用索引列，增大 max_length_for_sort_data 参数的设置 + 增大 sort_buffer_size 参数的设置\nwhere 高于 having，能写在 where 限定的条件就不要去 having 限定了。\n其余均和 Order by 相同\n# 慢查询日志\n\n\nMySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阀值的语句，具体指运行时间超过 long_query_time 值的 SQL，则会被记录到慢查询日志中。\n\n\n具体指运行时间超过 long_query_time 值的 SQL，则会被记录到慢查询日志中。long_query_time 的默认值为 10，意思是运行 10 秒以上的语句。\n\n\n由他来查看哪些 SQL 超出了我们的最大忍耐时间值，比如一条 sql 执行超过 5 秒钟，我们就算慢 SQL，希望能收集超过 5 秒的 sql，结合之前 explain 进行全面分析。\n\n\n# 操作说明\n默认情况下，MySQL 数据库没有开启慢查询日志，需要我们手动来设置这个参数。\n当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件\n# 查看是否开启及开启\n默认：\nshow variables like '%slow_query_log%'; -- OFF关闭\n\n开启\n开启了慢查询日志只对当前数据库生效，如果 MySQL 重启后则会失效。\nset global slow_query_log=1;\n如果要永久生效，就必须修改配置文件 my.cnf（其它系统变量也是如此)\n修改 my.cnf 文件，[mysqld] 下增加或修改参数\n slow_query_log 和 slow_query_log_file 后，然后重启 MySQL 服务器。也即将如下两行配置进 my.cnf 文件\nslow_query_log =1\nslow_query_log_file=/var/lib/mysqlslow-slow.log\n关于慢查询的参数 slow_query_log_file，它指定慢查询日志文件的存放路径，系统默认会给一个缺省的文件 host_name-slow.log(如果没有指定参数 slow_query_log_file 的话)\n# 那么开启了慢查询日志后，什么样的 SQL 才会记录到慢查询日志里面呢？\n这个是由参数 long_query_time 控制，默认情况下 long_query_time 的值为 10 秒，命令:\nSHoW VARIABLES LIKE 'long_query_time%;\n\n可以使用命令修改，也可以在 my.cnf 参数里面修改。\n假如运行时间正好等于 long_query_time 的情况，并不会被记录下来。也就是说，在 mysql 源码里是判断大于 long_query_time，而非大于等于。\n# Case\n\n查看当前多少秒算慢\n\nSHOW VARIABLES LIKE 'long_query_time%';\n\n设置慢的阙值时间\n\nset global long_query_time=3;\n\n\n为什么设置后看不出变化？\n\n需要重新连接或新开一个会话才能看到修改值\nSHow VARIABLES LIKE 'long _query_time%';\n\nshow global variables like 'long_query_time';\n\n记录慢 SQL 并后续分析 R\n\nselect sleep(4);-- 睡4s\n-- 查看日志\n\n\n查询当前系统中有多少条慢查询记录冒 R\n\nshow global status like '%Slow_queries%';\n\n# 配置版\n【mysqld】下配置:\n# 开启查询日志\nslow_query_log=1;\n# 日志地址\nslow_query_log_file=/var/lib/mysql/atguigu-slow.log\n# 最大的查询时间，超过就算是慢查询\nlong_query_time=3;\n# 日志输出\nlog_output=FILE\n# 日志分析工具 —mysqldumpslow\n​\t在生产环境中，如果要手工分析日志，查找、分析 SQL，显然是个体力活，MySQL 提供了日志分析工具 mysqldumpslow\n查看 mysqldumpslow 的帮助信息\nmysqldumpslow --help\n\n\n\n常用参数\n注解\n\n\n\n\ns\n是表示按照何种方式排序\n\n\nc\n访问次数\n\n\nl\n锁定时间\n\n\nr\n返回记录\n\n\nt\n查询时间\n\n\nal\n平均锁定时间\n\n\nar\n平均返回记录数\n\n\nat\n平均查询时间\n\n\nt\n即为返回前面多少条的数据；\n\n\ng\n后边搭配一个正则匹配模式，大小写不敏感的；\n\n\n\n得到返回记录集最多的10个SQL\nmysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log\n\n得到访问次数最多的10个SQL\nmysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log\n\n得到按照时间排序的前10条里面含有左连接的查询语句\nmysqldumpslow -s t -t 10 -g \"left join\"lar/lib/mysql/atguigu-slow.log\n\n另外建议在使用这些命令时结合|和more使用，否则有可能出现爆屏情况\nmysqldumpslow -s r -t 10 /ar/lib/mysql/atguigu-slow.log | more\n# 批量数据脚本\n1. 建表 (dept,emp)\n2. 设置参数 log_bin_trust_function_creatorst\n-- 创建函数，假如报错:This function has none of DETERMINISTIC\n\n-- 由于开启过慢查询日志，因为我们开启了bin-log,我们就必须为我们的function指定一个参数。\nshow variables like 'log_bin_trust_function_creators';\nset global log_bin_trust_function_creators=1;\n-- 这样添加了参数以后，如果mysqld重启，上述参数又会消失，永久方法:\nI\nwindows下my.ini[mysqld]加上log_bin_trust_function_creators=1\nlinux下letc/my.cnf 下my.cnf[mysqld]加上log_bin_trust_function_creators=1\n3. 创建函数，保证每条数据都不同\n随机产生字符串\n随机产生部门编号\nDELIMITER $$\nCREATE FUNCTION rand_string(n lNT) RETURNS VARCHAR(255）\nBEGIN\n    DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijlklmnoparstuvwxyABCDEFJHIJKLMNOPQRSTUWWXYZ';\n    DECLARE return_str VARCHAR(255) DEFAULT '' ;\n    DECLARE i INT DEFAULT 0;\n    WHILE i &lt; n DO\n        SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1);\n        SET i =i+ 1;\n    END WHILE;\n    RETURN return_str;\nEND\n$$\nDFLIMITER ;\n                               \ndelimiter $$\nCREATE FUNCTLON rand_num( )RETURNS INT(5)\nBEGIN\n    DECLARE i int default 0;\n    SET i = FLOOR(100+RAND()*10);\n    RETURN i;\nEND \ndelimiter $$\nDFLIMITER ;\n4. 创建存储过程\n创建往emp表中插入数据的存储过程\nDELIMITER $$\nCREATE PROCEDURE insert_emp(IN START INT(10),IN max_num INT(10))\nBEGIN\n    DECLARE i INT DEFAULT 0;\n    #set autocomnit = 0 把autocommit设置成0\n    SET autocommit =0;\n    REPEAT\n    SET i=i+ 1;\n    INSERT INTo emp(empno，ename , job ,mgr ,hiredate ,sal ,comm ,deptno ) values((SEAR+i) ,rand_string(6), 'sAESLsy',0001,now(),1000,0,10);\n    UNTIL i = max_num;\n    END REPEAT;\n    COMMIT;\nEND \n$$\nDFLIMITER ;\n\n创建往dept表中插入数据的存储过程\nDFLIMITER $$\nCREATE PROCEDURE insert_dept(IN START INT(10),IN max_num lNT(10))\nBEGIN\n    DECLARE i lNT DEFAULT 0;\n    SET autocommit = 0;\n    REPEAT\n    SETi= i+1;\n    INSERT INTO dept (deptno ,dname,loc ) VALUES((START+i) ,rand_string(10),rand_string(8);\n    UNTIL i = max_num;\n    END REPEAT;COMMIT;\nEND $$\nDFLIMITER ;\n5. 调用存储过程\ncall insert_emp(10001,50000);\ncall inser_dept(100,10);\n# Show profile\n是什么：是 mysql 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于 SQL 的调优的测量\n官网: http://dev.mysql.com/doc/refman/5.5/en/show-profile.html\n默认情况下，参数处于关闭状态，并保存最近 15 次的运行结果\n分析步骤\n1. 是否支持，看看当前的 mysql 版本是否支持\nshow variables like 'profiling';\n-- 默认是关闭，使用前需要开启\n2. 开启功能，默认是关闭，使用前需要开启\nset profiling=on;\nshow variables like 'profiling';\n3. 运行 SQL\nselect * from emp;\n\nselect * from emp e join dept d on e.deptno =d.deptno;\n\nselect * from emp group by id%10 limit 1500;\n\nselect * from emp group by id%20 order by 5;\n4. 查看结果，show profiles;\nshow profiles;\n\n5. 诊断 SQL，\nshow profile cpu,block io for query 3;-- 最后数字是上一步前面的SQL的Id;\n\n\n\n常用参数\n注释\n\n\n\n\nALL\n显示所有的开销信息\n\n\nBLOCK IO\n显示块 IO 相关开销\n\n\nCONTEXT SWITCHES\n上下文切换相关开销\n\n\nCPU\n显示 CPU 相关开销信息\n\n\nIPC\n显示发送和接收相关开销信息\n\n\nMEMORY\n显示内存相关开销信息\n\n\nPAGE FAULTS\n显示页面错误相关开销信息 |\n\n\nSOURCE\n显示和 Source_function，Source_file，Source_line 相关的开销信息\n\n\nSWAPS\n显示交换次数相关开销的信息\n\n\n\n\n6. 日常开发需要注意的结论\n\n\nconverting HEAP to MyISAM     查询结果太大，内存都不够用了往磁盘上搬了。\n\n\nCreating tmp table       创建临时表\n\n拷贝数据到临时表\n用完再删除\n\n\n\nCopying to tmp table on disk      把内存中临时表复制到磁盘，危险！！!\n\n\nlocked    (死锁)\n\n\n# 全局查询日志\n永远不要在生产环境开启这个功能。\n配置启用\n#在mysql的my.cnf中，设置如下:\n#开启\ngeneral_log=1\n#记录日志文件的路径\ngeneral_log_file=/path/logfile\n#输出格式\nlog_output=FILE\n编码启用\n-- 命令\nset global general_log=1;\nset global log_output='TABLE';\n\n-- 此后，你所编写的sql语句，将会记录到mysql库里的general_log表，可以用下面的命令查看\nselect * from mysql.general_lpg;\n\n# MySQL 锁机制\n概述：锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源〈如 CPU、RAM、V/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。[\n打个比方，我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，那么如何解决是你买到还是另一个人买到的问题？\n\n这里肯定要用到事务，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。\n# 锁的分类\n\n\n从对数据操作的粒度分\n\n表锁 (偏读，解决幻读 (一个事务中对数据添加、删除，并且多次查询，每次结果不都相同))\n行锁 (偏写，解决重复读 (一个事务中对一条数据多次修改，并且多次查询，每次结果不都相同))\n\n\n\n从对数据操作的类型（读 \\ 写) 分\n\n读锁 (共享锁)：针对同一份数据，多个读操作可以同时进行而不会互相影响。\n写锁 (排它锁)：当前写操作没有完成前，它会阻断其他写锁和读锁。\n\n\n\n# 读锁 (案例介绍)\n准备：\ncreate table mylock(\nid int not null primary key auto_increment,\nname varchar(20)\n)engine myisam;\n\ninsert into mylock(name) values('a');\ninsert into mylock(name) values('b');\ninsert into mylock(name) values('c');\ninsert into mylock(name) values('d');\ninsert into mylock(name) values('e');\nselect * from mylock;\n\nCREATE TABLE `book` ( \n    `bookid` int(10) unsigned NOT NULL AUTO_INCREMENT,\n    `card` int(10) unsigned NOT NULL,\n    PRIMARY KEY (`bookid`),\n    KEY `idx_card` (`card`)\n) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;\ninsert into book(card) values(1);\ninsert into book(card) values(2);\ninsert into book(card) values(3);\ninsert into book(card) values(4);\ninsert into book(card) values(5);\n-- 手动添加表锁\n-- 语法：lock table Table_1_Name  read/write,Table_2_name read/write,..;\nlock table mylock read ;\n\n-- 查看锁\nshow open tables;\n\n-- 释放锁\nunlock tables;\n\t\nselect * from mylock;\t\n-- 读锁没有释放之前这个回话只能读取这个读锁表，其他回话可以查询或者更新未锁定的表\n-- 其他回话插入或者更新表的时候会进入阻塞状态，直至锁的释放\nupdate mylock set name = 'aa' where id =1;\nselect * from book;\n# 写锁 (案例介绍)\nSession 1 (产生锁)\nlock table mylock write;\n\nselect * from mylock; --ok\n\nupdate mylock set name ='aa' where  id =1; -- ok\n\nselect * from book;\n/*\nERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'uplock tables' at line 1\n*/\n\nunlock tables; \nSession 2\nselect * from mylock; -- block 阻塞住了 ,直至锁的释放才看到了\n# 读写结论\nMyISAM 在执行查询语句〈SELECT) 前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。\nMySQL 的表级锁有两种模式:\n​\t表共享读锁 (Table Read Lock)\n​\t表独享读锁 (Table Write Lock)\n\n\n\nlock_type\n是否共享\n读锁\n写锁\n\n\n\n\n读锁\n是\n是\n否\n\n\n写锁\n是\n否\n否\n\n\n\n结论:\n结合上表，所以对 MyISAM 表进行操作，会有以下情况:\n1、对 MyISAM 表的读操作〈加读锁)，不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。\n2、对 MyISAM 表的写操作（加写锁)，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。\n简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞。\n# 表锁 (案例介绍)\n【如何分析表锁定】\n可以通过检查 table_locks_waited 和 table_locks_immedlate 状态变量来分析系统上的表锁定:\nshow status like 'table%';\n\n这里有两个状态变量记录 MySQL 内部表级锁定的情况，两个变量说明如下:\nTable_locks_immediate: 产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加 1\nTable_locks_waited: 出现表级锁定争用而发生等待的次数 (不能立即获取锁的次数，每等待一次锁值加 1),\n 此值高则说明存在着较严重的表级锁争用情况；\n此外，Myisam的读写锁调度是写优先，这也是myisam不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞\n# 行锁 (案例介绍)\n# 特点\n\n\n\n\n\n\n\n\n\n​\t偏向 InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。\n​\tInnoDB 与 MyISAM 的最大不同有两点:\n​\t一、是支持事务（TRANSACTION);\n​\t二、是采用了行级锁\n# 事务知识复习\n# 四大特性\n事务是由一组 SQL 语句组成的逻辑处理单元，事务具有以下 4 个属性，通常简称为事务的 ACID 属性。\n\n\n原子性（Atomicity)﹔事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。\n\n\n一致性（Consistent): 在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如 B 树索引或双向链表）也都必须是正确的。\n\n\n隔离性（lsolation): 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的 “独立” 环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。\n\n\n持久性（Durable): 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。\n\n\n# 并发带来的问题\n更新丢失 (Lost Update)\n\n\n\n\n\n\n\n\n\n当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题――最后的更新覆盖了由其他事务所做的更新。\n例如，两个程序员修改同一 java 文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改。\n如果在一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题。\n脏读 (Dirty Reads)\n\n\n\n\n\n\n\n\n\n简单来说就是 读了未提交的，此时事务级别在最低，改善方法就是提高级别即可\n不可重复读 (Non-Repeatable Reads)\n\n\n\n\n\n\n\n\n\n简单来说就是在一个事务中多次读取某些数据，数据的条数没有变，但是数据却变了。\n重在修改\n幻读 (Phantom Reads)\n\n\n\n\n\n\n\n\n\n简单来说就是在一个事务中多次读取某些数据，数据的条数变了\n重在添加、删除\n# 事务的隔离级别\n\n# 面试题\n不可重复读和幻读的区别？如何解决？\n\n\n\n\n\n\n\n\n\n​\t他们都是在一个事务中对某些数据进行多次读取，但是不可重复读的问题重在多次读取的数据不都一致；幻读重在多次读取确得到不一样数据量的数据\n解决办法：\n​\t重复读加行数\n​\t幻读加表锁\n# 案例分析\n准备\ncreate table test_innodb_lock (\na int(11),\nb varchar(16)\n)engine=innodb;I\n\ninsert into test_innodb_lock values(1,'b2');\ninsert into test_innodb_lock values(3,'3');\ninsert into test_innodb_lock values(4,'4000');\ninsert into test_innodb_lock values(5,'5000');\ninsert into test_innodb_lock values(6,'6000');\ninsert into test_innodb_lock values(7,'7000');\ninsert into test_innodb_lock values(8,'80O0');\ninsert into test_innodb_lock values(9,'9000');\ninsert into test_innodb_lock values(10,'b1');\n\ncreate index test_innodb_a_ind  on test_innodb_lock(a);\ncreate index test_innodb_b_ind  on test_innodb_lock(b);\n-- 打开两个会话 并且都关闭自动提交\nset autocommit=0;\n# 行锁演示\n\n    \n        Session 1\n        Session 2\n        explain  \n    \n    \n        case 1\n    \n    \n        \n            \n            \n                关闭 Session 1 的自动提交\n            \n        \n        \n            \n            \n                关闭 Session 2 的自动提交\n            \n        \n        \n             \n                目的是:模拟高并发的情况下事务的处理情况，就好比一个SQL在修改但是没又被提交\n            \n            \n                在Innodb引擎作用下默认行锁，可以自动锁住我们当行数据保证数据的准确性\n            \n        \n    \n    \n      case 2\n    \n    \n        \n            \n            \n                Session 1 修改a=4的数据，不提交\n            \n        \n        \n            \n            \n                Session 2 无法查询到原有数据\n            \n        \n        \n        \t\n            \n        \n    \n    \n      case 3\n    \n    \n        \n            \n            \n                Session 1 提交事务\n            \n        \n        \n            \n            \n                Session 2 提交事务()\n            \n        \n        \n        \t>\n                Session 2 这里也可以当做是清除之前数据库累计事务\n            \n            \n            \n               如果不提交，我们的Session 2 还是原来的数据\n            \n        \n    \n    \n      case 4\n    \n    \n        \n            \n            \n            \n                Session 1 修改a=4的数据，不提交\n            \n        \n        \n                        \n            \n                Session 2 修改a=9的数据，不提交\n            \n        \n        \n        \t\n                两个 Session 操作不同的数据，互补影响，充分的体现了行锁的作用\n            \n        \n    \n    \n      case 5\n    \n    \n        \n            \n            \n            \n                Session 1 修改a=1的数据，不提交\n            \n        \n        \n                        \n            \n                Session 2 修改a=1的数据，不提交\n            \n        \n        \n        \t\n                两个 Session 操作相同的数据，互相影响\n            \n        \t\n                Session2 在 Session1 没有提交之前，直接处于阻塞状态\n            \n        \n    \n    \n      case 5\n    \n    \n        \n            \n            \n            \n                Session 1 修改a=4的数据，不提交\n            \n        \n        \n                        \n            \n                Session 2 修改a=9的数据，不提交\n            \n        \n        \n        \t\n                两个 Session 操作不同的数据，互补影响，充分的体现了行锁的作用\n            \n        \n    \n\n# 索引失效导致行锁变成表锁\n\n    \n        Session 1\n        Session 2\n        explain  \n    \n    \n        \n            \n        \n        \n            \n        \n        \n        \t        \n\t            我们在最开始准备阶段，就创建了关于a ,b 的索引(单索引)\n            \n        \t        \n\t            我们之前说过，在where上不要进行隐式转换，这样会导致索引失效\n            \n        \t        \n\t            从这个例子中我们左边进行了隐式操作，导致索引失效，第二个 Session\n            \n        \t        \n\t            直接进入到了阻塞状态，表明了我们的索引失效让行锁变成了表锁\n            \n    \t\n    \n    \n        \n            \n        \n        \n            \n        \n        \n        \t        \n\t           上面的例子中直至Session 1 回话结束，这时候释放了锁\n            \n        \t        \n\t          我们的 Session 2 才接受到了锁，进入了表\n            \n        \t        \n\t           这个例子充分的表明了，我们在操作中一定要注意索引失效的问题\n            \n        \t        \n                他有可能会导致我们效率更低\n            \n    \t\n    \n\n# 间隙锁的危害\n【概念】\n​\t当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并木存在的记录，叫做 “间隙（GAP)”，\nInnoDB 也会对这个 “间隙” 加锁，这种锁机制就是所谓的间隙锁（Next-Key 锁）。\n【危害】\n因为 Query 执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，\n而造成在锁定的时候无\n法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害\n-- session 1\nupdate t1 set b='12312' where a>1 and a&lt;8;\n\n-- session 2\ninsert into t1 values(5,'asda');\n\n明显的看到在 Session 1 执行结束之后，执行 Session 2 即使他们操作的不是同一行也会因为间隙锁的缘故锁定这一行，即使不存在也是如此，直到 commit 之后 Session 2 才反应\n# 如何锁定一行\n/*\nselect xoo.... for update锁定某一行后，其它的操作会械阻塞，直到锁定行的会话提交commit\n*/\nbegin;\nselect * from test_innodb_lock where a = 8 for update;\ncommit;\n# 案例结论\n​\tInnodb 存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于 MyISAM 的表级锁定的。当系统并发量较高的时候，Innodb 的整体性能和 MyIlSAM 相比就会有比较明显的优势了。\n​\t但是，Innodb 的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让 Innodb 的整体性能表现不仅不能比 MyISAM 高，甚至可能会更差。(索引失效行锁变表锁)\n# 如何分析行锁定\n通过检查 InnoDB_row_lock 状态变量来分析系统上的行锁的争夺情况\nshow status like 'innodb_row_lock%';\n\n对各个状态量的说明如下:\nInnodb_row_lock_current_waits：当前正在等待锁定的数量；\nInnodb_row_lock_time：队系统启动到现在锁定总时间长度；\nInnodb_row_lock_time_avg：每次等待所花平均时间；\nInnodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；\nInnodb_row_lock_waits：系统启动后到现在总共等待的次数；\n对于这 5 个状态变量，比较重要的主要是\nInnodb_row_lock_time_avg（等待平均时长），\nInnodb_row_lock_waits（等待总次数) ，\nlnnodb_row_lock_time（等待总时长）这三项。\n尤其是当等踌次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待\n然后根据分析结果着手指定优化计划。\n# 优化意见\n\n\n尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。\n\n\n合理设计索引，尽量缩小锁的范围\n\n\n尽可能较少检索条件，避免间隙锁\n\n\n尽量控制事务大小，减少锁定资源量和时间长度\n\n\n尽可能低级别事务隔离\n\n\n# 页锁 (案例介绍)\n开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。\n# 附录\n\n    Select_Type\n\n\n\n\nselect_type 价值\nJSON 名称\n意义\n\n\n\n\nSIMPLE\n没有\n简单选择（不使用 UNION 或子查询）\n\n\nPRIMARY\n没有\n多层子查询中最外层选择\n\n\nUNION\n没有\n联盟中的第二个或稍后的 SELECT 语句若第二个 SELECT 出现在 UNION 之后，则被标记为 UNION;若 UNION 包含在 FROM 子句的子查询中，外层 SELECT 将被标记为：DERIVED\n\n\nDEPENDENT UNION\ndependent(true)\nUNION 中的第二个或更高版本的 SELECT 语句，依赖于外部查询\n\n\nUNION RESULT\nunion_result\n从 UNION 表获取结果的 SELECT\n\n\nSUBQUERY\n没有\n子查询中的第一个 SELECT在 SELECT 或 WHERE 列表中包含了子查询\n\n\nDEPENDENT SUBQUERY\ndependent(true)\n子查询中的第一个 SELECT, 依赖于外部查询\n\n\nDERIVED\n没有\n派生表在 FROM 列表中包含的子查询被标记为 DERIVED (衍生) MySQL 会递归执行这些子查询，把结果放在临时表里。\n\n\nMATERIALIZED\nmaterial!zed_from_subquery\n实例化子查询\n\n\nUNCACHEABLE SU3QUERY\ncacheable(false)\n无法缓存其结果并且必须为外部查询的每一行重新计算其结果的子查询\n\n\nUNCACHEABLE UNION\ncacheable(false)\n在属于不可缓存子查询的 UNION 中的第二个或更高版本选择（请参见 UNCACHEABLE SUBQUERY）\n\n\n\n","slug":"MySQL_Super","date":"2022-10-06T16:00:00.000Z","categories_index":"数据库,MySQL","tags_index":"MySQL,数据库","author_index":"雾都"},{"id":"3244bafd4b77bc1eda4a2f2a047e0e05","title":"MybatisPlus","content":"# 简介\nMyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window) 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。\n\n\n\n\n\n\n\n\n\n愿景\n我们的愿景是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P、2P，基友搭配，效率翻倍。\n# 特性\n\n无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑\n损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作\n强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求\n支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错\n支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题\n支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作\n支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）\n内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用\n内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询\n分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库\n内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询\n内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作\n\n# 支持数据库\n\n\n\n\n\n\n\n\n\n任何能使用  MyBatis  进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。\n\nMySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb\n达梦数据库，虚谷数据库，人大金仓数据库，南大通用 (华库) 数据库，南大通用数据库，神通数据库，瀚高数据库\n\n# 框架结构\n\n# 快速使用\n\n\n\n\n\n\n\n\n\n使用的 mybatis 3.5 之前版本，也就是官方的旧版本\n# 初始化工程\n创建一个空的 Spring Boot 工程（工程将以 H2 作为默认数据库进行演示）\n提示\n可以使用 Spring Initializer (opens new window) 快速初始化一个 Spring Boot 工程\n#  pom  添加依赖\n&lt;!--模板引擎,也可使用freemarker-->\n&lt;dependency>\n    &lt;groupId>org.apache.velocity&lt;/groupId>\n    &lt;artifactId>velocity-engine-core&lt;/artifactId>\n    &lt;version>2.3&lt;/version>\n&lt;/dependency>\n\n&lt;!--代码生成器 -->\n&lt;dependency>\n    &lt;groupId>com.baomidou&lt;/groupId>\n    &lt;artifactId>mybatis-plus-generator&lt;/artifactId>\n    &lt;version>3.4.1&lt;/version>\n&lt;/dependency>\n\n&lt;!--内嵌mybatis，不需要在添加-->\n&lt;dependency>\n    &lt;groupId>com.baomidou&lt;/groupId>\n    &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId>\n    &lt;version>3.4.1&lt;/version>\n&lt;/dependency>\n\n\n&lt;dependency>\n    &lt;groupId>org.projectlombok&lt;/groupId>\n    &lt;artifactId>lombok&lt;/artifactId>\n&lt;/dependency>\n\n&lt;dependency>\n    &lt;groupId>org.mybatis.spring.boot&lt;/groupId>\n    &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId>\n    &lt;version>2.1.3&lt;/version>\n&lt;/dependency>\n\n&lt;dependency>\n    &lt;groupId>com.alibaba&lt;/groupId>\n    &lt;artifactId>druid-spring-boot-starter&lt;/artifactId>\n    &lt;version>1.1.10&lt;/version>\n&lt;/dependency>\n\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-jdbc&lt;/artifactId>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n&lt;/dependency>\n\n&lt;dependency>\n    &lt;groupId>mysql&lt;/groupId>\n    &lt;artifactId>mysql-connector-java&lt;/artifactId>\n    &lt;scope>runtime&lt;/scope>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n    &lt;scope>test&lt;/scope>\n    &lt;exclusions>\n        &lt;exclusion>\n            &lt;groupId>org.junit.vintage&lt;/groupId>\n            &lt;artifactId>junit-vintage-engine&lt;/artifactId>\n        &lt;/exclusion>\n    &lt;/exclusions>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>junit&lt;/groupId>\n    &lt;artifactId>junit&lt;/artifactId>\n&lt;/dependency>\n\n\n# 逆向工程\n测试用例\nimport com.baomidou.mybatisplus.core.toolkit.StringPool;\nimport com.baomidou.mybatisplus.generator.AutoGenerator;\nimport com.baomidou.mybatisplus.generator.InjectionConfig;\nimport com.baomidou.mybatisplus.generator.config.*;\nimport com.baomidou.mybatisplus.generator.config.po.TableInfo;\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\n\npublic class Generator &#123;\n\n    public static void main(String[] args) &#123;\n        //0自动生成\n        AutoGenerator autoGenerator = new AutoGenerator();\n\n        //1 数据源配置\n        DataSourceConfig datasource = new DataSourceConfig();\n        datasource.setUrl(\"jdbc:mysql://127.0.0.1:3306/xhshixun?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai\");\n        // dsc.setSchemaName(\"public\");\n        datasource.setDriverName(\"com.mysql.jdbc.Driver\");\n        datasource.setUsername(\"root\");\n        datasource.setPassword(\"root\");\n\n        autoGenerator.setDataSource(datasource);\n\n        // 2全局配置\n        GlobalConfig gc = new GlobalConfig();\n        /**\n         * System.getProperty(key)\n         * getProperty()这个方法是获取指定键指示的系统属性的。\n         * 如果key不是系统属性本来系统自带的，需要用户自己设定采用。如果不设定，则为null\n         */\n        String projectPath = System.getProperty(\"user.dir\");\n        //与其等同  ||\n        // String projectPath = \"E:\\\\code\\\\java\\\\test\";\n\n        //生成在那个目录下\n        gc.setOutputDir(projectPath + \"/src/main/java\");\n        gc.setOpen(false);//生成之后打开目录？是在资源管理器中打开的\n        gc.setAuthor(\"zjj\");//作者\n        gc.setFileOverride(true);//是否覆盖原来文件\n        //gc.setMapperName(\"%sDao\");//设置数据层接口名，%s指代模块名,默认是*Mapper\n        gc.setMapperName(\"%sMapper\");\n        // ,,,其余自行探索\n//        gc.setSwagger2(true);// 实体属性 Swagger2 注解\n        autoGenerator.setGlobalConfig(gc);\n\n        //3 包配置\n        PackageConfig pc = new PackageConfig();\n        //pc.setModuleName(null); //模块名\n        pc.setParent(\"com.aaa\");\n        pc.setEntity(\"pojo\");   //设置实体类包名\n        pc.setMapper(\"mapper\"); //设置mapper层包名\n        //,,,其余自行探索\n        autoGenerator.setPackageInfo(pc);\n\n        //4自定义配置\n        // 如果模板引擎是 freemarker\n        //String templatePath = \"/templates/mapper.xml.ftl\";\n        // 如果模板引擎是 velocity\n        //String templatePath = \"/templates/mapper.xml.vm\";\n        String templatePath = \"/templates/service.java.vm\";\n\n\n\n        // 4自定义配置\n        InjectionConfig cfg = new InjectionConfig() &#123;\n            @Override\n            public void initMap() &#123;\n                // to do nothing\n            &#125;\n        &#125;;\n        // 自定义输出配置\n        List&lt;FileOutConfig> focList = new ArrayList&lt;>();\n        // 自定义配置会被优先输出\n        focList.add(new FileOutConfig(templatePath) &#123;\n            @Override\n            public String outputFile(TableInfo tableInfo) &#123;\n                // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！\n                return projectPath + \"/src/main/resources/mapper/\" + pc.getModuleName()\n                        + \"/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML;\n            &#125;\n        &#125;);\n        cfg.setFileOutConfigList(focList);\n        autoGenerator.setCfg(cfg);\n\n        // 5配置模板\n        TemplateConfig templateConfig = new TemplateConfig();\n\n        // 配置自定义输出模板\n        //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别\n        // templateConfig.setEntity(\"templates/entity2.java\");\n        // templateConfig.setService();\n        // templateConfig.setController();\n\n        templateConfig.setXml(null);\n        autoGenerator.setTemplate(templateConfig);\n\n        //提交配置\n        autoGenerator.setPackageInfo(pc);\n\n\n        //6策略设置\n        StrategyConfig strategyConfig = new StrategyConfig();\n\n        //strategyConfig.setInclude(\"tbl_user\");//设置当前参与生成的表名，参数为可变参数\n        strategyConfig.setTablePrefix(\"tbl_\");//设置数据库表的前缀，模块名=数振库表名+前缀名\n\n//        strategyConfig.setRestControllerStyle(true);//设置是否启用Rest风格\n//        strategyConfig.setVersionFieldName(\"version\");//设置乐观锁宁段名\n//        strategyConfig.setLogicDelet  eFieldName(\"deleted\");//设置逻辑删除字段将\n//        strategyConfig.setEntityLombokModel(true);//设置是否启用Lombok\n//        strategyConfig.setControllerMappingHyphenStyle(true); //url中驼峰转连字符\n\n        autoGenerator.setStrategy(strategyConfig);\n\n        //执行生成操作\n        autoGenerator.execute();\n    &#125;\n\n    @Test\n    public void test()&#123;\n        //获取所有的属性\n        Properties properties = System.getProperties();\n        //为了看看系统的属性有几个，加了一个计数器\n        int count = 0;\n        //遍历所有的属性\n        for (String key : properties.stringPropertyNames()) &#123;\n            System.out.println(key + \"=\" + properties.getProperty(key));\n            count++;\n            if (key.equalsIgnoreCase(\"jdbc.drivers\"))&#123;\n                System.out.println(\"YES\");\n                return ;\n            &#125;\n\n        &#125;\n        System.out.println(count);\n    &#125;\n&#125;\n\n","slug":"MybatisPlus","date":"2022-10-06T16:00:00.000Z","categories_index":"MybatisPlus","tags_index":"框架,ORM","author_index":"雾都"},{"id":"54e1d69dbe01003cc0c2e45b21bc6b3e","title":"Mybatis","content":"# 1 Mybatis 入门\n原生 JDBC 实现 CURD 的问题\n\n\n\n\n\n\n\n\n\n1 编码繁琐\n 2 需要我们自己将结果集映射成对象\n 3 性能不太好  连接池 缓存\n 4 SQL 语句和 java 代码的耦合度特别高\n 5 … …\nMyBatis 本是 Apache 的一个开源项目 iBatis, 2010 年这个项目由 Apache Software Foundation 迁移到了 Google Code，且改名为 MyBatis 。2013 年 11 月迁移到 GitHub。iBATIS 一词来源于 “internet” 和 “abatis” 的组合，是一个基于 Java 的持久层框架。\nMyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs (Plain Ordinary Java Object, 普通的 Java 对象) 映射成数据库中的记录。\n\n# 1 认识框架\n框架（Framework）是一个框子 —— 指其约束性，也是一个架子 —— 指其支撑性。是一个基本概念上的结构，用于去解决或者处理复杂的问题。框架这个广泛的定义使用的十分流行，尤其在软件概念。\n框架 (Framework) 对于 java 来说，就是一系列为了解决特定问题而定义的一系列接口和实现类，在组织框架代码时，使用了一系列优秀的设计模式，使代码无论在性能上还是 API 操作上得到很大提升。框架可以看做是项目开发的半成品，基本的底层操作已经封装完毕，通过框架，程序员可以从底层代码中解脱出来，专注于业务逻辑的完成和性能的优化。框架规定了你的应用的体系结构。它定义了整体结构，类和对象的分割，各部分的主要责任，类和对象怎么协作，以及控制流程。框架预定义了这些设计参数，以便于应用设计者或实现者能集中精力于应用本身的特定细节。\n如果将开发完成的软件比作是一套已经装修完毕的新房，那框架就好比是一套已经修建好的毛坯房。用户直接购买毛坯房，建筑质量和户型合理有保证，还省去了自己建造房屋的时间，一举多得。\n在开发过程是使用框架，同样可以保证减少开发时间、降低开发难度，并且还保证设计质量。好比和世界上最优秀的软件工程师是一个项目的，并且他们完成的还是基础、全局的工作。想想是不是很嗨的一件事情。\n\n框架还有一个作用是约束。莎士比亚说，“一千个观众眼中有一千个哈姆雷特” 即仁者见仁，智者见智。说每个人都会对作品有不同的理解，每个人对待任何事物都有自己的看法，一千个人就有可能有一千种不同的看法 1000 人心中有 1000 个哈姆雷特。同样的技术解决同样的问题会产生不同流程和风格的解决方案，而采用一种框架其实就是限制用户必须使用其规定的方案来实现，可以降低程序员之间沟通以及日后维护的成本。\n常用的基于 JavaEE 的三大开源框架，已经从 SSH、SSH2 过渡到了 SSM：SpringMVC、Spring、MyBatis &gt;&gt;&gt; springBoot\n总之，框架是一个半成品，已经对基础的代码进行了封装并提供相应的 API，开发者在使用框架是直接调用封装好的 API 可以省去很多代码编写，从而提高工作效率和开发速度。\n# 2 认识 ORM\nDBC 的缺点：\n需要手动的完成面向对象的 Java 语言、面向关系的数据库之间数据的转换，代码繁琐无技术含量，影响了开发效率。\n如图所示，查询是需要手动的将结果集的列数据转换为 Java 对象的属性；而添加操作时需要手动将 Java 对象的属性转换为数据库表的列字段。\n关于面向对象的 Java 语言、面向关系的数据库之间数据的转换必须要做，问题在于这个转换是否可以不由开发者来做。可以的。ORM 框架就是专门来做这个问题的，相当于在面向对象语言和关系数据库之间搭建一个桥梁。\nORM，Object-Relationl Mapping，对象关系映射，它的作用是在关系型数据库和对象之间作一个映射，这样我们在具体的操作数据库的时候，只要像平时操作对象一样操作它就可以了，ORM 框架会根据映射完成对数据库的操作，就不需要再去和复杂的 SQL 语句打交道了。\n\n另外学习 ORM 必须知道两个概念：持久化、持久层\n什么是 “持久化”\n持久（Persistence），即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、XML 数据文件中等等。\n什么是 “持久层”\n持久层（Persistence Layer），即专注于实现数据持久化应用领域的某个特定系统的一个逻辑层面，将数据使用者和数据实体相关联。之前使用 JDBC 访问数据库的 DAO 层，后面采用 MyBatis 访问数据库的 mapper 层，就是持久层。\nMybatis 是一持久层的款半自动的 ORM 映射框架\n# 3 认识 MyBatis\n\n\n\n\n\n\n\n\n\nMyBatis 本是 Apache 的一个开源项目 iBatis, 2010 年这个项目由 Apache Software Foundation 迁移到了 Google Code，且改名为 MyBatis 。2013 年 11 月迁移到 GitHub。iBATIS 一词来源于 “internet” 和 “abatis” 的组合，是一个基于 Java 的持久层框架。\nMyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs (Plain Ordinary Java Object, 普通的 Java 对象) 映射成数据库中的记录。\n\n精简解释：MyBatis 是一个半自动 ORM 框架，其本质是对 JDBC 的封装。使用 MyBatis 重点需要程序员编写 SQL 命令，不需要写一行 JDBC 代码\n# 2 MyBatis 初次使用\n# 1 创建 maven 项目导入相关依赖\n但凡是框架，使用都是分三步走\n1 导入 jar 文件，maven\n2 处理配置文件\n3 开发业务代码\n先创建一个空项目，用于存放后面 Mybatis 相关项目模块\n\n项目名为 mybatisAll 即可\n\n这里不显示项目名 没关系，如果想看到项目名，可以 close 项目后，再次 open 即可\n\n关闭项目\n\n再次 open\n\n项目名就显示了\n\n接下来设置 maven 为我们自己安装的，不用 idea 自带的 (当然用自带的也行)\n\n\n在当前项目中创建模块\n\n选择 maven 项目 next\n\n输入 groupid 和 aitifactid  然后 finish\n\n检查项目目前在磁盘上的存放路径 然后 next\n\n检查项目目录结构是否有缺失\n\nMyBatis 官网说明文档   https://mybatis.org/mybatis-3/zh/index.html\n在 pom.xml 中导入 MyBatis 相关依赖 jar 文件\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n    &lt;groupId>com.msb&lt;/groupId>\n    &lt;artifactId>mybatisTest01&lt;/artifactId>\n    &lt;version>1.0-SNAPSHOT&lt;/version>\n    &lt;packaging>jar&lt;/packaging>\n    &lt;dependencies>\n        &lt;!--mysqlConnector-->\n        &lt;dependency>\n            &lt;groupId>mysql&lt;/groupId>\n            &lt;artifactId>mysql-connector-java&lt;/artifactId>\n            &lt;version>8.0.16&lt;/version>\n        &lt;/dependency>\n        &lt;!--mybatis 核心jar包-->\n        &lt;dependency>\n            &lt;groupId>org.mybatis&lt;/groupId>\n            &lt;artifactId>mybatis&lt;/artifactId>\n            &lt;version>3.5.3&lt;/version>\n        &lt;/dependency>\n        &lt;!--junit-->\n        &lt;dependency>\n            &lt;groupId>junit&lt;/groupId>\n            &lt;artifactId>junit&lt;/artifactId>\n            &lt;version>4.13.1&lt;/version>\n            &lt;scope>test&lt;/scope>\n        &lt;/dependency>\n        &lt;!--lombok -->\n        &lt;dependency>\n            &lt;groupId>org.projectlombok&lt;/groupId>\n            &lt;artifactId>lombok&lt;/artifactId>\n            &lt;version>1.18.12&lt;/version>\n            &lt;scope>provided&lt;/scope>\n        &lt;/dependency>\n    &lt;/dependencies>\n&lt;/project>\n安装 lombok 插件后，重启 idea\n\n导入 lombok 依赖后，单独设置启用注解处理\n\n# 2  准备数据库_包结构和实体类\n数据库\n\n项目结构\n\n实体类 Dept\n package com.msb.pojo;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport java.io.Serializable;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\n    @Data\n    @AllArgsConstructor\n    @NoArgsConstructor\n    public class Dept implements Serializable &#123;\n    private Integer deptno;\n    private String dname;\n    private String loc;\n    &#125;\n# 3 准备 Mapper 映射文件和核心配置文件\nresources 目录下 创建 com/msb/mapper 目录，然后添加 DeptMapper.xml 映射文件\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"aaa\">\n    &lt;!--public List&lt;Dept> findAll()&#123;    &#125;-->\n    &lt;select id=\"findAll\" resultType=\"com.msb.pojo.Dept\" >\n        select * from dept\n    &lt;/select>\n&lt;/mapper>\nresources 目录下准备 sqlMapConfig.xml 核心配置文件\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n&lt;configuration>\n    &lt;environments default=\"development\">\n        &lt;environment id=\"development\">\n            &lt;transactionManager type=\"JDBC\"/>\n            &lt;dataSource type=\"POOLED\">\n                &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                &lt;property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai\"/>\n                &lt;property name=\"username\" value=\"root\"/>\n                &lt;property name=\"password\" value=\"root\"/>\n            &lt;/dataSource>\n        &lt;/environment>\n    &lt;/environments>\n    &lt;!--加载mapper映射文件-->\n    &lt;mappers>\n        &lt;mapper resource=\"com/msb/mapper/DeptMapper.xml\"/>\n    &lt;/mappers>\n&lt;/configuration>\n# 4 运行测试\n\n在 test 目录下开发测试代码并运行\n\n package com.msb.test;\nimport com.msb.pojo.Dept;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\n    public class Test1 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\");\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n    &#125;\n    @Test\n    public void testFindAll()&#123;\n        // 调用SQL语句\n        List&lt;Dept> list = sqlSession.selectList(\"findAll\");\n        for (Dept dept : list) &#123;\n            System.out.println(dept);\n        &#125;\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n    &#125;\n# 3 MyBatis 配置详解\n# 1_log4j1 和 log4j2 的简单配置\n项目中添加依赖\n&lt;!-- log4j2 -->\n&lt;dependency>\n    &lt;groupId>org.apache.logging.log4j&lt;/groupId>\n    &lt;artifactId>log4j-core&lt;/artifactId>\n    &lt;version>2.12.1&lt;/version>\n&lt;/dependency>\n&lt;!-- log4j1 -->\n&lt;dependency>\n    &lt;groupId>log4j&lt;/groupId>\n    &lt;artifactId>log4j&lt;/artifactId>\n    &lt;version>1.2.17&lt;/version>\n&lt;/dependency>\n在mybatis.cfg.xml中配置MyBatis所使用的具体日志实现。如果不指定将自动搜索。可能会搜到log4j，但是如果优先搜到了其他的日志实现呢，所以还是设置为好。这一来log4j就跑不了了。\n\nlog4j 1\n将log4j.properties文件负责到src下。另外在其中可以将全局的日志级别调高，避免大量debug信息的干扰。同时将对映射文件的操作调低，可以用来显示SQL语句的调试信息。开发阶段，建议启动控制的日志。\n\n#定义全局日志级别调试阶段推荐 debug\nlog4j.rootLogger=debug,stdout \nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target=System.err\nlog4j.appender.stdout.layout=org.apache.log4j.SimpleLayout\nlog4j.appender.logfile=org.apache.log4j.FileAppender\nlog4j.appender.logfile.File=d:/msb.log\nlog4j.appender.logfile.layout=org.apache.log4j.PatternLayout\nlog4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %F %p %m%n\n在核心配置文件中可以选择的其他日志处理方式\nlog4j 2\n将 log4j2.xml 文件负责到 resources 下。\n &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;Configuration status=\"DEBUG\">\n    &lt;Appenders>\n        &lt;Console name=\"Console\" target=\"SYSTEM_ERR\">\n            &lt;PatternLayout pattern=\"%d&#123;YYYY-MM-dd HH:mm:ss&#125; [%t] %-5p %c&#123;1&#125;:%L - %msg%n\" />\n        &lt;/Console>\n        &lt;RollingFile name=\"RollingFile\" filename=\"log/test.log\"\n                     filepattern=\"$&#123;logPath&#125;/%d&#123;YYYYMMddHHmmss&#125;-fargo.log\">\n            &lt;PatternLayout pattern=\"%d&#123;YYYY-MM-dd HH:mm:ss&#125; [%t] %-5p %c&#123;1&#125;:%L - %msg%n\" />\n            &lt;Policies>\n                &lt;SizeBasedTriggeringPolicy size=\"10 MB\" />\n            &lt;/Policies>\n            &lt;DefaultRolloverStrategy max=\"20\" />\n        &lt;/RollingFile>\n    &lt;/Appenders>\n    &lt;Loggers>\n        &lt;Root level=\"INFO\">\n            &lt;AppenderRef ref=\"Console\" />\n        &lt;/Root>\n    &lt;/Loggers>\n&lt;/Configuration>\n核心配置文件中可以指定日志打印方式\n\n# 2_关于事务配置\n\n在 mybatis 核心配置文件中 envirment 中 通过 transactionManager 配置事务的处理策略\nJDBC – 这个配置直接简单使用了 JDBC 的提交和回滚设置。它依赖于从数据源得到的连接来管理事务范围。\nMANAGED – 这个配置几乎没做什么。它从来不提交或回滚一个连接。而它会让容器来管理事务的整个生命周期 (比如 Spring 或 JEE 应用服务器的上下文) 默认情况下它会关闭连接。然而一些容器并不希望这样，因此如果你需要从连接中停止它，将 closeConnection 属性设置为 false. mybatis 本身并不做事务的处理，交给其他框架去处理事务，如 spring\n# 3_关于映射文件的加载方式\n1.mapper 映射文件的文件路径导入 使用的 mapper 标签的 resource 属性\n2. 网络资源路径 使用的 mapper 标签的 url 属性\n3. 接口的全限定名导入 使用的是 mapper 标签的 class 属性 (基于接口的代理模式开发)\n4. 包扫描形式加载所有的 mapper 映射文件 使用的是 package 标签\n\n# 4_关于实体类别名处理\n在 mybatis 核心配置文件中使用别名处理\n &lt;!--设置实体类别名-->\n&lt;typeAliases>\n    &lt;!--\n    通过包扫描给所有的实体类起别名\n    给指定报名下的所有类起别名\n    默认每个实体类的别名是首字母小写的类名\n    Dept   dept\n    Emp    emp\n    -->\n    &lt;package name=\"com.msb.pojo\"/>\n&lt;/typeAliases>\n在映射文件的 resultType 返回值类型  和 paramterType 上就可以使用别名了\n&lt;select id=\"selectByEmpno\"  resultType=\"emp\">\n    select * from emp where empno = 7566\n&lt;/select>\n# 5_关于外部属性配置文件存储数据库连接信息\n在 resources 下准备 jdbc.properties 属性配置文件\n\n配置文件中的内容\njdbc_driver=com.mysql.cj.jdbc.Driver\njdbc_url=jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai\njdbc_username=root\njdbc_password=root\n在核心配置文件中引入 db.properties 属性文件\n &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!-- xml文档约束 约束xml文档中可以有哪些标签,哪些属性,以及标签的包含关系和顺序....\ndtd 约束\nschema 约束\n-->\n\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n&lt;configuration>\n    &lt;properties resource=\"jdbc.properties\">&lt;/properties>\n    &lt;settings>\n        &lt;!--设置日志处理方式-->\n        &lt;setting name=\"logImpl\" value=\"LOG4J\"/>\n    &lt;/settings>\n    &lt;!--设置实体类别名-->\n    &lt;typeAliases>\n        &lt;!--\n        通过包扫描给所有的实体类起别名\n        给指定报名下的所有类起别名\n        默认每个实体类的别名是首字母小写的类名\n        Dept   dept\n        Emp    emp\n        -->\n        &lt;package name=\"com.msb.pojo\"/>\n    &lt;/typeAliases>\n    &lt;!--配置数据库链接信息-->\n    &lt;environments default=\"mysql\">\n        &lt;!--数据源1-->\n        &lt;environment id=\"mysql\">\n            &lt;transactionManager type=\"JDBC\"/>\n            &lt;!--一个数据源-->\n            &lt;dataSource type=\"POOLED\">\n                &lt;property name=\"driver\" value=\"$&#123;jdbc_driver&#125;\"/>\n                &lt;property name=\"url\" value=\"$&#123;jdbc_url&#125;\"/>\n                &lt;property name=\"username\" value=\"$&#123;jdbc_username&#125;\"/>\n                &lt;property name=\"password\" value=\"$&#123;jdbc_password&#125;\"/>\n            &lt;/dataSource>\n        &lt;/environment>\n    &lt;/environments>\n    &lt;!--加载映射文件的-->\n    &lt;mappers>\n        &lt;mapper resource=\"com/msb/mapper/DeptMapper.xml\"/>\n    &lt;/mappers>\n&lt;/configuration>\n# 4 MyBatis 传统 DAO 模式开发\n\n\n\n\n\n\n\n\n\n  普通模式,也称为传统DAO模式,就是在传统DAO模式下,定义接口和实现类,如 interface EmpDao  class EmpDaoImpl implements EmpDao.  在实现类中,用SQLSession对象调用select insert delete update 等方法实现.目前极为少见.在传统模式下,我们需要知道SqlSession对象 实现CURD和 参数传递的处理\n\n# 1_sqlSession 查询的三种方式\nSqlSession 对象本身的 API 中就有三个查询方法，分别能够实现如下查询方式\n1 返回单个对象 selectOne\n2 返回对象 List 集合 selectList\n3 返回对象 Map 集合 selectMap\n接下来我们就对这三个方法进行一个快速的学习\n\n创建 Emp 实体类\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class Emp implements Serializable &#123;\n    private Integer empno;\n    private String ename;\n    private String job;\n    private Integer mgr;\n    private Date hiredate;\n    private Double sal;\n    private Double comm;\n    private Integer deptno;\n&#125;\n准备 Mapper 映射文件\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"EmpMapper\">\n    &lt;!--\n    返回单个对象\n    public Emp findOne();\n    id 相当于方法名\n    resultType 相当于返回值类型\n        sql语句的查询结果用哪个类来进行封装 如果返回值类型是集合,这里写的也是集合中的元素对应的类,不是集合本身作为类型\n    paramaterType 参数类型\n    SQL语句就是具体的方法体的实现\n    -->\n    &lt;select id=\"findOne\" resultType=\"emp\" >\n        select * from emp where empno = 7499\n    &lt;/select>\n    &lt;!--\n    返回多个对象List集合\n    查询全部的员工信息\n    public List&lt;Emp> findAll()\n    -->\n    &lt;select id=\"findAll\" resultType=\"emp\">\n        select * from emp\n    &lt;/select>\n    &lt;!--返回多个对象的Map集合\n    把查询出来的数据中的某一列作为键,整条数据封装的对象作为值\n    public Map&lt;key,Emp> findEmpMap()\n    &lt;empno,Emp>\n    &lt;key,Emp>\n    -->\n    &lt;select id=\"findEmpMap\" resultType=\"map\">\n        select * from emp\n    &lt;/select>\n&lt;/mapper>\nsqlMapConfig 中导入 EmpMapper 映射文件\n&lt;!--加载mapper映射文件-->\n&lt;mappers>\n    &lt;mapper resource=\"com/msb/mapper/DeptMapper.xml\"/>\n    &lt;mapper resource=\"com/msb/mapper/EmpMapper.xml\"/>\n&lt;/mappers>\n\n测试代码\npackage com.msb.test;\nimport com.msb.pojo.Dept;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\n    public class Test2 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\");\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n    &#125;\n    @Test\n    public void testSelectOne()&#123;\n        // 查询单个对象\n        System.out.println(\"sqlSession查询单个对象\");\n        Emp emp = sqlSession.selectOne(\"findOne\");\n        System.out.println(emp);\n    &#125;\n    @Test\n    public void testSelectList()&#123;\n        // 查询多个对象的List集合\n        System.out.println(\"sqlSession查询对象List集合\");\n        List&lt;Emp> emps = sqlSession.selectList(\"EmpMapper.findAll\");\n        emps.forEach(System.out::println);\n    &#125;\n    @Test\n    public void testSelectMap()&#123;\n        // 查询多个对象的Map集合\n        System.out.println(\"sqlSession查询对象Map集合\");\n        Map&lt;Integer, Emp> empMap = sqlSession.selectMap(\"findEmpMap\", \"EMPNO\");\n        Set&lt;Integer> empnos = empMap.keySet();\n        for (Integer empno : empnos) &#123;\n            System.out.println(empno+\" :\" +empMap.get(empno));\n        &#125;\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n&#125;\n# 2_sqlSession 传递参数的三种方式\n1 单个基础数据类型作为参数\n2 多个基础数据类型的 map 集合作为参数\n3 引用类型作为参数\nMapper 映射文件\n &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"EmpMapper2\">\n    &lt;!--\n    参数为一个基本数据类型\n    根据员工工号查询员工的全部信息,返回单个员工对象\n    public Emp findByEmpno(int empno);\n    parameterType 在有参数情况下也是可以省略不写  mybatis 可以根据实际情况自动判断\n    如果要写parameterType 那么就要写对\n    在SQL语句上可以使用$&#123;&#125;  #&#123;&#125; 代表参数的占位\n    如果参数是单个基本数据类型,&#123;&#125;中名字可以随便写,见名知意\n    $&#123;&#125; 代表mybatis底层使用Statment语句对象,参数是以字符串拼接的形式设置\n    #&#123;&#125; 代表mybatis底层使用的preparedStatment语句对象,参数使用?作为占位符处理\n    #&#123;&#125; 以后常用\n    -->\n    &lt;select id=\"findByEmpno\" resultType=\"emp\" parameterType=\"int\">\n        select  * from emp where empno = #&#123;empno&#125;\n    &lt;/select>\n    &lt;!--\n    参数为map集合\n    查询指定部门号和指定最低薪资的员工信息\n    20 号部门 且工资在1500以上的员工信息\n    public List&lt;Emp> findEmpByDeptnoAndSal(int deptno,double sal);\n    &lt;  >  最好要进行转译处理,参照HTML转译  w3school在线文档中有转译符号对应规则\n     Map&lt;String,Object> args=new HashMap&lt;>();\n        args.put(\"deptno\", 20);\n        args.put(\"sal\", 1500.0);\n    #&#123;&#125;中写的是map集合中,参数的键\n    -->\n    &lt;select id=\"findEmpByDeptnoAndSal\" resultType=\"emp\" parameterType=\"map\">\n    &lt;/select>\n    &lt;!--\n   参数为对象\n   emp >>>  deptno   sal\n   参数是我们自定义的类型,那么 #&#123;&#125;中写的是参数的属性名\n   -->\n    &lt;select id=\"findEmpByDeptnoAndSal2\" resultType=\"emp\" parameterType=\"emp\">\n    &lt;/select>\n&lt;/mapper>\n测试代码\n package com.msb.test;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\n    public class Test3 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\");\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n    &#125;\n    @Test\n    public void testSingleArg()&#123;\n        // 测试单个基本数据类型作为参数\n        Emp emp = sqlSession.selectOne(\"findByEmpno\", 7499);\n        System.out.println(emp);\n    &#125;\n    @Test\n    public void testMapArg()&#123;\n        // 测试Map集合作为参数\n        Map&lt;String,Object> args=new HashMap&lt;>();\n        args.put(\"deptno\", 20);\n        args.put(\"sal\", 3000.0);\n        List&lt;Emp> emps = sqlSession.selectList(\"findEmpByDeptnoAndSal\", args);\n        emps.forEach(System.out::println);\n    &#125;\n    @Test\n    public void testEmpArg()&#123;\n        // 测试Map集合作为参数\n        Emp arg =new Emp();\n        arg.setDeptno(10);\n        arg.setSal(2000.0);\n        List&lt;Emp> emps = sqlSession.selectList(\"findEmpByDeptnoAndSal2\", arg);\n        emps.forEach(System.out::println);\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n&#125;\n# 3_sqlSession 完成 DML 所有操作\nMapper 映射文件\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"EmpMapper3\">\n    &lt;!--\n    增删方法的返回值类型都是int\n    resultType就无需指定了\n    insert update delete 标签中没有resultType\n    但是仍然可以有paramaterType\n    -->\n    &lt;!-- 增加方法\n    public int addEmp(Emp emp);\n    -->\n    &lt;insert id=\"addEmp\" parameterType=\"emp\">\n    &lt;/insert>\n    &lt;!--修改\n    根据工号修改员工姓名\n    public int updateEmp(Emp emp);\n    -->\n    &lt;update id=\"updateEmp\" parameterType=\"emp\">\n    &lt;/update>\n    &lt;!-- 删除\n    删除大于给定工号的员工信息\n    public int deleteEmp(int empno)\n    -->\n    &lt;delete id=\"deleteEmp\" parameterType=\"int\">\n        delete from emp where empno >= #&#123;empno&#125;\n    &lt;/delete>\n&lt;/mapper>\n测试代码\npackage com.msb.test;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic class Test4 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\");\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession(true);\n    &#125;\n    @Test\n    public void testInsert()&#123;\n        Emp emp =new Emp(null,\"按住啦Baby\",\"SALESMAN\",7839,new Date(),3100.0, 200.0,10 );\n        int rows = sqlSession.insert(\"addEmp\", emp);\n        System.out.println(rows);\n        // 手动提交事务\n        //sqlSession.commit();\n        /*增删改 要提交事务\n        * sqlSession.commit();手动提交事务\n        * sqlSession=factory.openSession(true); 设置事务自动提交\n        * */\n    &#125;\n    @Test\n    public void testUpdate()&#123;\n        Emp emp =new Emp( );\n        emp.setEname(\"晓明\");\n        emp.setEmpno(7937);\n        int rows = sqlSession.update(\"updateEmp\", emp);\n        System.out.println(rows);\n    &#125;\n    @Test\n    public void testDelete()&#123;\n        int rows = sqlSession.delete(\"deleteEmp\", 7936);\n        System.out.println(rows);\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n&#125;\n# 5 MyBatis 代理模式开发\n前面已经使用 MyBatis 完成了对 Emp 表的 CRUD 操作，都是由 SqlSession 调用自身方法发送 SQL 命令并得到结果的，实现了 MyBatis 的入门。\n但是却存在如下缺点：\n\n\n不管是 selectList ()、selectOne ()、selectMap ()，都是通过 SQLSession 对象的 API 完成增删改查，都只能提供一个查询参数。如果要多个参数，需要封装到 JavaBean 或者 Map 中，并不一定永远是一个好办法。\n\n\n返回值类型较固定。\n\n\n只提供了映射文件，没有提供数据库操作的接口，不利于后期的维护扩展。\n\n\n在 MyBatis 中提供了另外一种成为 **Mapper 代理（或称为接口绑定）** 的操作方式。在实际开发中也使用该方式。下面我们就是要 Mapper 代理的方式来实现对 Emp 表的 CRUD 操作吧，还有完成多个参数传递、模糊查询、自增主键回填等更多的技能实现。搭建好的项目框架如图所示，相比而言，增加了接口 EmployeeMapper。但是却会引起映射文件和测试类的变化。\n优点:\n1 有接口 模块之间有规范了\n2 参数的处理多样了，接口中的方法参数列表由我们自己决定\n3 通过代理模式由 mybatis 提供接口的实现类对象 我们不用写实现类了\n项目结构：注意文件路径和文件位置！！！\n\n准备接口和 mapper 映射文件\nEmpMapper 接口\npackage com.msb.mapper;\nimport com.msb.pojo.Emp;\nimport java.util.List;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\npublic interface EmpMapper &#123;\n    /**\n     * 该方法用于查询全部的员工信息\n     * @return 全部员工信息封装的Emp对象的List集合\n        */\n    List&lt;Emp> findAll();\n &#125;\n\nEmpMapper.xml 映射文件\n &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.msb.mapper.EmpMapper\">\n    &lt;!--\n    1 接口的名字和Mapper映射为文件名字必须保持一致(不包含拓展名)\n    2 Mapper映射文件的namespace必须是接口的全路径名\n    3 sql语句的id必须是对应方法的名\n    4 DeptMapper映射文件应该和接口编译之后放在同一个目录下\n    -->\n    &lt;!--List&lt;Emp> findAll();-->\n    &lt;select id=\"findAll\" resultType=\"emp\" >\n        select * from emp\n    &lt;/select>\n&lt;/mapper>\n在 sqlMapConfig.xml 核心配置文件中使用包扫描形式加载所有的映射文件\n &lt;!--加载mapper映射文件-->\n&lt;mappers>\n    &lt;!--通过类的全路径去找mapper映射文件-->\n    &lt;mapper class=\"com.msb.mapper.EmpMapper\"/>\n&lt;/mappers>\n测试代码\npackage com.msb.test;\nimport com.msb.mapper.EmpMapper;\nimport com.msb.pojo.Dept;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n/**\n\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n    */\n    public class Test1 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\");\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n    &#125;\n    @Test\n    public void testFindAll()&#123;\n        EmpMapper empMapper=sqlSession.getMapper(EmpMapper.class);\n        List&lt;Emp> emps = empMapper.findAll();\n        emps.forEach(System.out::println);\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n&#125;\n代理模式浅析\nmybatis 是如何通过代理模式实现查询的\n这条语句的底层使用了动态代理模式，动态创建一个 EmployeeMapper 的一个代理对象并赋给接口引用。所以在 MyBatis 中不需要显式提供 Mapper 接口的实现类，这也是简单的地方。\n# 6 代理模式下开发各种功能\n# 1_多种参数传递问题\n\n\n\n\n\n\n\n\n\n1 单个基本数据类型\n2 多个基本数据类型\n3 单个引用数据类型\n4map 集合数据类型\n5 多个引用数据类型\n接口\npackage com.msb.mapper;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.annotations.Param;\nimport java.util.List;\nimport java.util.Map;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic interface EmpMapper &#123;\n    /**\n     * 该方法用于查询全部的员工信息\n     * @return 全部员工信息封装的Emp对象的List集合\n     */\n    List&lt;Emp> findAll();\n    /**\n     * 根据员工编号查询单个员工信息的方法\n     * @param empno 员工编号\n     * @return 如果找到了返回Emp对象,找不到返回null\n     */\n    Emp findByEmpno(int empno);\n    /**\n     * 根据员工编号和薪资下限去查询员工信息\n     * @param empno 员工编号\n     * @param sal 薪资下限\n     * @return 多个Emp对象的List集合\n     */\n    List&lt;Emp> findByDeptnoAndSal(@Param(\"deptno\") int deptno,@Param(\"sal\") double sal);\n    List&lt;Emp> findByDeptnoAndSal2(Map&lt;String,Object> map);\n    List&lt;Emp> findByDeptnoAndSal3(Emp emp);\n    List&lt;Emp> findByDeptnoAndSal4(@Param(\"empa\") Emp empa,@Param(\"empb\") Emp empb);\n&#125;\n\nmapper 映射文件\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.msb.mapper.EmpMapper\">\n    &lt;!--\n    1 接口的名字和Mapper映射为文件名字必须保持一致(不包含拓展名)\n    2 Mapper映射文件的namespace必须是接口的全路径名\n    3 sql语句的id必须是对应方法的名\n    4 DeptMapper映射文件应该和接口编译之后放在同一个目录下\n    -->\n    &lt;!--List&lt;Emp> findAll();-->\n    &lt;select id=\"findAll\" resultType=\"emp\" >\n        select * from emp\n    &lt;/select>\n    &lt;!--\n    单个基本数据类型作为方法参数\n    #&#123;&#125;中可以随便写,遵循见名知意\n    Emp findByEmpno(int empno);\n    -->\n    &lt;select id=\"findByEmpno\" resultType=\"emp\" >\n        select * from emp where empno =#&#123;empno&#125;\n    &lt;/select>\n    &lt;!--\n     多个基本数据类型作为方法参数\n     List&lt;Emp> findByDeptnoAndSal(@Param(\"detpno\") int deptno,@Param(\"sal\") double sal);\n     方式1 arg*     arg0 arg1 arg2 数字是索引,从0开始\n     方式2 param*   param1 param2 param3 数字是编号,从1开始\n     使用别名\n     List&lt;Emp> findByDeptnoAndSal(@Param(\"detpno\") int deptno,@Param(\"sal\") double sal);\n     通过@Param注解使用别名之后,就不能再使用arg* 但是可以继续使用param*\n    -->\n    &lt;select id=\"findByDeptnoAndSal\" resultType=\"emp\">\n    &lt;/select>\n    &lt;!--\n    参数是map,&#123;&#125;写键的名字\n    -->\n    &lt;select id=\"findByDeptnoAndSal2\" resultType=\"emp\" parameterType=\"map\" >\n    &lt;/select>\n    &lt;!--单个引用类型,&#123;&#125;中写的使用对象的属性名-->\n    &lt;select id=\"findByDeptnoAndSal3\" resultType=\"emp\" parameterType=\"emp\" >\n    &lt;/select>\n    &lt;!--\n    多个引用类型作为方法参数\n     List&lt;Emp> findByDeptnoAndSal4(@Param(\"empa\") Emp empa,@Param(\"empb\") Emp empb);\n     如果用@Param定义了别名,那么就不能使用arg*.属性名,但是可以使用param*.属性名和别名.属性名\n    -->\n    &lt;select id=\"findByDeptnoAndSal4\" resultType=\"emp\"  >\n    &lt;/select>\n&lt;/mapper>\n\n测试 代码\npackage com.msb.testDemo;\nimport com.msb.mapper.EmpMapper;\nimport com.msb.pojo.Emp;\nimport com.msb.util.SqlSessionUtil;\nimport org.apache.ibatis.session.SqlSession;\nimport java.util.List;\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        SqlSession sqlSession = SqlSessionUtil.getSqlSession(true);\n        /*\n        * 帮助我们生成一个接口下的实现类对象的\n        *\n        * */\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        List&lt;Emp> emps = mapper.getAllEmp();\n        for(Emp emp:emps) &#123;\n            System.out.println(emp);\n        &#125;\n        // 1单个基本数据类型作为方法参数\n        Emp emp = mapper.getByEmpno(7902);\n        System.out.println(emp);\n        // 2多个基本数据类型作为方法参数\n        List&lt;Emp> emps2 = mapper.getByDeptnoAndSal(10, 1500);\n        for(Emp em:emps2) &#123;\n            System.out.println(em);\n        &#125;\n        // 3单个引用类型作为方法参数\n        Emp condition=new Emp();\n        condition.setDeptno(10);\n        condition.setSal(1500.0);\n        List&lt;Emp> emps3 = mapper.getByDeptnoAndSal2(condition);\n        for(Emp em:emps3) &#123;\n            System.out.println(em);\n        &#125;\n        // 4多个引用类型作为方法参数\n        Emp condition1=new Emp();\n        condition1.setDeptno(10);\n        Emp condition2=new Emp();\n        condition2.setSal(1500.0);\n        List&lt;Emp> emps4 = mapper.getByDeptnoAndSal3(condition1,condition2);\n        for(Emp em:emps4) &#123;\n            System.out.println(em);\n        &#125;\n        sqlSession.close();\n    &#125;\n&#125;\n# 2 模糊查询功能\n在进行模糊查询时，在映射文件中可以使用concat()函数来连接参数和通配符。另外注意对于特殊字符，比如&lt;，不能直接书写，应该使用字符实体替换。\n\n接口\n/**\n * 根据名字做模糊查询\n * @param name 模糊查询的文字\n * @return  Emp对象List集合\n */\nList&lt;Emp> findByEname( String name);\nmapper 映射文件\n&lt;!--List&lt;Emp> getByName(String name);-->\n&lt;select id=\"findByEname\"  resultType=\"emp\" >\n    select * from emp where ename like concat('%',#&#123;name&#125;,'%')\n&lt;/select>\n# 3_主键自增回填\nMySQL支持主键自增。有时候完成添加后需要立刻获取刚刚自增的主键，由下一个操作来使用。比如结算构造车后，主订单的主键确定后，需要作为后续订单明细项的外键存在。如何拿到主键呢，MyBatis提供了支持，可以非常简单的获取。\n\n接口\npublic interface DeptMapper &#123;\n    int addDept(Dept dept);\n    int addDept2(Dept dept);\n&#125;\nmapper 映射文件\n&lt;mapper namespace=\"com.msb.mapper.DeptMapper\">\n   &lt;!-- int addDept(Dept dept);\n   useGeneratedKeys=\"true\" 返回数据库帮我们生成的主键\n   keyProperty=\"deptno\" 生成的主键值用我们dept对象那个属性存储\n   -->\n    &lt;insert id=\"addDept\" parameterType=\"dept\" useGeneratedKeys=\"true\" keyProperty=\"deptno\">\n    &lt;/insert>\n    &lt;insert id=\"addDept2\" parameterType=\"dept\">\n        &lt;selectKey order=\"AFTER\" keyProperty=\"deptno\"  resultType=\"int\">\n            select @@identity\n        &lt;/selectKey>\n    &lt;/insert>\n&lt;/mapper>\n\n测试代码\nSqlSession sqlSession = SqlSessionUtil.getSqlSession(true);\nDeptMapper mapper = sqlSession.getMapper(DeptMapper.class);\nDept dept =new Dept(null,\"AI学院\",\"北京\");\nint i = mapper.addDept2(dept);\nSystem.out.println(i);\nSystem.out.println(dept.getDeptno());\nsqlSession.close();\n\n方式 1\nuseGeneratedKeys：表示要使用自增的主键\nkeyProperty：表示把自增的主键赋给 JavaBean 的哪个成员变量。\n以添加 Dept 对象为例，添加前 Dept 对象的 deptno 是空的，添加完毕后可以通过 getDeptno () 获取自增的主键。\n方式 2\norder：取值 AFTER|BEFORE，表示在新增之后 | 之前执行中的 SQL 命令\nkeyProperty：执行 select @@identity 后结果填充到哪个属性中\nresultType：结果类型。\n技术扩展\n在很多应用场景中需要新增数据后获取到新增数据的主键值，针对这样的需求一般由三种解决方式：\n\n主键自定义，用户通过 UUID 或时间戳等方式生成唯一主键，把这个值当做主键值。在分布式场景中应用较多。\n查询后通过 select max (主键) from 表获取主键最大值。这种方式在多线程访问情况下可能出现问题。\n查询后通过 select @@identity 获取最新生成主键。要求这条 SQL 必须在 insert 操作之后，且数据库连接没有关闭。\n\n# 4_实现 DML 操作\nEmpMapper 接口\n/**\n * 增加员工信息\n * @param emp 存储新增员工信息的Emp对象\n * @return 对数据库数据产生影响的行数\n */\nint addEmp(Emp emp);\n/**\n * 根据员工编号修改员工姓名的方法\n * @param empno 要修改的员工编号\n * @param ename 修改之后的新的员工名字\n * @return 对数据库数据产生影响的行数\n */\nint updateEnameByEmpno(@Param(\"empno\") int empno,@Param(\"ename\") String ename);\n/**\n * 根据员工编号删除员工信息\n * @param empno 要删除的员工编号\n * @return 对数据库数据产生影响的行数\n */\nint deleteByEmpno(int empno);\nEmpMapper 映射 文件\n&lt;!--int addEmp(Emp emp);-->\n&lt;insert id=\"addEmp\" >\n&lt;/insert>\n&lt;!--int updateEnameByEmpno(@Param(\"empno\") int empno,@Param(\"ename\") String ename);-->\n&lt;update id=\"updateEnameByEmpno\" >\n&lt;/update>\n&lt;!--int deleteByEmpno(int empno);-->\n&lt;update id=\"deleteByEmpno\" >\n    delete from emp where empno =#&#123;empno&#125;\n&lt;/update>\n测试代码\npackage com.msb.test;\nimport com.msb.mapper.DeptMapper;\nimport com.msb.mapper.EmpMapper;\nimport com.msb.pojo.Dept;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Date;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic class Test3 &#123;\n    private SqlSession sqlSession;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\");\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n    &#125;\n    @Test\n    public void testAddEmp()&#123;\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        mapper.addEmp(new Emp(null, \"TOM\", \"SALESMAN\", 7521, new Date(), 2314.0, 100.0, 10));\n        sqlSession.commit();\n    &#125;\n    @Test\n    public void testUpdateEnameByEmpno()&#123;\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        mapper.updateEnameByEmpno(7938, \"TOM\");\n        sqlSession.commit();\n    &#125;\n    @Test\n    public void testDeletByEmpno()&#123;\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        mapper.deleteByEmpno(7938);\n        sqlSession.commit();\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n    &#125;\n&#125;\n\n# 7 动态 SQL\n经常遇到很多按照很多查询条件进行查询的情况，比如京东根据不同的条件筛选商品。其中经常出现很多条件不取值的情况，在后台应该如何完成最终的SQL语句呢？\n\n\n\n\n\n\n\n\n\n如果采用JDBC进行处理，需要根据条件是否取值进行SQL语句的拼接，一般情况下是使用StringBuilder类及其append方法实现，还是有些繁琐的。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。\n\nMyBatis在简化操作方法提出了动态SQL功能，将使用Java代码拼接SQL语句，改变为在XML映射文件中截止标签拼接SQL语句。相比而言，大大减少了代码量，更灵活、高度可配置、利于后期维护。\n\nMyBatis中动态SQL是编写在mapper.xml中的，其语法和JSTL类似，但是却是基于强大的OGNL表达式实现的。\n\nMyBatis也可以在注解中配置SQL，但是由于注解功能受限，尤其是对于复杂的SQL语句，可读性很差，所以较少使用。\n\n# 1_if 标签\n接口\n public interface EmpMapper2 &#123;\n   List&lt;Emp> findByCondition(Emp emp);\n&#125;\n映射文件\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.msb.mapper.EmpMapper2\">\n&lt;!--List&lt;Emp> findByCondition(Emp emp);-->\n    &lt;select id=\"findByCondition\" resultType=\"emp\">\n        select * from emp where 1=1\n        &lt;if test=\"empno != null\">\n            and empno =#&#123;empno&#125;\n        &lt;/if>\n        &lt;if test=\"ename != null and ename != ''\">\n            and ename like concat('%',#&#123;ename&#125;,'%')\n        &lt;/if>\n        &lt;if test=\"job != null and job != ''\">\n            and job =#&#123;job&#125;\n        &lt;/if>\n        &lt;if test=\"mgr != null\">\n            and mgr =#&#123;mgr&#125;\n        &lt;/if>\n        &lt;if test=\"hiredate != null\">\n            and hiredate =#&#123;hiredate&#125;\n        &lt;/if>\n        &lt;if test=\"sal != null\">\n            and sal =#&#123;sal&#125;\n        &lt;/if>\n        &lt;if test=\"comm != null\">\n            and comm =#&#123;comm&#125;\n        &lt;/if>\n        &lt;if test=\"deptno != null\">\n            and deptno =#&#123;deptno&#125;\n        &lt;/if>\n    &lt;/select>\n&lt;/mapper>\n\n测试代码\npublic static void main(String[] args) &#123;\n    SqlSession sqlSession = MyBatisUtil.getSqlSession(false);\n    EmpMapper2 mapper = sqlSession.getMapper(EmpMapper2.class);\n    Emp condition =new Emp();\n   /* condition.setDeptno(20);*/\n   /* condition.setSal(3000.0);*/\n   /*condition.setHiredate(new java.sql.Date(81,1,22));*/\n   condition.setComm(0.0);\n   condition.setDeptno(20);\n    List&lt;Emp> emps = mapper.findEmpByCondition(condition);\n    for (Emp e:emps\n         ) &#123;\n        System.out.println(e);\n    &#125;\n&#125;\n\n# 2_where 标签\n\n\n\n\n\n\n\n\n\n用于处理 where 关键字和 and\n默认删除第一个 and 逻辑连接符\n&lt;select id=\"findEmpByCondition\" resultType=\"emp\">\n    select * from emp\n    &lt;where>\n        &lt;if test=\"empno != null\">\n            and empno= #&#123;empno&#125;\n        &lt;/if>\n        &lt;if test=\"ename != null and ename != ''\">\n            and ename= #&#123;ename&#125;\n        &lt;/if>\n        &lt;if test=\"job != null and job != ''\">\n            and job= #&#123;job&#125;\n        &lt;/if>\n        &lt;if test=\"mgr != null \">\n            and mgr= #&#123;mgr&#125;\n        &lt;/if>\n        &lt;if test=\"hiredate != null \">\n            and hiredate= #&#123;hiredate&#125;\n        &lt;/if>\n        &lt;if test=\"sal != null\">\n            and sal= #&#123;sal&#125;\n        &lt;/if>\n        &lt;if test=\"comm != null \">\n             and comm =#&#123;comm&#125;\n        &lt;/if>\n        &lt;if test=\"deptno != null \">\n            and deptno= #&#123;deptno&#125;\n        &lt;/if>\n    &lt;/where>\n&lt;/select>\n\n# 3_choose 标签\n前面的 when 条件成立 后面的 when 就不再判断了\n &lt;select id=\"findEmpByCondition2\" resultType=\"emp\">\n    select * from emp\n    &lt;where>\n        &lt;choose>\n            &lt;when test=\"empno != null\">\n                and empno= #&#123;empno&#125;\n            &lt;/when>\n            &lt;when test=\"ename != null and ename != ''\">\n                and ename= #&#123;ename&#125;\n            &lt;/when>\n            &lt;when test=\"job != null and job != ''\">\n                and job= #&#123;job&#125;\n            &lt;/when>\n            &lt;when test=\"mgr != null \">\n                and mgr= #&#123;mgr&#125;\n            &lt;/when>\n            &lt;when test=\"hiredate != null \">\n                and hiredate= #&#123;hiredate&#125;\n            &lt;/when>\n            &lt;when test=\"sal != null\">\n                and sal= #&#123;sal&#125;\n            &lt;/when>\n            &lt;when test=\"comm != null \">\n                and comm =#&#123;comm&#125;\n            &lt;/when>\n            &lt;when test=\"deptno != null \">\n                and deptno= #&#123;deptno&#125;\n            &lt;/when>\n        &lt;/choose>\n    &lt;/where>\n&lt;/select>\n\n# 4_set 标签\n接口\nint updateEmpByCondtion(Emp emp);\n映射文件\n &lt;!--int updateEmpByCondtion(Emp emp);-->\n&lt;update id=\"updateEmpByCondtion\" >\n    update emp\n    &lt;set>\n        &lt;if test=\"ename != null and ename != '' \">\n            , ename =#&#123;ename&#125;\n        &lt;/if>\n        &lt;if test=\"job != null and ename != '' \">\n            , job =#&#123;job&#125;\n        &lt;/if>\n        &lt;if test=\"mgr != null \">\n            , mgr =#&#123;mgr&#125;\n        &lt;/if>\n        &lt;if test=\"hiredate != null \">\n            , hiredate =#&#123;hiredate&#125;\n        &lt;/if>\n        &lt;if test=\"sal != null \">\n            , sal =#&#123;sal&#125;\n        &lt;/if>\n        &lt;if test=\"comm != null \">\n            , comm =#&#123;comm&#125;\n        &lt;/if>\n        &lt;if test=\"deptno != null \">\n            , deptno =#&#123;deptno&#125;\n        &lt;/if>\n    &lt;/set>\n    where empno =#&#123;empno&#125;\n&lt;/update>\n# 5_trim 标签\n\n\n\n\n\n\n\n\n\nTrim 标签处理 set  ，可以为他包裹起来的 SQL 语句前后 增加 / 删除 关键词 / 固定字符\n&lt;update id=\"updateEmpByCondition2\" >\n    update emp\n    &lt;!--prefix 要增加什么前缀\n    prefixOverrides 要去除什么前缀\n    suffix 要增加什么后缀\n    suffixOverrides 要去除什么后缀\n    set 是trim的一种特殊情况\n    -->\n    &lt;trim prefix=\"set\"  suffixOverrides=\",\" >\n        &lt;if test=\"ename != null and ename != ''\">\n            ename= #&#123;ename&#125;,\n        &lt;/if>\n        &lt;if test=\"job != null and job != ''\">\n            job= #&#123;job&#125;,\n        &lt;/if>\n        &lt;if test=\"mgr != null \">\n            mgr= #&#123;mgr&#125;,\n        &lt;/if>\n        &lt;if test=\"hiredate != null \">\n            hiredate= #&#123;hiredate&#125;,\n        &lt;/if>\n        &lt;if test=\"sal != null\">\n            sal= #&#123;sal&#125;,\n        &lt;/if>\n        &lt;if test=\"comm != null \">\n            comm =#&#123;comm&#125;,\n        &lt;/if>\n        &lt;if test=\"deptno != null \">\n            deptno= #&#123;deptno&#125;,\n        &lt;/if>\n    &lt;/trim>\n    where  empno = #&#123;empno&#125;\n&lt;/update>\nTrim 标签  处理 where\n&lt;select id=\"findByCondition\" resultMap=\"EmpMap\">\n       select * from emp \n       &lt;trim prefix=\"where\" prefixOverrides=\"and\">\n           &lt;if test=\"empno != null\">\n               and empno =#&#123;empno&#125;\n           &lt;/if>\n           &lt;if test=\"ename != null and ename != ''\">\n               &lt;bind name=\"likePattern\" value=\"'%'+ename+'%'\"/>\n               and ename like #&#123;likePattern&#125;\n           &lt;/if>\n           &lt;if test=\"job != null and job != ''\">\n               and job =#&#123;job&#125;\n           &lt;/if>\n           &lt;if test=\"mgr != null\">\n               and mgr =#&#123;mgr&#125;\n           &lt;/if>\n           &lt;if test=\"hiredate != null\">\n               and hiredate =#&#123;hiredate&#125;\n           &lt;/if>\n           &lt;if test=\"sal != null\">\n               and sal =#&#123;sal&#125;\n           &lt;/if>\n           &lt;if test=\"comm != null\">\n               and comm =#&#123;comm&#125;\n           &lt;/if>\n           &lt;if test=\"deptno != null\">\n               and deptno =#&#123;deptno&#125;\n           &lt;/if>\n       &lt;/trim>\n   &lt;/select>\n# 6_bind 标签\n一般用于处理模糊查询的模板\n接口\n\nSQL 语句\n&lt;!-- bind 写一个局部SQL模板，模糊 like 常用-->\n    &lt;select id=\"findEmpByEname\" resultMap=\"EmpMap\">\n        &lt;bind name=\"likePatten\" value=\"'%'+param1+'%'\"/>\n        select * from emp where ename like #&#123;likePatten&#125;;\n    &lt;/select>\n# 7_nclude\n引用提前写好的 SQL 标签的 SQL 语句\n&lt;sql id=\"empColumn\">empno,ename,job,mgr,hiredate,sal,comm,deptno&lt;/sql>\n&lt;sql id=\"baseSelect\">\n       select &lt;include refid=\"empColumn\">&lt;/include> from emp\n&lt;/sql>\n# 8_sql 标签\n &lt;sql id=\"empColumn\">empno,ename,job,mgr,hiredate,sal,comm,deptno&lt;/sql>\n&lt;sql id=\"baseSelect\">select &lt;include refid=\"empColumn\">&lt;/include> from emp&lt;/sql>\n&lt;!--List&lt;Emp> findByCondition(Emp emp);-->\n&lt;select id=\"findByCondition\" resultType=\"emp\">\n    &lt;include refid=\"baseSelect\">&lt;/include>\n    &lt;trim prefix=\"where\" prefixOverrides=\"and\">\n        &lt;if test=\"empno != null\">\n            and empno =#&#123;empno&#125;\n        &lt;/if>\n        &lt;if test=\"ename != null and ename != ''\">\n            &lt;bind name=\"likePattern\" value=\"'%'+ename+'%'\"/>\n            and ename like #&#123;likePattern&#125;\n        &lt;/if>\n        &lt;if test=\"job != null and job != ''\">\n            and job =#&#123;job&#125;\n        &lt;/if>\n        &lt;if test=\"mgr != null\">\n            and mgr =#&#123;mgr&#125;\n        &lt;/if>\n        &lt;if test=\"hiredate != null\">\n            and hiredate =#&#123;hiredate&#125;\n        &lt;/if>\n        &lt;if test=\"sal != null\">\n            and sal =#&#123;sal&#125;\n        &lt;/if>\n        &lt;if test=\"comm != null\">\n            and comm =#&#123;comm&#125;\n        &lt;/if>\n        &lt;if test=\"deptno != null\">\n            and deptno =#&#123;deptno&#125;\n        &lt;/if>\n    &lt;/trim>\n&lt;/select>\n\n# 9_foreach 标签\n &lt;!--List&lt;Emp> findByEmpnos1(int[] empnos);\n collection=\"\"  遍历的集合或者是数组\n                 参数是数组,collection中名字指定为array\n                 参数是List集合,collection中名字指定为list\n separator=\"\"   多个元素取出的时候 用什么文字分隔\n open=\"\"        以什么开头\n close=\"\"       以什么结尾\n item=\"\"        中间变量名\n for(Person per:PersonList)\n -->\n &lt;select id=\"findByEmpnos1\" resultType=\"emp\">\n     select * from emp  where empno in\n     &lt;foreach collection=\"array\" separator=\",\" open=\"(\" close=\")\" item=\"deptno\">\n         #&#123;deptno&#125;\n     &lt;/foreach>\n &lt;/select>\n&lt;!-- List&lt;Emp> findByEmpnos2(List&lt;Integer> empnos);-->\n &lt;select id=\"findByEmpnos2\" resultType=\"emp\">\n     select * from emp  where empno in\n     &lt;foreach collection=\"list\" separator=\",\" open=\"(\" close=\")\" item=\"deptno\">\n         #&#123;deptno&#125;\n     &lt;/foreach>\n &lt;/select>\n\n# 8 MyBatis 实现多表查询\n前面已经使用 MyBatis 完成了对 Emp 表的 CRUD 操作，不管是使用 SqlSession 直接操作，还是使用 Mapper 代理方式，都只是完成了对单个数据库表的操作。这肯定是远远不够的。\n在实际开发中，经常会将来自多张表的数据在一个位置显示。比如查询并显示的员工信息中会有来自部门表、岗位表的数据，而后台一般是定义一个方法\n# 1 关联查询\n# 1 手动处理映射关系\n实体类\npublic class Emp  implements Serializable &#123;\n    private Integer empno;\n    private String name;\n    private String job;\n    private Integer mgr;\n    private Date hiredate;\n    private Double sal;\n    private Double comm;\n    private Integer deptno;\n&#125;\n映射文件\n&lt;mapper namespace=\"com.msb.mapper.EmpMapper\">\n    &lt;!--手动处理数据库查询字段和封装实体类属性之间的映射关系\n    1 主键一般使用id属性\n    2 当属性名和查询出的数据表字段名相同 可以不写映射关系\n    -->\n    &lt;resultMap id=\"empMap\" type=\"emp\">\n        &lt;!--&lt;id property=\"empno\" column=\"empno\">&lt;/id>-->\n        &lt;result property=\"name\" column=\"ename\">&lt;/result>\n        &lt;!--&lt;result property=\"job\" column=\"job\">&lt;/result>\n        &lt;result property=\"sal\" column=\"sal\">&lt;/result>\n        &lt;result property=\"hiredate\" column=\"hiredate\">&lt;/result>\n        &lt;result property=\"mgr\" column=\"mgr\">&lt;/result>\n        &lt;result property=\"comm\" column=\"comm\">&lt;/result>\n        &lt;result property=\"deptno\" column=\"deptno\">&lt;/result>-->\n    &lt;/resultMap>\n    &lt;select id=\"findByEmpno\" resultMap=\"empMap\" >\n        select * from emp where empno =#&#123;empno&#125;\n    &lt;/select>\n&lt;/mapper>\n\n# 2 一对一关联查询\n数据准备：创建项目表和项目记录表\n\nCREATE TABLE `projects`  (\n  `pid` int(2) NOT NULL AUTO_INCREMENT,\n  `pname` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,\n  `money` int(11) NULL DEFAULT NULL,\n  PRIMARY KEY (`pid`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\nINSERT INTO `projects` VALUES (1, ' ***大学OA', 500000);\nINSERT INTO `projects` VALUES (2, '学生选课系统', 100000);\nINSERT INTO `projects` VALUES (3, '讲师测评系统', 20000);\nINSERT INTO `projects` VALUES (4, '线上问答系统 ', 20000);\nCREATE TABLE `projectrecord`  (\n  `empno` int(4) NOT NULL,\n  `pid` int(2) NOT NULL,\n  PRIMARY KEY (`empno`, `pid`) USING BTREE,\n  INDEX `fk_project_pro`(`pid`) USING BTREE,\n  CONSTRAINT `fk_emp_pro` FOREIGN KEY (`empno`) REFERENCES `emp` (`EMPNO`) ON DELETE CASCADE ON UPDATE CASCADE,\n  CONSTRAINT `fk_project_pro` FOREIGN KEY (`pid`) REFERENCES `projects` (`pid`) ON DELETE CASCADE ON UPDATE CASCADE\n) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\nINSERT INTO `projectrecord` VALUES (7369, 1);\nINSERT INTO `projectrecord` VALUES (7521, 1);\nINSERT INTO `projectrecord` VALUES (7369, 2);\nINSERT INTO `projectrecord` VALUES (7499, 2);\nINSERT INTO `projectrecord` VALUES (7521, 2);\nINSERT INTO `projectrecord` VALUES (7369, 3);\nINSERT INTO `projectrecord` VALUES (7499, 3);\nINSERT INTO `projectrecord` VALUES (7521, 3);\nINSERT INTO `projectrecord` VALUES (7369, 4);\nINSERT INTO `projectrecord` VALUES (7499, 4);\n需求：根据编号查询员工信息及所在的部门信息\n实体类添加一个部门作为属性\n实体类\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class Emp implements Serializable &#123;\n    private Integer empno;\n    private String ename;\n    private String job;\n    private Integer mgr;\n    private Date hiredate;\n    private Double sal;\n    private Double comm;\n    private Integer deptno;\n    // 组合一个Dept对象作为自己的属性\n    private Dept dept;\n&#125;\n\n接口\npublic interface EmpMapper &#123;\n    /**\n     * 根据员工编号查询员工的所有信息并携带所在的部门信息\n     * @param empno 要查询的员工编号\n     * @return Emp对象,组合了Dept对象作为属性,对部门信息进行存储\n     */\n    Emp findEmpJoinDeptByEmpno(int empno);\n&#125;\n映射文件\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.msb.mapper.EmpMapper\">\n    &lt;!--Emp findEmpJoinDeptByEmpno(int empno);-->\n    &lt;resultMap id=\"empJoinDept\" type=\"emp\">\n        &lt;!--设置emp本身的八个属性的映射关系-->\n        &lt;id property=\"empno\" column=\"empno\">&lt;/id>\n        &lt;result property=\"ename\" column=\"ename\">&lt;/result>\n        &lt;result property=\"job\" column=\"job\">&lt;/result>\n        &lt;result property=\"sal\" column=\"sal\">&lt;/result>\n        &lt;result property=\"hiredate\" column=\"hiredate\">&lt;/result>\n        &lt;result property=\"mgr\" column=\"mgr\">&lt;/result>\n        &lt;result property=\"comm\" column=\"comm\">&lt;/result>\n        &lt;result property=\"deptno\" column=\"deptno\">&lt;/result>\n        &lt;!--\n        association 处理一对一\n        封装一对一信息关系的标签\n        property  emp类的属性名\n        javaType  用哪个类的对象给属性赋值\n        -->\n        &lt;association property=\"dept\" javaType=\"dept\">\n            &lt;id column=\"deptno\" property=\"deptno\">&lt;/id>\n            &lt;result column=\"dname\" property=\"dname\">&lt;/result>\n            &lt;result column=\"loc\" property=\"loc\">&lt;/result>\n        &lt;/association>\n    &lt;/resultMap>\n    &lt;select id=\"findEmpJoinDeptByEmpno\" resultMap=\"empJoinDept\" >\n        select * from\n        emp e\n        left join dept  d\n        on e.deptno =d.deptno\n        where empno = #&#123;empno&#125;\n    &lt;/select>\n&lt;/mapper>\n\n测试代码\n@Test\npublic void testOneToOne() throws ParseException &#123;\n    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n    Emp emp = mapper.findEmpJoinDeptByEmpno(7499);\n    System.out.println(emp);\n&#125;\n3 一对多关联查询\n根据部门号查询部门信息及该部门的所有员工信息\n实体类\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Dept implements Serializable &#123;\n    private Integer deptno;\n    private String dname;\n    private String loc;\n    // 组合一个Emp的List集合作为属性\n    private List&lt;Emp> empList;\n&#125;\n接口\npackage com.msb.mapper;\nimport com.msb.pojo.Dept;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic interface DeptMapper &#123;\n    /**\n     * 根据部门编号查询部门信息及该部分的所有员工信息\n     * @param deptno 要查询的部门编号\n     * @return Dept对象,内部组合了一个Emp的List属性用于封装部门的所有员工信息\n     */\n    Dept findDeptJoinEmpsByDeptno(int deptno);\n&#125;\n\n映射文件\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.msb.mapper.DeptMapper\">\n    &lt;!--Dept findDeptJoinEmpsByDeptno(int deptno);-->\n    &lt;resultMap id=\"deptJoinEmps\" type=\"dept\">\n        &lt;id column=\"deptno\" property=\"deptno\">&lt;/id>\n        &lt;result column=\"dname\" property=\"dname\">&lt;/result>\n        &lt;result column=\"loc\" property=\"loc\">&lt;/result>\n        &lt;!--处理一对多关系的标签-->\n        &lt;collection property=\"empList\" ofType=\"emp\" >\n            &lt;!--设置emp本身的八个属性的映射关系-->\n            &lt;id property=\"empno\" column=\"empno\">&lt;/id>\n            &lt;result property=\"ename\" column=\"ename\">&lt;/result>\n            &lt;result property=\"job\" column=\"job\">&lt;/result>\n            &lt;result property=\"sal\" column=\"sal\">&lt;/result>\n            &lt;result property=\"hiredate\" column=\"hiredate\">&lt;/result>\n            &lt;result property=\"mgr\" column=\"mgr\">&lt;/result>\n            &lt;result property=\"comm\" column=\"comm\">&lt;/result>\n            &lt;result property=\"deptno\" column=\"deptno\">&lt;/result>\n        &lt;/collection>\n    &lt;/resultMap>\n    &lt;select id=\"findDeptJoinEmpsByDeptno\" resultMap=\"deptJoinEmps\">\n        select * from dept d left join emp e on d.deptno =e.deptno where d.deptno =#&#123;deptno&#125;\n    &lt;/select>\n&lt;/mapper>\n\n测试代码\n@Test\npublic void testOneToMany() throws ParseException &#123;\n    DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);\n    Dept dept = mapper.findDeptJoinEmpsByDeptno(20);\n    System.out.println(dept);\n    System.out.println(\"---------\");\n    List&lt;Emp> empList = dept.getEmpList();\n    empList.forEach(System.out::println);\n&#125;\n\n4 多对多关联查询\n根据项目编号查询项目信息，以及参与到该项目之中的所有的员工信息\n实体类\n@NoArgsConstructor\n@AllArgsConstructor\n@Data\npublic class Project  implements Serializable &#123;\n    private Integer pid;\n    private String pname;\n    private Integer money;\n    // 组合一个ProjectRecord对象集合作为属性\n    private List&lt;ProjectRecord> projectRecords;\n&#125;\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class ProjectRecord implements Serializable &#123;\n    private Integer empno;\n    private Integer pid;\n    // 组合一个Emp对象作为属性\n    private Emp emp;\n&#125;\n\n接口\npackage com.msb.mapper;\nimport com.msb.pojo.Emp;\nimport com.msb.pojo.Project;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic interface ProjectMapper &#123;\n    /**\n     * 根据项目编号查询一个项目信息及参与该项目的所有员工信息\n     * @param pid 项目编号\n     * @return 所有信息封装的Project对象\n     */\n    Project findProjectJoinEmpsByPid(int pid);\n&#125;\n映射文件\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.msb.mapper.ProjectMapper\">\n    &lt;!--Project findProjectJoinEmpsByPid(int pid);-->\n    &lt;resultMap id=\"projectJoinEmps\" type=\"project\">\n        &lt;id column=\"pid\" property=\"pid\">&lt;/id>\n        &lt;result column=\"pname\" property=\"pname\">&lt;/result>\n        &lt;result column=\"money\" property=\"money\">&lt;/result>\n        &lt;!--一对多 集合属性 collection-->\n        &lt;collection property=\"projectRecords\" ofType=\"projectRecord\">\n            &lt;id column=\"empno\" property=\"empno\">&lt;/id>\n            &lt;id column=\"pid\" property=\"pid\">&lt;/id>\n            &lt;!--一对一 -->\n            &lt;association property=\"emp\" javaType=\"emp\">\n                &lt;id property=\"empno\" column=\"empno\">&lt;/id>\n                &lt;result property=\"ename\" column=\"ename\">&lt;/result>\n                &lt;result property=\"job\" column=\"job\">&lt;/result>\n                &lt;result property=\"sal\" column=\"sal\">&lt;/result>\n                &lt;result property=\"hiredate\" column=\"hiredate\">&lt;/result>\n                &lt;result property=\"mgr\" column=\"mgr\">&lt;/result>\n                &lt;result property=\"comm\" column=\"comm\">&lt;/result>\n                &lt;result property=\"deptno\" column=\"deptno\">&lt;/result>\n            &lt;/association>\n        &lt;/collection>\n    &lt;/resultMap>\n    &lt;select id=\"findProjectJoinEmpsByPid\"  resultMap=\"projectJoinEmps\">\n        select * from\n        project p\n        left join projectrecord pr\n        on p.pid = pr.pid\n        left join emp e\n        on e.empno = pr.empno\n        where p.pid= #&#123;pid&#125;\n    &lt;/select>\n&lt;/mapper>\n测试代码\n@Test\npublic void testManyToMany() throws ParseException &#123;\n    ProjectMapper mapper = sqlSession.getMapper(ProjectMapper.class);\n    Project project = mapper.findProjectJoinEmpsByPid(2);\n    System.out.println(project.getPid());\n    System.out.println(project.getPname());\n    System.out.println(project.getMoney());\n    List&lt;ProjectRecord> projectRecords = project.getProjectRecords();\n    for (ProjectRecord projectRecord : projectRecords) &#123;\n        Emp emp = projectRecord.getEmp();\n        System.out.println(emp);\n    &#125;\n&#125;\n# 2 级联查询\n级联查询，顾名思义，就是利于数据库表间的外键关联关系进行自动的级联查询操作。使用 MyBatis 实现级联查询，除了实体类增加关联属性外，还需要在映射文件中进行配置。\n# 1 立即加载\n# 2 延迟加载\n延迟加载，又称按需加载。延迟加载的内容等到真正使用时才去进行加载（查询）。多用在关联对象或集合中。\n延迟加载的好处：先从单表查询、需要时再从关联表去关联查询，大大降低数据库在单位时间内的查询工作量，将工作在时间上的分配更加均匀，而且单表要比关联查询多张表速度要快。\n延迟加载的设置\n第一步：全局开关：在 sqlMapConfig.xml 中打开延迟加载的开关。配置完成后所有的 association 和 collection 元素都生效\n&lt;settings>\n    &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    &lt;setting name=\"aggressiveLazyLoading\" value=\"true\"/>\n&lt;/settings>\nlazyLoadingEnabled: 是否开启延迟加载。是 Mybatis 是否启用懒加载的全局开关。当开启时，所有关联对象都会延迟加载。特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态\naggressiveLazyLoading：当开启时，任何方法的调用都会懒加载对象的所有属性。否则，每个属性会按需加载，\n第二步：分开关：指定的 association 和 collection 元素中配置fetchType属性。eager：表示立刻加载；lazy：表示延迟加载。将覆盖全局延迟设置。\n# 3 总结\n# resultMap 中的常见属性\n\n    \n\t\t\tproperty\n\t\t\t需要映射到JavaBean 的属性名称\n\t\t\n\t\t\n\t\t\tjavaType\n\t\t\tproperty的类型，一个完整的类名，或者是一个类型别名。如果你匹配的是一个JavaBean，那MyBatis 通常会自行检测到\n\t\t\n\t\t\n\t\t\tcolumn\n\t\t\t数据表的列名或者列别名\n\t\t\n\t\t\n\t\t\tjdbcType\n\t\t\tcolumn在数据库表中的类型。这个属性只在insert,update   或delete 的时候针对允许空的列有用。JDBC 需要这项，但MyBatis 不需要\n\t\t\n\t\t\n\t\t\ttypeHandler\n\t\t\t使用这个属性可以覆写类型处理器，实现javaType、jdbcType之间的相互转换。一般可以省略，会探测到使用的什么类型的typeHandler进行处理\n\t\t\n\t\t\n\t\t\tfetchType\n\t\t\t自动延迟加载\n\t\t\n\t\t\n\t\t\tselect\n\t\t\tassociation、collection的属性，使用哪个查询查询属性的值，要求指定namespace+id的全名称\n\t\t\n\t\t\n\t\t\tofType\n\t\t\tcollection的属性，指明集合中元素的类型（即泛型类型）\n\t\t\n\t\n# 级联查询和多表查询的比较及其选择\n\n    \n        \tSQL语句数量\n\t\t多条\n    \t一条\n\t\n\t\n\t\t性能\n\t\t性能低\n    \t性能高\n\t\n\t\n\t\t延迟加载\n\t\t立即加载、延迟加载\n    \t只有立即加载\n\t\n\t\n\t\t灵活性\n\t\t更灵活\n    \t不灵活\n\t\n\t\n\t\tSQL难易度\n\t\t简单\n    \t复杂\n\t\n\t\n\t\t选择依据\n\t\t简单、灵活\n    \t高性能\n\t\n\nResultType 和 ResultMap 使用场景\n\n\n如果你做的是单表的查询并且封装的实体和数据库的字段一一对应   resultType\n\n\n\n如果实体封装的属性和数据库的字段不一致  resultMap\n\n\n\n 使用N+1级联查询的时候  resultMap\n\n\n\n使用的是多表的连接查询  resultMap\n\n\n\n一对一关联映射的实现\n\n\n实例：学生和学生证、雇员和工牌\n\n\n\n数据库层次：主键关联或者外键关联（参看之前内容）\n\n\n\n MyBatis层次：在映射文件的设置双方均使用association即可，用法相同\n\n\n\n多对多映射的实现\n\n\n实例：学生和课程、用户和角色\n\n\n\n 数据库层次：引入一个中间表将一个多对多转为两个一对多\n\n\n\n MyBatis层次\n\n\n\n方法 1：在映射文件的设置双方均使用 collection 即可，不用引入中间类\n方法 2：引入中间类和中间类的映射文件，按照两个一对多处理\n自关联映射\n\n\n实例：Emp表中的员工和上级。一般是一对多关联\n\n\n\n数据库层次：外键参考当前表的主键（比如mgr参考empno）\n\n\n\nMyBatis 层次：按照一对多处理，但是增加的属性都写到一个实体类中，增加的映射也都写到一个映射文件中\n\n\n# 9 MyBatis 注解开发\npublic interface DeptMapper &#123;\n    Dept findDeptByDeptno(int deptno);\n    @Select(\"select * from dept where deptno =#&#123;deptno&#125;\")\n    Dept findByDeptno(int deptno);\n    int updateDept(Dept dept);\n    int addDept(Dept dept);\n    @Delete(\"delete from dept where deptno =#&#123;deptno&#125;\")\n    int removeDept(int deptno);\n&#125;\n\n1. 使用注解没有实现 Java 代码和 SQL 语句的解耦\n2. 无法实现 SQL 语句的动态拼接\n3. 进行多表的查询时定制 ResultMap 比较麻烦\n注解和 XML 的优缺点\n\n    \n        \t优点\n\t\t类和类之间的解耦\n    \t简化配置\n\t\n\t\n\t\t \n\t\t利于修改。直接修改XML文件，无需到源代码中修改。\n    \t使用起来直观且容易，提升开发效率\n\t\n\t\n\t\t\n\t\t配置集中在XML中，对象间关系一目了然，利于快速了解项目和维护\n    \t类型安全，编译器进行校验，不用等到运行期才会发现错误\n\t\n\t\n\t\t\n\t\t容易和其他系统进行数据交交换\n    \t注解的解析可以不依赖于第三方库，可以直接使用Java自带的反射\n\t\n\n# 10 缓存\n\n\n\n\n\n\n\n\n\n\n​\t是一种临时存储少量数据至内存或者是磁盘的一种技术。减少数据的加载次数，可以降低工作量，提高程序响应速度\n​\t缓存的重要性是不言而喻的。mybatis 的缓存将相同查询条件的 SQL 语句执行一遍后所得到的结果存在内存或者某种缓存介质当中，当下次遇到一模一样的查询 SQL 时候不在执行 SQL 与数据库交互，而是直接从缓存中获取结果，减少服务器的压力；尤其是在查询越多、缓存命中率越高的情况下，使用缓存对性能的提高更明显。\n​\tMyBatis 允许使用缓存，缓存一般放置在高速读 / 写的存储器上，比如服务器的内存，能够有效的提供系统性能。MyBatis 分为一级缓存和二级缓存，同时也可配置关于缓存设置。\n​\t一级存储是 SqlSession 上的缓存，二级缓存是在 SqlSessionFactory (namespace) 上的缓存。默认情况下，MyBatis 开启一级缓存，没有开启二级缓存。当数据量大的时候可以借助一些第三方缓存框架或 Redis 缓存来协助保存 Mybatis 的二级缓存数据。\n\n# 1 一级缓存\n一级存储是 SqlSession 上的缓存，默认开启，是一种内存型缓存，不要求实体类对象实现 Serializable 接口。\n缓存中的数据使用键值对形式存储数据\nnamespace + sqlid + args + offset     &gt;&gt;&gt;   hash 值作为键，查询出的结果作为值\n\n测试 代码\n@Test\npublic void testFindDeptByDetpno()   &#123;\n    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n    Emp emp = mapper.findByEmpno(7521);\n    System.out.println(emp);\n    // 中间发生了增删改或者是调用了SqlSession调用了commit,会自动清空缓存\n    sqlSession.commit();// 增删改的时候调用\n    EmpMapper mapper2 = sqlSession.getMapper(EmpMapper.class);\n    Emp emp2 = mapper2.findByEmpno(7521);\n    System.out.println(emp2); \n    \n    System.out.println(emp==emp2);// 没有commit之前为True\n    System.out.println(mapper==mapper2);// false 表示确实产生了两个代理对象\n&#125;\n\n# 2 二级缓存\n二级缓存是以 namespace 为标记的缓存，可以是由一个 SqlSessionFactory 创建的 SqlSession 之间共享缓存数据。默认并不开启。下面的代码中创建了两个 SqlSession，执行相同的 SQL 语句，尝试让第二个 SqlSession 使用第一个 SqlSession 查询后缓存的数据。要求实体类必须实现序列化接口\n\n接口\npublic interface EmpMapper &#123;\n    Emp findByEmpno(int empno);\n&#125;\n映射文件\n&lt;mapper namespace=\"com.msb.mapper.EmpMapper\">\n    &lt;cache/>\n    &lt;select id=\"findByEmpno\" resultType=\"emp\" useCache=\"true\" flushCache=\"false\">\n        select * from emp where empno =#&#123;empno&#125;\n    &lt;/select>\n&lt;/mapper>\n\n测试 代码\npackage com.msb.test;\nimport com.msb.mapper.EmpMapper;\nimport com.msb.pojo.Emp;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.IOException;\nimport java.io.InputStream;\n/**\n * @Author: Ma HaiYang\n * @Description: MircoMessage:Mark_7001\n */\npublic class Test3 &#123;\n    private SqlSession sqlSession;\n    private SqlSession sqlSession2;\n    @Before\n    public void init()&#123;\n        SqlSessionFactoryBuilder ssfb =new SqlSessionFactoryBuilder();\n        InputStream resourceAsStream = null;\n        try &#123;\n            resourceAsStream = Resources.getResourceAsStream(\"sqlMapConfig.xml\");\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n        SqlSessionFactory factory=ssfb.build(resourceAsStream) ;\n        sqlSession=factory.openSession();\n        sqlSession2=factory.openSession();\n    &#125;\n    @Test\n    public void testFindDeptByDetpno()   &#123;\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        Emp emp = mapper.findByEmpno(7521);\n        System.out.println(emp);\n        // SqlSession提交之后,才会将查询的结果放入二级缓存\n        sqlSession.commit();\n        EmpMapper mapper2 = sqlSession2.getMapper(EmpMapper.class);\n        Emp emp2 = mapper2.findByEmpno(7521);\n        System.out.println(emp2);\n    &#125;\n    @After\n    public void release()&#123;\n        // 关闭SQLSession\n        sqlSession.close();\n        sqlSession2.close();\n    &#125;\n&#125;\n\n注意：\n​\t其中的 commit ()，执行该命令后才会将该 SqlSession 的查询结果从一级缓存中放入二级缓存，供其他 SqlSession 使用。另外执行 SqlSession 的 close () 也会将该 SqlSession 的查询结果从一级缓存中放入二级缓存。两种方式区别在当前 SqlSession 是否关闭了。\n执行结果显示进行了两次对数据库的 SQL 查询，说明二级缓存并没有开启。需要进行如下步骤完成开启。\n\n全局开关：在 sqlMapConfig.xml 文件中的标签配置开启二级缓存\n\n&lt;settings>\n    &lt;setting name=\"cacheEnabled\" value=\"true\"/>\n&lt;/settings>\ncacheEnabled 的默认值就是 true，所以这步的设置可以省略。\n\n分开关：在要开启二级缓存的 mapper 文件中开启缓存：\n\n&lt;mapper namespace=\"com.msb.mapper.EmployeeMapper\">\n    &lt;cache/>\n&lt;/mapper>\n\n二级缓存未必完全使用内存，有可能占用硬盘存储，缓存中存储的 JavaBean 对象必须实现序列化接口，\n\npublic class Emp implements  Serializable &#123;  &#125;\n经过设置后，查询结果如图所示。发现第一个 SqlSession 会首先去二级缓存中查找，如果不存在，就查询数据库，在 commit () 或者 close () 的时候将数据放入到二级缓存。第二个 SqlSession 执行相同 SQL 语句查询时就直接从二级缓存中获取了。\n注意：\n​\t1)    MyBatis 的二级缓存的缓存介质有多种多样，而并不一定是在内存中，所以需要对 JavaBean 对象实现序列化接口。\n\n二级缓存是以 namespace 为单位的，不同 namespace 下的操作互不影响\n\n​\t3)    加入 Cache 元素后，会对相应命名空间所有的 select 元素查询结果进行缓存，而其中的 insert、update、delete 在操作是会清空整个 namespace 的缓存。\n​\t4)    cache 有一些可选的属性 type, eviction, flushInterval, size, readOnly, blocking。\n &lt;cache type=\"\" readOnly=\"\" eviction=\"\"flushInterval=\"\"size=\"\"blocking=\"\"/>\n&lt;cache type=&quot;&quot; readOnly=&quot;&quot; eviction=&quot;“flushInterval=”“size=”“blocking=”&quot;/&gt;\n\n    \n        td {\n            text-align:center;\n        }\n        p {\n          text-align:center;\n        }\n    \n    \n        \ttype\n         自定义缓存类，要求实现org.apache.ibatis.cache.Cache接口\n\t\t\tnull\n\t\t\n\t\t\n        \treadOnly\n            是否只读\n                 true:给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。 \n                 这提供了很重要的性能优势。\n                false:会返回缓存对象的拷贝(通过序列化)。\n                 这会慢一些,但是安全\n\t\t\t\n\t\t\tfalse\n\t\t\n\t\t\n        \teviction\n\t\t\t\t \n                缓存策略LRU（默认） – 最近最少使用：移除最长时间不被使用的对象。\n                FIFO – 先进先出：按对象进入缓存的顺序来移除它们。\n                SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。\n                WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。\n\t\t\t\n\t\t\tLRU\n\t\t\n\t\t\n        \tflushInterval\n\t\t\t\n                \t刷新间隔，毫秒为单位。默认为null，也就是没有刷新间隔，\n                \n                \n                    只有执行update、insert、delete语句才会刷新\n                \n\t\t\t\n\t\t\tnull\n\t\t\n\t\t\n        \t size\n\t\t\t缓存对象个数\n\t\t\t1024\n\t\t\n\t\t\n        \tblocking\n\t\t\t\n                是否使用阻塞性缓存BlockingCache\n                true：在查询缓存时锁住对应的Key，如果缓存命中了则会释放对应的锁，\n                否则会在查询数据库以后再释放锁，\n                保证只有一个线程到数据库中查找指定key对应的数据\n                false：不使用阻塞性缓存，性能更好\n\t\t\t\n\t\t\tfalse\n\t\t\n\n\n如果在加入 Cache 元素的前提下让个别 select 元素不使用缓存，可以使用 useCache 属性，设置为 false。useCache 控制当前 sql 语句是否启用缓存  flushCache 控制当前 sql 执行一次后是否刷新缓存\n\n &lt;select id=\"findByEmpno\" resultType=\"emp\" useCache=\"true\" flushCache=\"false\">\n# 3 三方缓存\n\n\n\n\n\n\n\n\n\n分布式缓存框架：我们系统为了提高系统并发和性能，一般对系统进行分布式部署（集群部署方式）不适用分布缓存， 缓存的数据在各个服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理.ehcache,redis ,memcache 缓存框架。\nEhcache：是一种广泛使用的开源 java 分布式缓存。主要面向通用缓存，javaEE 和 轻量级容器。它具有内存和磁盘存储功能。被用于大型复杂分布式 web application 的\n这里的三方缓存是作为二级缓存使用的\n导入依赖的 jar 文件\n &lt;dependency>\n    &lt;groupId>org.mybatis.caches&lt;/groupId>\n    &lt;artifactId>mybatis-ehcache&lt;/artifactId>\n    &lt;version>1.0.2&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>net.sf.ehcache&lt;/groupId>\n    &lt;artifactId>ehcache&lt;/artifactId>\n    &lt;version>2.10.1&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>org.slf4j&lt;/groupId>\n    &lt;artifactId>slf4j-nop&lt;/artifactId>\n    &lt;version>1.7.2&lt;/version>\n&lt;/dependency>\n去各自的 sql 映射文件里，开启二级缓存，并把缓存类型指定为 EhcacheCache\n&lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/>\n在资源目录下放置一个缓存配置文件，文件名为: ehcache.xml 内容如下\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"ehcache.xsd\"\n         updateCheck=\"true\" monitoring=\"autodetect\"\n         dynamicConfig=\"true\">\n    &lt;diskStore path=\"D:\\msb\\ehcache\" />\n    &lt;defaultCache\n            maxElementsInMemory=\"1000\"\n            maxElementsOnDisk=\"10000000\"\n            eternal=\"false\"\n            overflowToDisk=\"true\"\n            timeToIdleSeconds=\"120\"\n            timeToLiveSeconds=\"120\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n    &lt;/defaultCache>\n&lt;/ehcache>\n        &lt;!--  Cache配置\n        ·           name：Cache的唯一标识\n        ·           maxElementsInMemory：内存中最大缓存对象数。\n        ·           maxElementsOnDisk：磁盘中最大缓存对象数，若是0表示无穷大。\n        ·           eternal：Element是否永久有效，一但设置了，timeout将不起作用。\n        ·           overflowToDisk：配置此属性，当内存中Element数量达到maxElementsInMemory时，Ehcache将会Element写到磁盘中。\n        ·           timeToIdleSeconds：设置Element在失效前的允许闲置时间。仅当element不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。\n        ·           timeToLiveSeconds：设置Element在失效前允许存活时间。最大时间介于创建时间和失效时间之间。仅当element不是永久有效时使用，默认是0.，也就是element存活时间无穷大。\n        ·           diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。\n        ·           diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。\n        ·           memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。     -->\n# 11 逆向工程\n\n\n\n\n\n\n\n\n\nMyBatisPlus 内容，简略分析，可以参考后面具体内容\nMyBatis 的一个主要的特点就是需要程序员自己编写 SQL，那么如果表太多的话，难免会很麻烦，所以 MyBatis 官方提供了一个逆向工程，可以针对单表自动生成 MyBatis 执行所需要的代码（包括 mapper.xml，mapper.java，pojo）。一般在开发中，常用的逆向工程方式是通过数据库的表生成代码。\n创建 maven 项目导入逆向工程依赖\n\n&lt;dependencies>\n  \n    &lt;!-- mysql驱动包 -->\n    &lt;dependency>\n        &lt;groupId>mysql&lt;/groupId>\n        &lt;artifactId>mysql-connector-java&lt;/artifactId>\n        &lt;version>8.0.16&lt;/version>\n    &lt;/dependency>\n    &lt;!-- 日志包，方便查看执行信息-->\n    &lt;dependency>\n        &lt;groupId>org.slf4j&lt;/groupId>\n        &lt;artifactId>slf4j-log4j12&lt;/artifactId>\n        &lt;version>1.6.1&lt;/version>\n    &lt;/dependency>\n    &lt;!-- 代码生成工具jar -->\n    &lt;dependency>\n        &lt;groupId>org.mybatis.generator&lt;/groupId>\n        &lt;artifactId>mybatis-generator-core&lt;/artifactId>\n        &lt;version>1.3.2&lt;/version>\n    &lt;/dependency>\n&lt;/dependencies>\n配置逆向工程配置文件 在 resources 目录下放置一个名为 generatorConfig.xml 的配置文件，文件内容如下\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!DOCTYPE generatorConfiguration\n  PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n&lt;generatorConfiguration>\n   &lt;context id=\"testTables\" targetRuntime=\"MyBatis3\">\n      &lt;commentGenerator>\n         &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 -->\n         &lt;property name=\"suppressAllComments\" value=\"true\" />\n      &lt;/commentGenerator>\n      &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 -->\n      &lt;!-- &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\"\n         connectionURL=\"jdbc:mysql://localhost:3306/mybatis\" userId=\"root\"\n         password=\"123\">\n      &lt;/jdbcConnection> -->\n       &lt;jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\"\n         connectionURL=\"jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true\"\n         userId=\"root\"\n         password=\"root\">\n      &lt;/jdbcConnection> \n      &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 \n         NUMERIC 类型解析为java.math.BigDecimal -->\n      &lt;javaTypeResolver>\n         &lt;property name=\"forceBigDecimals\" value=\"false\" />\n      &lt;/javaTypeResolver>\n      &lt;!-- targetProject:生成PO类的位置 -->\n      &lt;javaModelGenerator targetPackage=\"com.msb.pojo\"\n         targetProject=\".\\src\">\n         &lt;!-- enableSubPackages:是否让schema作为包的后缀 -->\n         &lt;property name=\"enableSubPackages\" value=\"false\" />\n         &lt;!-- 从数据库返回的值被清理前后的空格 -->\n         &lt;property name=\"trimStrings\" value=\"true\" />\n      &lt;/javaModelGenerator>\n        &lt;!-- targetProject:mapper映射文件生成的位置 -->\n      &lt;sqlMapGenerator targetPackage=\"com.msb.mapper\"\n         targetProject=\".\\src\">\n         &lt;!-- enableSubPackages:是否让schema作为包的后缀 -->\n         &lt;property name=\"enableSubPackages\" value=\"false\" />\n      &lt;/sqlMapGenerator>\n      &lt;!-- targetPackage：mapper接口生成的位置 -->\n      &lt;javaClientGenerator type=\"XMLMAPPER\"\n         targetPackage=\"com.msb.mapper\"\n         targetProject=\".\\src\">\n         &lt;!-- enableSubPackages:是否让schema作为包的后缀 -->\n         &lt;property name=\"enableSubPackages\" value=\"false\" />\n      &lt;/javaClientGenerator>\n      &lt;!-- 指定数据库表 -->\n      \n      &lt;table tableName=\"dept\" domainObjectName=\"Dept\"\n       enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\"    \n               enableSelectByExample=\"false\" selectByExampleQueryId=\"false\" >\n               &lt;columnOverride column=\"id\" javaType=\"Integer\" />\n         &lt;/table>\n      \n   &lt;/context>\n&lt;/generatorConfiguration>\n\n在 resources 目录下放置一个名为 log4j.properties 的配置文件，文件内容如下\nlog4j.rootLogger=debug,stdout\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target=System.err\nlog4j.appender.stdout.layout=org.apache.log4j.SimpleLayout\nlog4j.appender.logfile=org.apache.log4j.FileAppender\nlog4j.appender.logfile.File=d:/msb.log\nlog4j.appender.logfile.layout=org.apache.log4j.PatternLayout\nlog4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %F %p %m%n\n运行逆向工程代码\npackage com.msb.gennerator;\nimport org.mybatis.generator.api.MyBatisGenerator;\nimport org.mybatis.generator.config.Configuration;\nimport org.mybatis.generator.config.xml.ConfigurationParser;\nimport org.mybatis.generator.internal.DefaultShellCallback;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n/**\n *\n */\npublic class GeneratorSqlmap &#123;\n    public void generator() throws Exception&#123;\n        List&lt;String> warnings = new ArrayList&lt;String>();\n        boolean overwrite = true;\n        File configFile = new File(\"D:\\\\ideaProjects\\\\reverse\\\\target\\\\classes\\\\generatorConfig.xml\");\n        ConfigurationParser cp = new ConfigurationParser(warnings);\n        Configuration config = cp.parseConfiguration(configFile);\n        DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,\n                callback, warnings);\n        myBatisGenerator.generate(null);\n    &#125;\n    public static void main(String[] args) throws Exception &#123;\n        try &#123;\n            GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap();\n            generatorSqlmap.generator();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n生成的实体类和 Mapper 接口和 Mapper 映射文件，包含了基本的 CURD 功能，哪里需要文件就放哪里\n\n# 12 main 目录下配置文件打包问题\n&lt;build>\n    &lt;!--告诉maven将项目源码中的xml文件也进行编译，并放到编译目录中-->\n    &lt;resources>\n        &lt;resource>\n            &lt;directory>src/main/java&lt;/directory>\n            &lt;includes>\n                &lt;include>**/*.xml&lt;/include>\n            &lt;/includes>\n            &lt;filtering>true&lt;/filtering>\n        &lt;/resource>\n        &lt;resource>\n            &lt;directory>src/main/resources&lt;/directory>\n            &lt;filtering>true&lt;/filtering>\n        &lt;/resource>\n    &lt;/resources>\n&lt;/build>\n","slug":"Mybatis","date":"2022-10-06T16:00:00.000Z","categories_index":"Mybatis","tags_index":"框架,ORM","author_index":"雾都"},{"id":"eb3ef2175aab37a16c1ed443702f7a7d","title":"RabbitMQ","content":"# 主要内容\n\n\nAMQP 简介\n\n\nRabbitMQ 简介\n\n\nRabbitMQ 原理\n\n\nErlang 安装\n\n\n安装 RabbitMQ\n\n\nRabbitMQ 账户管理\n\n\n交换器\n\n\n# 学习目标\n\n\n\n知识点\n要求\n\n\n\n\nAMQP 简介\n掌握\n\n\nRabbmitMQ 简介\n掌握\n\n\nRabbitMQ 原理\n掌握\n\n\nErlang 安装\n掌握\n\n\n安装 RabbitMQ\n掌握\n\n\nRabbitMQ 账户管理\n掌握\n\n\n交换器\n掌握\n\n\n\n# 一、 AMQP 简介\n# 1 AMQP 是什么？\n​\tAMQP (Advanced Message Queuing Protocol, 高级消息队列协议) 是进程之间传递异步消息的网络协议。\n# 2 AMQP 工作过程\n​\t发布者 (Publisher) 发布消息 (Message), 经过交换机 (Exchange)，交换机根据路由规则将收到消息分发给交换机绑定的队列 (Queue)，最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。\n\n# 3 队列\n​\t队列是数据结构中概念。数据存储在一个队列中，数据是有顺序的，先进的先出，后进后出。其中一侧负责进数据，另一侧负责出数据。\nMQ（消息队列）很多功能都是基于此队列结构实现的！\n# 二、 RabbitMQ 简介\n# 1 RabbitMQ 介绍\n​\tRabbitMQ 是由 Erlang 语言编写的基于 AMQP 的消息中间件。而消息中间件作为分布式系统重要组件之一，可以解决应用耦合，异步消息，流量削峰等问题。\n# 1.1 解决应用耦合\n# 1.1.1 不使用 MQ 时\n\n# 1.1.2 使用 MQ 解决耦合\n\n# 2 RabbitMQ 适用场景\n​\t排队算法：使用消息队列特性\n​\t秒杀活动：使用消息队列特性\n​\t消息分发：使用消息异步特性\n​\t异步处理：使用消息异步特性\n​\t数据同步：使用消息异步特性\n​\t处理耗时任务：使用消息异步特性\n​\t流量销峰\n# 三、 RabbitMQ 原理\n\n\n\n\n1.Message\n\n\n\n\n消息。消息是不具名的，它由消息头消息体组成。消息体是不透明的，而消息头则由一系列可选属性组成，这些属性包括：routing-key (路由键)、priority (相对于其他消息的优先权)、delivery-mode (指出消息可能持久性存储) 等。\n\n\n2.Publisher\n\n\n消息的生产者。也是一个向交换器发布消息的客户端应用程序。\n\n\n3.Consumer\n\n\n消息的消费者。表示一个从消息队列中取得消息的客户端应用程序。\n\n\n4.Exchange\n\n\n交换器。用来接收生产者发送的消息并将这些消息路由给服务器中的队列。三种常用的交换器类型 1. direct (发布与订阅 完全匹配) 2. fanout (广播) 3. topic (主题，规则匹配)\n\n\n5.Binding\n\n\n绑定。用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。\n\n\n6.Queue\n\n\n消息队列。用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者链接到这个队列将其取走。\n\n\n7.Routing-key\n\n\n路由键。RabbitMQ 决定消息该投递到哪个队列的规则。（也可以理解为队列的名称，路由键是 key，队列是 value）队列通过路由键绑定到交换器。消息发送到 MQ 服务器时，消息将拥有一个路由键，即便是空的，RabbitMQ 也会将其和绑定使用的路由键进行匹配。如果相匹配，消息将会投递到该队列。如果不匹配，消息将会进入黑洞。\n\n\n8.Connection\n\n\n链接。指 rabbit 服务器和服务建立的 TCP 链接。\n\n\n9.Channel\n\n\n信道。1，Channel 中文叫做信道，是 TCP 里面的虚拟链接。例如：电缆相当于 TCP，信道是一个独立光纤束，一条 TCP 连接上创建多条信道是没有问题的。2，TCP 一旦打开，就会创建 AMQP 信道。3，无论是发布消息、接收消息、订阅队列，这些动作都是通过信道完成的。\n\n\n10.Virtual Host\n\n\n虚拟主机。表示一批交换器，消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在链接时指定，RabbitMQ 默认的 vhost 是 **/**\n\n\n11.Borker\n\n\n表示消息队列服务器实体。\n\n\n12. 交换器和队列的关系\n\n\n交换器是通过路由键和队列绑定在一起的，如果消息拥有的路由键跟队列和交换器的路由键匹配，那么消息就会被路由到该绑定的队列中。     也就是说，消息到队列的过程中，消息首先会经过交换器，接下来交换器在通过路由键匹配分发消息到具体的队列中。     路由键可以理解为匹配的规则。\n\n\n13.RabbitMQ 为什么需要信道？为什么不是 TCP 直接通信？\n\n\n1. TCP 的创建和销毁开销特别大。创建需要 3 次握手，销毁需要 4 次分手。2. 如果不用信道，那应用程序就会以 TCP 链接 Rabbit，高峰时每秒成千上万条链接会造成资源巨大的浪费，而且操作系统每秒处理 TCP 链接数也是有限制的，必定造成性能瓶颈。3. 信道的原理是一条线程一条通道，多条线程多条通道同用一条 TCP 链接。一条 TCP 链接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能的瓶颈。\n\n\n\n# 四、 Erlang 安装\n​\tRabbitMQ 是使用 Erlang 语言编写的，所以需要先配置 Erlang\n# 1 修改主机名\n​\tRabbitMQ 是通过主机名进行访问的，必须指定能访问的主机名。\nvim &#x2F;etc&#x2F;sysconfig&#x2F;network\n\nvim &#x2F;etc&#x2F;hosts\n​\t新添加了一行，前面为服务器 ip，空格后面添加计算机主机名\n\n# 2 安装依赖\nyum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC unixODBC-devel\n# 3 上传并解压\n​\t上传 otp_src_22.0.tar.gz 到 /usr/local/tmp 目录中，进入目录并解压。\n解压时注意，此压缩包不具有gzip属性，解压参数没有z，只有xf\n\ncd &#x2F;usr&#x2F;local&#x2F;tmp\ntar xf otp_src_22.0.tar.gz -C &#x2F;usr&#x2F;local&#x2F;tmp\n# 4 配置参数\n​\t先新建 /usr/local/erlang 文件夹，作为安装文件夹\nmkdir -p &#x2F;usr&#x2F;local&#x2F;erlang\n​\t 进入文件夹\ncd otp_src_22.0\n​\t 配置参数\n.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;erlang --with-ssl --enable-threads --enable-smp-support --enable-kernel-poll --enable-hipe --without-javac\n# 5 编译并安装\n​\t编译\nmake\n​\t 安装\nmake install\n# 6 修改环境变量\n​\t修改 /etc/profile 文件\nvim &#x2F;etc&#x2F;profile\n​\t 在文件中添加下面代码\nexport PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;erlang&#x2F;bin\n​\t运行文件，让修改内容生效\nsource &#x2F;etc&#x2F;profile\n# 7 查看配置是否成功\nerl -version\n\n# 五、 安装 RabbitMQ\n# 1 上传并解压\n​\t上传 rabbitmq-server-generic-unix-3.7.18.tar.xz 到 /usr/loca/tmp 中\ncd &#x2F;usr&#x2F;local&#x2F;tmp\ntar xf rabbitmq-server-generic-unix-3.7.18.tar.xz\n# 2 复制到 local 下\n​\t复制解压文件到 /usr/local 下，命名为 rabbitmq\ncp -r rabbitmq_server-3.7.18 &#x2F;usr&#x2F;local&#x2F;rabbitmq\n# 3 配置环境变量\nvim &#x2F;etc&#x2F;profile\n​\t在文件中添加\nexport PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;rabbitmq&#x2F;sbin\n​\t解析文件\n# source &#x2F;etc&#x2F;profile\n# 4 开启 web 管理插件\n​\t进入 rabbitmq/sbin 目录\n# cd &#x2F;usr&#x2F;local&#x2F;rabbitmq&#x2F;sbin\n查看插件列表\n\n# .&#x2F;rabbitmq-plugins list\n生效管理插件\n\n# .&#x2F;rabbitmq-plugins enable rabbitmq_management\n# 5 后台运行\n​\t启动 rabbitmq。\n# .&#x2F;rabbitmq-server -detached\n​\t停止命令，如果无法停止，使用 kill -9 进程号进行关闭\n# .&#x2F;rabbitmqctl stop_app\n# 6 查看 web 管理界面\n​\t默认可以在安装 rabbitmq 的电脑上通过用户名：guest 密码 guest 进行访问 web 管理界面\n​\t端口号：15672（放行端口，或关闭防火墙）\n​\t在虚拟机浏览器中输入：\n​\thttp://localhost:15672\n# 六、 RabbitMq 账户管理\n# 1 创建账户\n​\t语法：./rabbitmqctl add_user username password\n# cd &#x2F;usr&#x2F;local&#x2F;rabbitmq&#x2F;sbin\n# .&#x2F;rabbitmqctl add_user mashibing mashibing\n# 2 给用户授予管理员角色\n​\t其中 smallming 为新建用户的用户名\n# .&#x2F;rabbitmqctl set_user_tags mashibing administrator\n# 3 给用户授权\n​\t“/” 表示虚拟机\n​\tmashibing 表示用户名\n​\t“.&quot; &quot;.” “.*” 表示完整权限\n# .&#x2F;rabbitmqctl set_permissions -p &quot;&#x2F;&quot; mashibing &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;\n# 4 登录\n​\t使用新建账户和密码在 windows 中访问 rabbitmq 并登录\n​\t在浏览器地址栏输入：\n​\thttp://ip:15672/\n用户名：mashibing\n\n​\t密码：mashibing\n# 七、 交换器（交换机）\n​\t交换器负责接收客户端传递过来的消息，并转发到对应的队列中。在 RabbitMQ 中支持四种交换器\n​\t1.Direct Exchange：直连交换器（默认）\n​\t2.Fanout Exchange：扇形交换器\n​\t3.Topic Exchange：主题交换器\n​\t4.Header Exchange：首部交换器。\n​\t在 RabbitMq 的 Web 管理界面中 Exchanges 选项卡就可以看见这四个交换器。\n\n# 1 direct 交换器\n​\tdirect 交换器是 RabbitMQ 默认交换器。默认会进行公平调度。所有接受者依次从消息队列中获取值。Publisher 给哪个队列发消息，就一定是给哪个队列发送消息。对交换器绑定的其他队列没有任何影响。\n​\t（代码演示）一个队列需要绑定多个消费者\n​\t需要使用注解 / API：\n​\torg.springframework.amqp.core.Queue: 队列\n​\tAmqpTemplate：操作 RabbitMQ 的接口。负责发送或接收消息\n​\t@RabbitListener (queues = “”) 注解某个方法为接收消息方法\n# 1.1 代码实现\n# 1.1.1 新建项目 Publisher\n# 1.1.1.1 添加依赖\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n# 1.1.1.2 编写配置文件\n​\t新建 application.yml.\n​\thost: 默认值 localhost\n​\tusername 默认值：guest\n​\tpassword 默认值：guest\nspring:\n  rabbitmq:\n    host: 192.168.1.195\n    username: mashibing\n    password: mashibing\n# 1.1.1.3 编写配置类\n新建 com.config.RabbitmqConfig\n​\t队列的创建只有没有这个队列的时候需要编写。以后没有这个 queue () 方法也可以。\n@Configuration\npublic class RabbitmqConfig &#123;\n    @Bean\n    protected Queue queue()&#123;\n        Queue queue &#x3D; new Queue(&quot;myqueue&quot;);\n        return queue;\n    &#125;\n&#125;\n# 1.1.1.4 编写启动类\n略\n# 1.1.1.5 编写测试类\nSpringBoot 整合 Spring-AMQP 后包含内置对象 AmqpTemplate\n@SpringBootTest(classes &#x3D; PublisherApplication.class)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class MyTest &#123;\n    @Autowired\n    private AmqpTemplate amqpTemplate;\n\n    @Test\n    public void test()&#123;\n        amqpTemplate.convertAndSend(&quot;myqueue&quot;,&quot;这是内容1&quot;);\n        System.out.println(&quot;发送成功&quot;);\n    &#125;\n&#125;\n# 1.1.2 创建 Consumer\n​\t新建项目 consumer\n# 1.1.2.1 添加依赖\n​\t和 Publisher 一样\n# 1.1.2.2 编写配置文件\n​\t和 Publisher 一样\n# 1.1.2.3 编写监听器方法\n​\t注意：\n​\t类上要有 @Componet，项目启动时此类生效。\n​\t@RabbitListener 监听指定队列。\n@Component\npublic class DemoReceive &#123;\n\n    @RabbitListener(queues &#x3D; &quot;myqueue&quot;)\n    public void demo(String msg)&#123;\n        System.out.println(&quot;获取到的消息1111：&quot;+msg);\n    &#125;\n\n    @RabbitListener(queues &#x3D; &quot;myqueue&quot;)\n    public void demo2(String msg)&#123;\n        System.out.println(&quot;获取到的消息2222：&quot;+msg);\n    &#125;\n&#125;\n# 1.1.2.4 新建启动类\n​\t略。启动后此项目一直处于运行状态。属于长连接。\n# 2 fanout 交换器\n​\t扇形交换器，实际上做的事情就是广播，fanout 会把消息发送给所有的绑定在当前交换器上的队列。且每个队列消息中第一个 Consumer 能收到消息。\n​\t（代码演示）一个交换器需要绑定多个队列\n​\t需要使用注解 / API：\n​\tFanoutExchange：fanout 交换器\n​\tBinding：绑定交换器和队列\n​\tBindingBuilder：Binding 的构建器\n​\tamq.fanout: 内置 fanout 交换器名称\n# 2.1 代码\n# 2.1.1 Publisher\n# 2.1.1.1 修改配置类\n@Bean\nprotected Queue fanoutQuque1()&#123;\n    return new Queue(&quot;fanout1&quot;);\n&#125;\n\n@Bean\nprotected Queue fanoutQuque2()&#123;\n    return new Queue(&quot;fanout2&quot;);\n&#125;\n\n@Bean\nprotected FanoutExchange fanoutExchange()&#123;\n    return new FanoutExchange(&quot;amq.fanout&quot;);\n&#125;\n\n@Bean\nprotected Binding fanoutBinding(Queue fanoutQuque1,FanoutExchange fanoutExchange)&#123;\n    return BindingBuilder.bind(fanoutQuque1).to(fanoutExchange);\n&#125;\n\n@Bean\nprotected Binding fanoutBinding2(Queue fanoutQuque2,FanoutExchange fanoutExchange)&#123;\n    return BindingBuilder.bind(fanoutQuque2).to(fanoutExchange);\n&#125;\n# 2.1.2 编写发送方法 ****\n​\t第二个参数 routingKey 对于 fanout 没有意义的\n@Test\npublic void test2()&#123;\n    amqpTemplate.convertAndSend(&quot;amq.fanout&quot;,&quot;asdfadsf&quot;,&quot;fanout msg&quot;);\n    System.out.println(&quot;发送成功&quot;);\n&#125;\n# 2.1.3 Consumer\n​\tConsumer 代码和 Direct 完全相同。一个队列给一个监听方法即可。\n# 3 topic 交换器\n​\t允许在路由键（RoutingKey）中出现匹配规则。\n​\t路由键的写法和包写法相同。com.msb.xxxx.xxx 格式。\n​\t在绑定时可以带有下面特殊符号，中间可以出现:\n​\t* : 代表一个单词（两个。之间内容）\n​\t# : 0 个或多个字符\n​\t接收方依然是公平调度，同一个队列中内容轮换获取值。\n​\t需要使用注解 / API：\n​\tTopicExchange：Topic 交换器\n​\tamq.topic: 内置 topic 交换器名称\n# 3.1 代码\n# 3.1.1 Publisher\n# 3.1.1.1 配置类。\n​\t之所以建立两个队列目的是为了演示使用 Topic 完成 Fanout 效果。\n@Bean\nprotected Queue topicQueue() &#123;\n    return new Queue(&quot;topic1&quot;);\n&#125;\n\n@Bean\nprotected Queue topicQueue2() &#123;\n    return new Queue(&quot;topic2&quot;);\n&#125;\n\n@Bean\nprotected TopicExchange topicExchange() &#123;\n    return new TopicExchange(&quot;amq.topic&quot;);\n&#125;\n\n@Bean\nprotected Binding topicBinding(Queue topicQueue, TopicExchange topicExchange) &#123;\n    return BindingBuilder.bind(topicQueue).to(topicExchange).with(&quot;com.a&quot;);\n&#125;\n\n@Bean\nprotected Binding topicBinding2(Queue topicQueue2, TopicExchange topicExchange) &#123;\n    return BindingBuilder.bind(topicQueue2).to(topicExchange).with(&quot;com.#&quot;);\n&#125;\n# 3.1.1.2 发送消息\n​\t第二个参数为路由键，匹配配置类中绑定时的路由规则。\n@Test\npublic void test3()&#123;\n    amqpTemplate.convertAndSend(&quot;amq.topic&quot;,&quot;com.bjsxt.a.b&quot;,&quot;topic msg&quot;);\n    System.out.println(&quot;发送成功&quot;);\n&#125;\n3.1.2 Consumer\n​\tConsumer 代码与以前一样，注意队列名称 topic1,topic2 不要写路由键名称。(queues 取值)\n@RabbitListener(queues &#x3D; &quot;topic2&quot;)\npublic void demo10(String msg)&#123;\n    System.out.println(&quot;topic2-2:&quot;+msg);\n&#125;\n# 八、 传递对象类型参数\n​\t如果消息是对象类型，此对象的类型必须进行序列化，且需要给定序列化值\npublic class People implements Serializable \n&#123;\n    public static final long serialVersionUID&#x3D;1L;\n&#125;\n","slug":"RabbitMQ","date":"2022-10-06T16:00:00.000Z","categories_index":"分布式,RabbitMQ","tags_index":"分布式,中间件,RabbitMQ","author_index":"雾都"},{"id":"2307afeebfa3d0a700b40ffec9a054c8","title":"RPC","content":"# 【RPC】\n# 主要内容\n\n\n项目结构变化\n\n\nRPC 简介\n\n\nRMI 实现 RPC\n\n\nHttpClient 实现 RPC\n\n\nZookeeper 安装\n\n\nZookeeper 客户端常用命令\n\n\n向 Zookeeper 中注册内容\n\n\n从 Zookeeper 中发现内容\n\n\n手写 RPC 框架\n\n\n# 学习目标\n\n\n\n知识点\n要求\n\n\n\n\n项目架构变化\n掌握\n\n\nRPC 简介\n掌握\n\n\nRMI 实现 RPC\n掌握\n\n\nHttpClient 实现 RPC\n了解\n\n\nZookeeper 安装\n掌握\n\n\nZookeeper 客户端常用命令\n掌握\n\n\n向 Zookeeper 中注册内容\n掌握\n\n\n从 zookeeper 中发现内容\n掌握\n\n\n手写 RPC 框架\n掌握\n\n\n\n# 一、今天学什么？为什么讲？\n​\t 现在学习 RPC。后期学习的 Dubbo 是一个 RPC 框架，学习好现在的内容，学习 Dubbo 将会变得容易一些。\n# 二、项目架构变化\n# 1     单体架构\n# 1.1   架构图\n​\t单体架构就是一个项目里面包含这个项目中全部代码。一个应用搞定全部功能。\n​\tDNS 服务器可以是单映射，也可以配置多个映射。\n\n# 1.2   软件代码结构\n​\t在单体架构项目中，团队都是通过包 (package) 进行区分每个模块。\n​\t总体包结构：com.msb.*. 分层包。\n项目名：\n  -- com\n    --msb\n      -- common\n        -- utils\n      --user\n        -- controller\n        -- service\n        -- mapper\n      -- sys\n        -- controller\n        -- service\n        -- mapper\n# 1.3   优缺点\n# 1.3.1    优点\n​\t部署简单\n​\t维护方便\n​\t成本低\n# 1.3.2    缺点\n​\t当项目规模大、用户访问频率高、并发量大、数据量大时，会大大降低程序执行效率，甚至出现服务器宕机等情况。\n# 1.4   适用项目\n传统管理项目，小型互联网项目。\n# 2     分布式架构\n# 2.1   架构图（简易版）\n​\t分布式架构会把一个项目按照特定要求（多按照模块或功能）拆分成多个项目，每个项目分别部署到不同的服务器上。\n\n# 2.2   软件代码结构\n项目1：\n  --com.msb.xxx\n    -- controller\n    -- service\n    -- mapper\n项目2\n  --com.msb.mmm\n    -- controller\n    -- service\n    -- mapper\n# 2.3   优缺点\n# 2.3.1    优点\n​\t增大了系统可用性。减少单点故障，导致整个应用不可用。\n​\t增加重用性。因为模块化，所以重用性更高。\n​\t增加可扩展性。有新的模块增加新的项目即可。\n​\t增加每个模块的负载能力。因为每个模块都是一个项目，所以每个模块的负载能力更强。\n# 2.3.2    缺点\n​\t成本更高。\n​\t架构更加复杂。\n​\t整体响应之间变长，一些业务需要多项目通信后给出结果。\n​\t吞吐量更大。吞吐量 = 请求数 / 秒。\n# 2.4   待解决问题\n​\t分布式架构中各个模块如何进行通信？\n​\t可以使用 Http 协议，也可以使用 RPC 协议通信，也可以使用其他的通信方式。我们本阶段使用的是 RPC 协议，因为它比 HTTP 更适合项目内部通信。\n# 三、RPC 简介\n# 1     RFC\n​\tRFC (Request For Comments) 是由互联网工程任务组 (IETF) 发布的文件集。文件集中每个文件都有自己唯一编号，例如：rfc1831。目前 RFC 文件由互联网协会 (Internet Society，ISOC) 赞助发型。\n​\tRPC 就收集到了 rfc 1831 中。可以通过下面网址查看：\n​\thttps://datatracker.ietf.org/doc/rfc1831/\n# 2     RPC\n​\tRPC 在 rfc 1831 中收录 ，RPC（Remote Procedure Call） 远程过程调用协议\n​\tRPC 协议规定允许互联网中一台主机程序调用另一台主机程序，而程序员无需对这个交互过程进行编程。在 RPC 协议中强调当 A 程序调用 B 程序中功能或方法时，A 是不知道 B 中方法具体实现的。\n​\tRPC 是上层协议，底层可以基于 TCP 协议，也可以基于 HTTP 协议。一般我们说 RPC 都是基于 RPC 的具体实现，如：Dubbo 框架。从广义上讲只要是满足网络中进行通讯调用都统称为 RPC，甚至 HTTP 协议都可以说是 RPC 的具体实现，但是具体分析看来 RPC 协议要比 HTTP 协议更加高效，基于 RPC 的框架功能更多。\n​\tRPC 协议是基于分布式架构而出现的，所以 RPC 在分布式项目中有着得天独厚的优势。\n# 3     RPC 和 HTTP 对比\n# 3.1   具体实现\n​\tRPC：可以基于 TCP 协议，也可以基于 HTTP 协议。\n​\tHTTP：基于 HTTP 协议\n# 3.2   效率\n​\tRPC：自定义具体实现可以减少很多无用的报文内容，使得报文体积更小。\n​\tHTTP：如果是 HTTP 1.1 报文中很多内容都是无用的。如果是 HTTP2.0 以后和 RPC 相差不大，比 RPC 少的可能就是一些服务治理等功能。\n# 3.3   连接方式\n​\tRPC：长连接支持。\n​\tHTTP：每次连接都是三次握手四次挥手。\n# 3.4   性能\n​\tRPC 可以基于很多序列化方式。如：thrift\n​\tHTTP 主要是通过 JSON，序列化和反序列效率更低。\n# 3.5   注册中心\n​\tRPC ：一般 RPC 框架都带有注册中心。\n​\tHTTP：都是直连。\n# 3.6   负载均衡\n​\tRPC：绝大多数 RPC 框架都带有负载均衡测量。\n​\tHTTP：一般都需要借助第三方工具。如：nginx\n# 3.7   综合结论\n​\tRPC 框架一般都带有丰富的服务治理等功能，更适合企业内部接口调用。而 HTTP 更适合多平台之间相互调用。\n# 四、HttpClient 实现 RPC\n# 1     HttpClient 简介\n​\t在 JDK 中 java.net 包下提供了用户 HTTP 访问的基本功能，但是它缺少灵活性或许多应用所需要的功能。\n​\tHttpClient 起初是 Apache Jakarta Common 的子项目。用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本。2007 年成为顶级项目。\n​\t通俗解释：HttpClient 可以实现使用 Java 代码完成标准 HTTP 请求及响应。\n# 2     代码实现\n# 2.1   服务端\n​\t新建项目 HttpClientServer\n# 2.1.1    新建控制器\ncom.msb.controller.DemoController\n@Controller\npublic class DemoController &#123;\n    @RequestMapping(\"/demo\")\n    @ResponseBody\n    public String demo(String param)&#123;\n        return \"demo\"+param;\n    &#125;\n&#125;\n# 2.1.2    新建启动器\n​\t新建启动器\ncom.msb.HttpClientServerApplication\n@SpringBootApplication\npublic class HttpClientServerApplication &#123;\n    public static void main(String[] args) &#123;\n    SpringApplication.run(HttpClientServerApplication.class,args);\n    &#125;\n&#125;\n# 2.2   客户端\n​\t新建 HttpClientDemo 项目\n# 2.2.1    添加依赖\n&lt;dependency>\n       &lt;groupId>org.apache.httpcomponents&lt;/groupId>\n       &lt;artifactId>httpclient&lt;/artifactId>\n       &lt;version>4.5.10&lt;/version>\n&lt;/dependency>\n# 2.2.2    新建类\n​\t新建 com.msb.HttpClientDemo，编写主方法。\n# 2.2.2.1 使用 GET 方法访问\npublic static void main(String[] args) &#123;\n    try &#123;\n    \t//创建http工具（理解成:浏览器） 发起请求，解析响应\n        CloseableHttpClient httpClient = HttpClients.createDefault();\n        //请求路径\n        URIBuilder uriBuilder = new URIBuilder(\"http://localhost:8080/demo\");\n        uriBuilder.addParameter(\"param\", \"get123\");\n        //创建HttpGet请求对象\n        HttpGet get = new HttpGet(uriBuilder.build());\n        //创建响应对象\n        CloseableHttpResponse response = httpClient.execute(get);\n        //由于响应体是字符串，因此把HttpEntity类型转换为字符串类型，并设置字符编码\n        String result = EntityUtils.toString(response.getEntity(), \"utf-8\");\n        //输出结果\n        System.out.println(result);\n        //释放资源\n        response.close();\n        httpClient.close();\n    &#125; catch (URISyntaxException e) &#123;\n        e.printStackTrace();\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n# 2.2.2.2 使用 POST 方式访问\npublic class HttpClientDemo &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n        \t//创建http工具（理解成:浏览器） 发起请求，解析响应\n            CloseableHttpClient httpClient = HttpClients.createDefault();\n            //创建HttpPOST请求对象\n            HttpPost post = new HttpPost(\"http://localhost:8080/demo\");\n            //所有请求参数\n            List&lt;NameValuePair> params = new ArrayList&lt;>();\n            params.add(new BasicNameValuePair(\"param\",\"123\"));\n            //创建HttpEntity接口的文本实现类的对象，放入参数并设置编码\n            HttpEntity httpEntity = new UrlEncodedFormEntity(params,\"utf-8\");\n            //放入到HttpPost对象中\n            post.setEntity(httpEntity);            \n            //创建响应对象\n            CloseableHttpResponse response = httpClient.execute(post);\n            //由于响应体是字符串，因此把HttpEntity类型转换为字符串类型\n            String result = EntityUtils.toString(response.getEntity());\n            //输出结果\n            System.out.println(result);\n            //释放资源\n            response.close();\n            httpClient.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n# 3. Jackson 用法\n# 3.1   把对象转换为 json 字符串\nObjectMapper objectMapper = new ObjectMapper();\nPeople peo = new People();\nobjectMapper.writeValueAsString(peo);\n# 3.2   把 json 字符串转换为对象\nObjectMapper objectMapper = new ObjectMapper();\nPeople peo = objectMapper.readValue(content, People.class);\n# 3.3   把 json 字符串转换为 List 集合\nObjectMapper objectMapper = new ObjectMapper();\nJavaType javaType = objectMapper.getTypeFactory().constructParametricType(List.class, People.class);\nList&lt;People> list = objectMapper.readValue(content, javaType);\n# 4     HttpClient 请求包含 JSON\n# 4.1   java 代码实现\npublic class HttpClientDemo &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            CloseableHttpClient httpClient = HttpClients.createDefault();\n            HttpPost post = new HttpPost(\"http://localhost:8080/demo\");\n            HttpEntity httpEntity= null;\n\t\t\tString json = \"&#123;&#125;\";\n            StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON);\n            post.setEntity(entity);\n            CloseableHttpResponse response = httpClient.execute(post);\n            String result = EntityUtils.toString(response.getEntity());\n            System.out.println(result);\n            response.close();\n            httpClient.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n @Test\n    public void testInputSteam()&#123;\n        try &#123;\n\n            CloseableHttpClient httpClient = HttpClients.createDefault();\n\n            URIBuilder uriBuilder = new URIBuilder(\"http://localhost:8080/demo4\");\n\n            HttpPost httpPost = new HttpPost(uriBuilder.build());\n            //创建集合\n            List&lt;User> users = new ArrayList&lt;>();\n            users.add(new User(2,\"李四\"));\n            users.add(new User(1,\"张三\"));\n            //将集合对象转化成JSON字符串\n            ObjectMapper objectMapper = new ObjectMapper();\n            String UserJson = objectMapper.writeValueAsString(users);\n            System.out.println(UserJson);\n            StringEntity stringEntity = new StringEntity(UserJson, \t\t  ContentType.APPLICATION_JSON);\n            //设置请求体\n            httpPost.setEntity(stringEntity);\n            CloseableHttpResponse response= httpClient.execute(httpPost);\n            String result = EntityUtils.toString(response.getEntity());\n            System.out.println(result);\n\n            response.close();\n            httpClient.close();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n# 5     控制器接口参数\n​\t@RequestBody 把请求体中流数据转换为指定的对象。多用在请求参数是 json 数据且请求的 Content-Type=”application/json”\n@RequestMapping(\"/demo4\")\n@ResponseBody\npublic String demo4(@RequestBody List&lt;People> list) &#123;\n    System.out.println(list);\n    return list.toString();\n&#125;\n# 6   Ajax 发送 json 参数写法\nvar json = '[&#123;\"id\":123,\"name\":\"msb\"&#125;,&#123;\"id\":123,\"name\":\"mashibing\"&#125;]';\n $.ajax(&#123;\n     url:'/demo5',\n     type:'post',\n     success:function(data)&#123;\n         alert(data);\n         for(var i = 0 ;i&lt;data.length;i++)&#123;\n\n             alert(data[i].id +\"  \"+data[i].name);\n         &#125;\n     &#125;,\n     contentType:'application/json',//请求体中内容类型\n     dataType:'json',//响应内容类型。\n     data:json\n &#125;);\n# 7     跨域\n​\t跨域：协议、ip、端口中只要有一个不同就是跨域请求。\n​\t同源策略：浏览器默认只允许 ajax 访问同源 (协议、ip、端口都相同) 内容。\n​\t解决同源策略：\n​\t在控制器接口上添加 @CrossOrigin。表示允许跨域。本质在响应头中添加 Access-Control-Allow-Origin: *\nvar json = '[&#123;\"id\":123,\"name\":\"msb\"&#125;,&#123;\"id\":456,\"name\":\"mashibing\"&#125;]';\n $.ajax(&#123;\n     url:'/demo5',\n     type:'post',\n     success:function(data)&#123;\n         alert(data);\n         for(var i = 0 ;i&lt;data.length;i++)&#123;\n\n             alert(data[i].id +\"  \"+data[i].name);\n         &#125;\n     &#125;,\n     contentType:'application/json',//请求体中内容类型\n     dataType:'json',//响应内容类型。\n     data:json\n &#125;);\n# 五、RMI 实现 RPC\n# 1     RMI 简 介\n​\tRMI (Remote Method Invocation) 远程方法调用。\n​\tRMI 是从 JDK1.2 推出的功能，它可以实现在一个 Java 应用中可以像调用本地方法一样调用另一个服务器中 Java 应用（JVM）中的内容。\n​\tRMI 是 Java 语言的远程调用，无法实现跨语言。\n# 2     执行流程\n\n​\tRegistry (注册表) 是放置所有服务器对象的命名空间。 每次服务端创建一个对象时，它都会使用 bind () 或 rebind () 方法注册该对象。 这些是使用称为绑定名称的唯一名称注册的。\n​\t要调用远程对象，客户端需要该对象的引用。即通过服务端绑定的名称从注册表中获取对象 (lookup () 方法)。\n# 3     API 介绍\n# 3.1   Remote\n​\tjava.rmi.Remote 定义了此接口为远程调用接口。如果接口被外部调用，需要继承此接口。\npublic interface Remote&#123;&#125;\n# 3.2   RemoteException\n​\tjava.rmi.RemoteException\n​\t继承了 Remote 接口的接口中，如果方法是允许被远程调用的，需要抛出此异常。\n# 3.3   UnicastRemoteObject\n​\tjava.rmi.server.UnicastRemoteObject\n​\t此类实现了 Remote 接口和 Serializable 接口。\n​\t自定义接口实现类除了实现自定义接口还需要继承此类。\n# 3.4   LocateRegistry\n​\tjava.rmi.registry.LocateRegistry\n​\t可以通过 LocateRegistry 在本机上创建 Registry，通过特定的端口就可以访问这个 Registry。\n# 3.5   Naming\n​\tjava.rmi.Naming\n​\tNaming 定义了发布内容可访问 RMI 名称。也是通过 Naming 获取到指定的远程方法。\n# 4     代码实现\n# 4.1   服务端创建\n​\t创建 RmiServer 项目\n# 4.1.1    编写接口\n​\tcom.msb.service.DemoService 编写\npublic interface DemoService extends Remote &#123;\n    String demo(String demo) throws RemoteException;\n&#125;\n# 4.1.2    编写实现类\n​\tcom.msb.service.impl.DemoServiceImpl 编写。\n​\t注意：构造方法是 public 的。默认生成 protected\npublic class DemoServiceImpl extends UnicastRemoteObject implements DemoService &#123;\n    public DemoServiceImpl() throws RemoteException &#123;\n    &#125;\n    @Override\n    public String demo(String demo) throws RemoteException &#123;\n        return demo+\"123\";\n    &#125;\n&#125;\n# 4.1.3    编写主方法\n​\t编写 com.msb.DemoServer 类，生成主方法\npublic class DemoServiceImpl extends UnicastRemoteObject implements DemoService &#123;\n    public DemoServiceImpl() throws RemoteException &#123;\n    &#125;\n    @Override\n    public String demo(String demo) throws RemoteException &#123;\n        return demo+\"123\";\n    &#125;\n&#125;\npublic class DemoStart &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            //1创建接口实现类\n            RmiDemo rmiDemo = new RmiDemoImpl();\n            //2创建注册表\n            LocateRegistry.createRegistry(8099);\n            //3绑定服务\n            Naming.bind(\"rmi://localhost:8099/rmiDemo\",rmiDemo);\n\n            System.out.println(\"服务器启动！\");\n        &#125; catch (RemoteException e) &#123;\n            e.printStackTrace();\n        &#125; catch (AlreadyBoundException e) &#123;\n            e.printStackTrace();\n        &#125; catch (MalformedURLException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n# 4.1.4    运行项目\n​\t运行后项目，项目一直处于启动状态，表示可以远程访问此项目中的远程方法。\n# 4.2   创建客户端代码\n​\t创建项目 RmiClient\n# 4.2.1    复制服务端接口\n​\t把服务端 com.msb.service.DemoService 粘贴到项目中\n# 4.2.2    创建主方法类\n​\t新建 com.msb.DemoClient\npublic class DemoServiceImpl extends UnicastRemoteObject implements DemoService &#123;\n    public DemoServiceImpl() throws RemoteException &#123;\n    &#125;\n    @Override\n    public String demo(String demo) throws RemoteException &#123;\n        return demo+\"123\";\n    &#125;\n&#125;\n# 六、Zookeeper 安装\n# 1     Zookeeper 简介\n​\tzookeeper 分布式管理软件。常用它做注册中心（依赖 zookeeper 的发布 / 订阅功能）、配置文件中心、分布式锁配置、集群管理等。\n​\tzookeeper 一共就有两个版本。主要使用的是 java 语言写的。\n# 2     安装\n# 2.1   上传压缩文件\n​\t上传到 /usr/local/tmp 中\n# 2.2   解压\ntar zxf apache-zookeeper-3.5.5-bin.tar.gz\ncp -r apache-zookeeper-3.5.5-bin ../zookeeper\n# 2.3   新建 data 目录\n进入到 zookeeper 中\ncd /usr/local/zookeeper\nmkdir data\n# 2.4   修改配置文件\n进入 conf 中\ncd conf\ncp zoo_sample.cfg zoo.cfg\nvim zoo.cfg\n修改 dataDir 为 data 文件夹路径\ndataDir=/usr/local/zookeeper/data\n# 2.5   启动 zookeeper\n进入 bin 文件夹\ncd /usr/local/zookeeper/bin\n./zkServer.sh start\n通过 status 查看启动状态。稍微有个等待时间\n# ./zkServer.sh status\n# 六、Zookeeper 安装 (Docker)\n资料：\nhttps://www.cnblogs.com/kingkoo/p/8732448.html\nhttps://www.bilibili.com/video/av80874666?from=search&amp;seid=1629145025211999104&amp;spm_id_from=333.337.0.0\n# 1     Zookeeper 简介\n​\tzookeeper 分布式管理软件。常用它做注册中心（依赖 zookeeper 的发布 / 订阅功能）、配置文件中心、分布式锁配置、集群管理等。\n​\tzookeeper 一共就有两个版本。主要使用的是 java 语言写的。\n# 2     安装\n# 2.1   拉取镜像\n\n\n自定义 zookeeper 目录\n mkdir /root/zookeeper\n\nmkdir /root/zookeeper/data #原因参照上面 -在docker中data其实也不用在宿主机行自己生成(目前如此)\n\n#仓库官网查看版本或者用命令直接查\ndocker search zookeeper\n\n#拉取特定版本（3.5）\ndocker pull zookeeper:3.5\n\n\n\n# 2.2 创建并启动容器\n​\t注：就目前而且 好像直接在 docker 中使用 zookeeper 不需要过多的配置，直接用命令创建吧，下面的解释先不看，具体原因后面补充\n命令：\ndocker run -d --name zookeeper -v /root/zookeeper/data:/data -p 2181:2181 --restart always zookeeper:3.5\n\n--restart always ：始终重启\nhttps://www.cnblogs.com/ageovb/p/15328796.html\n\n解释\n\n\n1、这里为啥只挂载了 data 目录–》因为当我们 没有直接的安装压缩包时，我们的就没有配置文件，所以我们直接生成，容器中就回自动生成 conf 文件，其中就有我们需要的 一系列配置文件，我们第一次创建的时候就可以如此，我们在进行配置文件的修改完成后，要将所有配置文件放到我们  bash 目录中的 conf 文件中去。\n\n\n2、第一次进入容器\n\n\n在 bash 目录下进入 bin 目录然后输入开启客户端命令\n  ./zkCli.sh\n\n\n\n\n3、第二次进入容器\n  docker exec -it zookeeper /bin/bash  -p    端口号\n或\ndocker exec -it zookeeper zkCli.sh\n\n\n只看到这就可，容器创建成功就可以直接用了，还没有出现问题。有待补充 *\n# 2.3   修改配置文件\n\n配置文件来源\n\n1、可以去我们的资料中直接解压出 conf 目录粘贴到我们的 zookeeper 目录中去\n2、可以直接进行第 3 步，完事之后直接会在容器中生成。找到 conf 文件，修改其中的 zoo.cfg 文件，\n\n\n\n进入容器后，找到 conf 中的 **zoo.cfg 文件，接下来就是修改 dataDir 路径为容器中的 data 文件目录。\n前提是要下载 vim ，因为容器中没有，命令是：\napt-get update\n\napt-get install -y vim\n\ncd conf\n# 没有zoo.cfg 就先拷贝 zoo_sample.cfg 两个其实是一个文件，内容相同\n#cp zoo_sample.cfg zoo.cfg\nvim zoo.cfg\n修改 dataDir 为 data 文件夹路径\ndataDir=/usr/local/zookeeper/data\n# 注：docker 集群搭建在 solr 笔记中\n# 七、Zookeeper 客户端常用命令\n​\t进入到./zkCli.sh 命令行工具后，可以使用下面常用命令\n# 1    ls\n​\tls [-s][-R] /path\n​\t-s 详细信息，替代老版的 ls2\n​\t-R 当前目录和子目录中内容都罗列出来\n​\t例如：ls -R / 显示根目录下所有内容\n# 2     create\n​\tcreate /path [data]\n​\t[data] 包含内容\n​\t创建指定路径信息\n​\t例如：create /demo 创建 /demo\n# 3     get\n​\tget [-s] /path\n​\t[-s] 详细信息\n​\t查看指定路径下内容。\n​\t例如： get -s /demo\n\n​\tnull: 存放的数据\n​\tcZxid: 创建时 zxid (znode 每次改变时递增的事务 id)\n​\tctime: 创建时间戳\n​\tmZxid: 最近一次更新的 zxid\n​\tmtime: 最近一次更新的时间戳\n​\tpZxid: 子节点的 zxid\n​\tcversion: 子节点更新次数\n​\tdataversion: 节点数据更新次数\n​\taclVersion: 节点 ACL (授权信息) 的更新次数\n​\tephemeralOwner: 如果该节点为 ephemeral 节点 (临时，生命周期与 session 一样), ephemeralOwner 值表示与该节点绑定的 session id. 如果该节点不是 ephemeral 节点，ephemeralOwner 值为 0.\n​\tdataLength: 节点数据字节数\n​\tnumChildren: 子节点数量\n# 4     set\n​\tset /path data\n​\t设置节点内容\n# 5     delete\n​\tdelete /path\n​\t删除节点\n# 八、向 Zookeeper 中注册内容\n​\t新建项目 ZookeeperClient\n# 1     创建 /demo\n​\t使用 zookeeper 的客户端命令工具创建 /demo\n./zkCli.sh\ncreate /demos\n# 2     添加依赖\n&lt;dependency>\n    &lt;groupId>org.apache.zookeeper&lt;/groupId>\n    &lt;artifactId>zookeeper&lt;/artifactId>\n    &lt;version>3.5.5&lt;/version>\n&lt;/dependency>\n\n# 3     编写代码\n​\t创建类 com.msb.MyApp。\n​\tZooDefs.Ids.OPEN_ACL_UNSAFE 表示权限。\n​\tCreateMode.PERSISTENT_SEQUENTIAL 永久存储，文件内容编号递增。\npublic class SendContent &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            /**\n             * 创建ZooKeeper对象\n             * param1: zookeeper_IP+端口号\n             * param2: 访问超时设置---时间设置长一点\n             * param3: 通过观察者模式发出访问回复，当连接成功后，编写成功信息\n             */\n            ZooKeeper zooKeeper = new ZooKeeper(\n                    \"192.168.88.128:2181\",\n                    1000000,\n                    new Watcher() &#123;\n                        @Override\n                        public void process(WatchedEvent watchedEvent) &#123;\n                            System.out.println(\"获取链接\");\n                        &#125;\n                    &#125;\n            );\n\n            /**\n             * 发送内容  向zookeeper服务器中\n             * param1: 发送的文件\n             * param2: 发送的内容(要转变成Bytes[])\n             * param3: 权限\n             * param4: 内容的模式\n             */\n            String result = zooKeeper.create(\n                    \"/demos/rmi_address\",\n                    \"rmi:localhost:8080/demoService\".getBytes(),\n                    ZooDefs.Ids.OPEN_ACL_UNSAFE,\n                    CreateMode.PERSISTENT_SEQUENTIAL\n            );\n\n            System.out.println(\"result  -> \"+result);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; catch (KeeperException e) &#123;\n            e.printStackTrace();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n    &#125;\n&#125;\n\n# 4     查看上传数据\n​\tls -R /            : 查看列表\n​\tget  /demo/nn0000000002     : 查看内容\n# 九、    从 zookeeper 中发现内容\n​\t在原有项目中新建一个类，类中编写主方法。\npublic static void main(String[] args) &#123;\n    try &#123;\n        ZooKeeper zookeeper = new ZooKeeper(\"192.168.32.128:2181\", 10000, new Watcher() &#123;\n            @Override\n            public void process(WatchedEvent watchedEvent) &#123;\n                System.out.println(\"获取连接\");\n            &#125;\n        &#125;);\n        //获取列表\n        List&lt;String> list = zookeeper.getChildren(\"/demo\", false);\n        for (String child : list) &#123;\n            byte[] result = zookeeper.getData(\"/demo/\" + child, false, null);\n            System.out.println(new String(result));\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; catch (KeeperException e) &#123;\n        e.printStackTrace();\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n# 十、手写 RPC 框架\n​\t使用 Zookeeper 作为注册中心，RMI 作为连接技术，手写 RPC 框架。\n# 1     创建项目 ParentDemo\n​\t创建父项目 ParentDemo。\n​\t包含 3 个聚合子项目。\n​\tpojo: service 中需要的实体类\n​\tservice：包含被 serviceimpl 和 consumer 依赖的接口。\n​\tserviceimpl:provider 提供的服务内容\n​\tconsumer：消费者，调用服务内容。\n# 2     在父项目中添加依赖\npublic static void main(String[] args) &#123;\n    try &#123;\n        ZooKeeper zookeeper = new ZooKeeper(\"192.168.32.128:2181\", 10000, new Watcher() &#123;\n            @Override\n            public void process(WatchedEvent watchedEvent) &#123;\n                System.out.println(\"获取连接\");\n            &#125;\n        &#125;);\n        //获取列表\n        List&lt;String> list = zookeeper.getChildren(\"/demo\", false);\n        for (String child : list) &#123;\n            byte[] result = zookeeper.getData(\"/demo/\" + child, false, null);\n            System.out.println(new String(result));\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; catch (KeeperException e) &#123;\n        e.printStackTrace();\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n# 3     创建 service 项目\n# 4     创建 DemoService 接口\n​\t创建 com.msb.DemoService\npublic interface DemoService extends Remote &#123;\n    String demo(String param) throws RemoteException;\n&#125;\n# 5     创建 serviceimpl 项目\n​\t此项目编写接口具体实现，RMI 服务发布和把信息发送到 Zookeeper 中。\n​\t项目结构如下：\n​\t在 pom.xml 中添加对 service 项目的依赖\n&lt;dependencies>\n    &lt;dependency>\n        &lt;artifactId>service&lt;/artifactId>\n        &lt;groupId>com.msb&lt;/groupId>\n        &lt;version>1.0.0&lt;/version>\n    &lt;/dependency>\n&lt;/dependencies>\n# 6     创建 DemoServiceImpl\n​\t创建 com.bjsxt.service.impl.DemoServiceImpl\npublic class DemoServiceImpl extends UnicastRemoteObject implements DemoService &#123;\n    public DemoServiceImpl() throws RemoteException &#123;\n    &#125;\n\n    @Override\n    public String demo(String param) throws RemoteException&#123;\n        return param+\"123\";\n    &#125;\n&#125;\n# 7     创建 RmiRun\n​\t创建 com.msb.RmiRun。实现 RMI 服务的发布和 Zookeeper 消息的发布。\npublic class RmiRun &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            DemoService demoService = new DemoServiceImpl();\n            LocateRegistry.createRegistry(8888);\n            String url = \"rmi://localhost:8888/demoService\";\n            Naming.bind(url,demoService);\n            ZooKeeper zookeeper = new ZooKeeper(\"192.168.32.128:2181\", 10000, new Watcher() &#123;\n                @Override\n                public void process(WatchedEvent watchedEvent) &#123;\n                    System.out.println(\"获取连接\");\n                &#125;\n            &#125;);\n            String content = zookeeper.create(\"/demo/demoService\",url.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            System.out.println(\"服务发布成功。。。。\");\n        &#125; catch (AlreadyBoundException e) &#123;\n            e.printStackTrace();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; catch (KeeperException e) &#123;\n            e.printStackTrace();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n# 8     创建 Consumer 项目\n​\t新建 consumer 项目，此项目需要从 zookeeper 中获取 rmi 信息，并调用 rmi 服务\n​\t在 pom.xml 中添加对 service 项目的依赖\n&lt;dependencies>\n    &lt;dependency>\n        &lt;artifactId>service&lt;/artifactId>\n        &lt;groupId>com.msb&lt;/groupId>\n        &lt;version>1.0.0&lt;/version>\n    &lt;/dependency>\n&lt;/dependencies>\n# 9     创建接口和实现类\n​\t创建 com.msb.service.ConsumerService 接口\n​\t创建 com.msb.service.impl.ConsumerServiceImpl 实现类\npublic interface ConsumerService &#123;\n    String consumerService(String param);\n&#125;\n@Service\npublic class ConsumerServiceImpl implements ConsumerService &#123;\n    @Override\n    public String consumerService(String param) &#123;\n        try &#123;\n            ZooKeeper zookeeper = new ZooKeeper(\"192.168.32.128:2181\", 10000, new Watcher() &#123;\n                @Override\n                public void process(WatchedEvent watchedEvent) &#123;\n                    System.out.println(\"获取连接\");\n                &#125;\n            &#125;);\n            byte[] urlByte = zookeeper.getData(\"/demo/demoService\", false, null);\n            DemoService demoService =(DemoService) Naming.lookup(new String(urlByte));\n            String result = demoService.demo(param);\n            System.out.println(result);\n            return result;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; catch (KeeperException e) &#123;\n            e.printStackTrace();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; catch (NotBoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return null;\n    &#125;\n&#125;\n# 10  创建控制器\n​\t创建 com.msb.controller.DemoController 控制器\n@Controller\npublic class DemoController &#123;\n\n    @Autowired\n    private ConsumerService consumerService;\n\n    @RequestMapping(\"/demo\")\n    @ResponseBody\n    public String demo(String param)&#123;\n        return consumerService.consumerService(param);\n    &#125;\n&#125;\n# 11  创建启动器\n​\t创建 com.msb.ConsumerApplication\n@SpringBootApplication\npublic class ConsumerApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(ConsumerApplication.class,args);\n    &#125;\n&#125;\n# 12  测试\n​\t在浏览器输入：http://localhost:8080/demo?param=demo\n​\t观察结果是否是：demo123\n","slug":"RPC","date":"2022-10-06T16:00:00.000Z","categories_index":"分布式,RPC","tags_index":"分布式,RPC","author_index":"雾都"},{"id":"b6845422ba4775a7cab0c414606e3ecd","title":"Redis基础","content":"# Redis\n# 一.Redis 简介\n# 1.NoSQL 简介\n​\t目前市场主流数据存储都是使用关系型数据库。每次操作关系型数据库时都是 I/O 操作，I/O 操作是主要影响程序执行性能原因之一，连接数据库关闭数据库都是消耗性能的过程。尽量减少对数据库的操作，能够明显的提升程序运行效率。\n​\t针对上面的问题，市场上就出现了各种 NoSQL (Not Only SQL, 不仅仅可以使用关系型数据库) 数据库，它们的宣传口号：不是什么样的场景都必须使用关系型数据库，一些特定的场景使用 NoSQL 数据库更好。\n常见 NoSQL 数据库：\n​\tmemcached ：键值对，内存型数据库，所有数据都在内存中。\n​\tRedis: 和 Memcached 类似，还具备持久化能力。\n​\tHBase：以列作为存储。\n​\tMongoDB：以 Document 做存储。\n# 2.Redis 简介\n​\tRedis 是以 Key-Value 形式进行存储的 NoSQL 数据库。\n​\tRedis 是使用 C 语言进行编写的。\n​\t平时操作的数据都在内存中，效率特高，读的效率 110000/s，写 81000/s，所以多把 Redis 当做缓存工具使用。\n​\tRedis 以 solt（槽）作为数据存储单元，每个槽中可以存储 N 多个键值对。Redis 中固定具有 16384。理论上可以实现一个槽是一个 Redis。每个向 Redis 存储数据的 key 都会进行 crc16 算法得出一个值后对 16384 取余就是这个 key 存放的 solt 位置。\n​\t同时通过 Redis Sentinel 提供高可用，通过 Redis Cluster 提供自动分区。\n# 二. Redis 单机版安装\n​\t1. 安装依赖 C 语言依赖\n​\tredis 使用 C 语言编写，所以需要安装 C 语言库\n# yum install -y gcc-c++ automake autoconf libtool make tcl \n​\n​\t2. 上传并解压\n​\t把 redis-5.0.5.tar.gz 上传到 /usr/local/tmp 中\n​\t解压文件\n# cd &#x2F;usr&#x2F;local&#x2F;tmp\n\n# tar zxf redis-5.0.5.tar.gz\n​\t3. 编译并安装\n​\t进入解压文件夹\n# cd &#x2F;usr&#x2F;local&#x2F;tmp&#x2F;redis-5.0.5&#x2F;\n​\t编译\n# make\n​\t安装\n# make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis\n​\t4. 开启守护进程\n​\t复制 cd /usr/local/tmp/redis-5.0.5 / 中 redis.conf 配置文件\n# cp redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;\n​\t修改配置文件\n# cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;\n\n# vim redis.conf\n​\t把 daemonize 的值由 no 修改为 yes\n\n​\t5. 修改外部访问\n​\t在 redis5 中需要修改配置文件 redis.conf 允许外部访问。需要修改两处。\n​\t注释掉下面\n​\tbind 127.0.0.1\n#bind 127.0.0.1\n​\tprotected-mode yes 改成 no\n\n​\t6. 启动并测试\n​\t启动 redis\n ./redis-server redis.conf\n​\t重启 redis\n.&#x2F;redis-cli shutdown\n.&#x2F;redis-server redis.conf\n​\t启动客户端工具\n​\t在 redis5 中客户端工具对命令会有提供功能。\n ./redis-cli \n# 二.、docker 安装 Redis\n1、拉取镜像文件\ndocker pull redis[:(版本号)]\n2、去 gitee 库中下载 redis 配置文件（docker 不自带配置文件）【也可不进行此步骤】\n建议看完，先别操作，再看三，看完三之后再决定如何操作\n然后按照文章内容进行，忽略下载。\n文章地址： https://www.jb51.net/article/203274.htm\n、\n\n3、创建一个 redis 服务容器\n第二步进行了的\ndocker run -p 6379:6379 --name myredis -v /usr/local/docker/redis.conf:/etc/redis/redis.conf -v /usr/local/docker/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes\n\n第二步没有进行的\ndocker run -p 6379:6379 --name myredis -v /root/myredis/data:/data -v /root/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis redis-server /usr/local/etc/redis/redis.conf --appendonly yes\n\n区别：\n​\t其实也没有什么区别，只是映射的文件不同，也可以将第二步的文件直接创建到第二种创建服务容器的配置文件地址中去，这样也可使用第二个创建方式。\n\n\n# 三.Redis 常用的五大类型\n​\t Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储，它还支持数据的备份，即 master-slave 模式的数据备份，同样 Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。\n​        Redis 支持的五大数据类型包括 String（字符串  用法： 键  值），Hash（哈希 类似 Java 中的 map  用法： 键  键值对），List（列表  用法：键 集合 不可以重复），Set（集合 用法：键 集合 可以重复），Zset（sorted set 有序集合    用法： 键  值 值）\n# String（字符串）\n​\tstring 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。\n应用场景：\n​\tString 是最常用的一种数据类型，普通的 key/value 存储都可以归为此类，value 其实不仅是 String，\n也可以是数字：比如想知道什么时候封锁一个 IP 地址 (访问超过几次)。\n# Hash（哈希）\n​\tRedis hash 是一个键值 (key=&gt;value) 对集合。\n​\tRedis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。\n​\t使用场景：存储、读取、修改用户属性\n​\t我们简单举个实例来描述下 Hash 的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：    用户 ID，为查找的 key，\n​    \t存储的 value 用户对象包含姓名 name，年龄 age，生日 birthday 等信息，  如果用普通的 key/value 结构来存储，主要有以下 2 种存储方式：\n​    \t第一种方式将用户 ID 作为查找 key, 把其他信息封装成一个对象以序列化的方式存储，\n​           如：set u001 “李三，18,20010101”\n​     \t这种方式的缺点是，增加了序列化 / 反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入 CAS 等复杂问题。\n​     \t第二种方法是这个用户信息对象有多少成员就存成多少个 key-value 对儿，用用户 ID + 对应属性的名称作为唯一标识来取得对应属性的值，\n​       \t如：mset user:001:name &quot;李三&quot;user:001:age18 user:001:birthday “20010101” 虽然省去了序列化开销和并发问题，但是用户 ID 为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。\n​    \t那么 Redis 提供的 Hash 很好的解决了这个问题。\n# List（列表）\n​\tRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n应用场景：\n Redis list的应用场景非常多，也是Redis最重要的数据结构之一。  \n\n​    \t我们可以轻松地实现最新消息排行等功能。\n Lists的另一个应用就是消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。  \n\n# Set（集合）\n​\tRedis 的 Set 是 string 类型的无序集合。\n​\t使用场景：1. 共同好友、二度好友\n​\t\t\t   2. 利用唯一性，可以统计访问网站的所有独立 IP\n Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。  \n\n 比如在微博应用中，每个人的好友存在一个集合（set）中，这样求两个人的共同好友的操作，可能就只需要用求交集命令即可。  \n\n​    \tRedis 还为集合提供了求交集、并集、差集等操作，可以非常方便的实\n实现方式：  \n\n​    \tset 的内部实现是一个 value 永远为 null 的 HashMap，实际就是通过计算 hash 的方式来快速排重的，这也是 set 能提供判断一个成员是否在集合内的原因。\n# zset (sorted set：有序集合)\nRedis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。\n\n使用场景：1. 带有权重的元素，比如一个游戏的用户得分排行榜\n​\t\t   2. 比较复杂的数据结构，一般用到的场景不算太多\n# 四. Redis 常用命令\nRedis 命令相关手册有很多，下面为其中比较好用的两个\n1.https://www.redis.net.cn/order/\n2.http://doc.redisfans.com/text-in\n# 1. Key 操作\n# 1.1  exists\n​\t判断 key 是否存在。\n​\t语法：exists key 名称\n​\t返回值：存在返回数字，不存在返回 0\n# 1.2 expire\n​\t设置 key 的过期时间，单位秒\n​\t语法：expire key 秒数\n​\t返回值：成功返回 1，失败返回 0\n# 1.3 ttl\n​\t查看 key 的剩余过期时间\n​\t语法：ttl key\n​\t返回值：返回剩余时间，如果不过期返回 - 1\n# 1.4 del\n​\t根据 key 删除键值对。\n​\t语法：del key\n​\t返回值：被删除 key 的数量\n# 2. 字符串值 (String)\n# 2.1 set\n​\t设置指定 key 的值\n​\t语法：set key value\n​\t返回值：成功 OK\n# 2.2 get\n​\t获取指定 key 的值\n​\t语法：get key\n​\t返回值：key 的值。不存在返回 nil\n# 2.3 setnx\n​\t当且仅当 key 不存在时才新增。\n​\t语法：setnx key value\n​\t返回值：不存在时返回 1，存在返回 0\n# 2.4 setex\n​\t设置 key 的存活时间，无论是否存在指定 key 都能新增，如果存在 key 覆盖旧值。同时必须指定过期时间。\n​\t语法：setex key seconds value\n​\t返回值：OK\n# 3. 哈希表 (Hash)\n​\tHash 类型的值中包含多组 field value。\n\n# 3.1 hset\n​\t给 key 中 field 设置值。\n​\t语法：hset key field value\n​\t返回值：成功 1，失败 0\n# 3.2 hget\n​\t获取 key 中某个 field 的值\n​\t语法：hget key field\n​\t返回值：返回 field 的内容\n# 3.3 hmset\n​\t给 key 中多个 filed 设置值\n​\t语法：hmset key field value field value\n​\t返回值：成功 OK\n# 3.4 hmget\n​\t一次获取 key 中多个 field 的值\n​\t语法：hmget key field field\n​\t返回值：value 列表\n# 3.5 hvals\n​\t获取 key 中所有 field 的值\n​\t语法：hvals key\n​\t返回值：value 列表\n# 3.6 hgetall\n​\t获取所有 field 和 value\n​\t语法：hgetall key\n​\t返回值：field 和 value 交替显示列表\n# 3.7 hdel\n​\t删除 key 中任意个 field\n​\t语法：hdel key field field\n​\t返回值：成功删除 field 的数量\n# 4. 列表（List）\n# 4.1 Rpush\n​\t向列表末尾中插入一个或多个值\n​\t语法；rpush key value value\n​\t返回值：列表长度\n# 4.2 lrange\n​\t返回列表中指定区间内的值。可以使用 - 1 代表列表末尾\n​\t语法：lrange list 0 -1\n​\t返回值：查询到的值\n# 4.3 lpush\n​\t将一个或多个值插入到列表前面\n​\t语法：lpush key value value\n​\t返回值：列表长度\n# 4.4 llen\n​\t获取列表长度\n​\t语法：llen key\n​\t返回值：列表长度\n# 4.5 lrem\n​\t删除列表中元素。count 为正数表示从左往右删除的数量。负数从右往左删除的数量。\n​\t语法：lrem key count value\n​\t返回值：删除数量。\n# 5 集合 (Set)\n​\tset 和 java 中集合一样。\n# 5.1 sadd\n​\t向集合中添加内容。不允许重复。\n​\t语法：sadd key value value value\n​\t返回值：集合长度\n# 5.2 scard\n​\t返回集合元素数量\n​\t语法：scard key\n​\t返回值：集合长度\n# 5.3 **smembers **\n​\t查看集合中元素内容\n​\t语法：smembers key\n​\t返回值：集合中元素\n# 6 . 有序集合（Sorted Set）\n​\t有序集合中每个 value 都有一个分数（score），根据分数进行排序。\n# 6.1 zadd\n​\t向有序集合中添加数据\n​\t语法：zadd key score value score value\n​\t返回值：长度\n\n# 6.2 zrange\n​\t返回区间内容想・，withscores 表示带有分数\n​\t语法：zrange key 区间 [withscores]\n​\t返回值：值列表\n\n\n# 五、 Redis 持久化策略\n​\tRedis 不仅仅是一个内存型数据库，还具备持久化能力。\n# 1. RDB\n​\trdb 模式是默认模式，可以在指定的时间间隔内生成数据快照（snapshot），默认保存到 dump.rdb 文件中。当 redis 重启后会自动加载 dump.rdb 文件中内容到内存中。\n​\t用户可以使用 SAVE（同步）或 BGSAVE（异步）手动保存数据。\n​\t可以设置服务器配置的 save 选项，让服务器每隔一段时间自动执行一次 BGSAVE 命令，可以通过 save 选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行 BGSAVE 命令。\n　　\t例如：\n　　\tsave 900 1\n　　\tsave 300 10\n　　\tsave 60 10000\n　　那么只要满足以下三个条件中的任意一个，BGSAVE 命令就会被执行\n　　服务器在 900 秒之内，对数据库进行了至少 1 次修改\n　　服务器在 300 秒之内，对数据库进行了至少 10 次修改\n　　服务器在 60 秒之内，对数据库进行了至少 10000 次修改\n# 1.1 优点\n​\trdb 文件是一个紧凑文件，直接使用 rdb 文件就可以还原数据。\n​\t数据保存会由一个子进程进行保存，不影响父进程。\n​\t恢复数据的效率要高于 aof\n# 1.2 缺点\n​\t每次保存点之间导致 redis 不可意料的关闭，可能会丢失数据。\n​\t由于每次保存数据都需要 fork () 子进程，在数据量比较大时可能会比较耗费性能。\n# 2 AOF\n​\tAOF 默认是关闭的，需要在配置文件中开启 AOF。Redis 支持 AOF 和 RDB 同时生效，如果同时存在，AOF 优先级高于 RDB（Redis 重新启动时会使用 AOF 进行数据恢复）\n​\t监听执行的命令，如果发现执行了修改数据的操作，同时直接同步到数据库文件中。\n# 2.1 优点\n​\t相对 RDB 数据更加安全。\n# 2.2 缺点\n​\t相同数据集 AOF 要大于 RDB。\n​\t相对 RDB 可能会慢一些。\n# 2.3 开启办法\n​\t修改 redis.conf 中\n# 默认no\nappendonly yes\n# aof文件名\nappendfilename &quot;appendonly.aof&quot;\n# 六. Redis 主从复制\n​\tRedis 支持集群功能。为了保证单一节点可用性，redis 支持主从复制功能。每个节点有 N 个复制品（replica），其中一个复制品是主（master），另外 N-1 个复制品是从（Slave），也就是说 Redis 支持一主多从。\n​\t一个主可有多个从，而一个从又可以看成主，它还可以有多个从。\n\n# 1. 主从优点\n​\t增加单一节点的健壮性，从而提升整个集群的稳定性。（Redis 中当超过 1/2 节点不可用时，整个集群不可用）\n​\t从节点可以对主节点数据备份，提升容灾能力。\n​\t读写分离。在 redis 主从中，主节点一般用作写（具备读的能力），从节点只能读，利用这个特性实现读写分离，写用主，读用从。\n# 1.1 一主多从搭建\n​\t在已经搭建的单机版 redis 基础上进行操作。\n​\t并且关闭 redis 单机版\n.&#x2F;redis-cli shutdown\n# 1.2 新建目录\n# mkdir &#x2F;usr&#x2F;local&#x2F;replica\n# 1.3 复制目录\n​\t把之前安装的 redis 单机版中 bin 目录复制三份，分别叫做：master、slave1、slave2\n# cp -r &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin &#x2F;usr&#x2F;local&#x2F;replica&#x2F;master\n# cp -r &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin &#x2F;usr&#x2F;local&#x2F;replica&#x2F;slave1\n# cp -r &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin &#x2F;usr&#x2F;local&#x2F;replica&#x2F;slave2\n# 1.4 修改从的配置文件\n​\t修改 2 个从的 redis.conf，指定主节点 ip 和端口。并修改自身端口号防止和其他 redis 冲突。\n# vim &#x2F;usr&#x2F;local&#x2F;replica&#x2F;slave1&#x2F;redis.conf\n​\t指定主节点 ip 和端口\nreplicaof 192.168.93.10 6379\n​\t修改自己端口\nport 6380\n# vim &#x2F;usr&#x2F;local&#x2F;replica&#x2F;slave2&#x2F;redis.conf\n​\t指定主节点 ip 和端口\nreplicaof 192.168.93.10 6379\n​\t修改自己端口\nport 6381\n# 1.5 启动三个 redis 实例\n​\t注意：一定要关闭单机的 redis，否则端口冲突。\n# cd &#x2F;usr&#x2F;local&#x2F;replica\n# vim startup.sh\n​\t在文件中添加下面内容\ncd &#x2F;usr&#x2F;local&#x2F;replica&#x2F;master&#x2F;\n.&#x2F;redis-server redis.conf\n  cd &#x2F;usr&#x2F;local&#x2F;replica&#x2F;slave1\n.&#x2F;redis-server redis.conf\n  cd &#x2F;usr&#x2F;local&#x2F;replica&#x2F;slave2\n.&#x2F;redis-server redis.conf\n赋予权限\n\n# chmod a+x startup.sh\n​\t开启\n# .&#x2F;startup.sh\n# 1.6 查看启动状态\n# ps aux|grep redis\n\n# 1.7 测试 *\n# cd &#x2F;usr&#x2F;local&#x2F;replica&#x2F;master&#x2F;\n# .&#x2F;redis-cli \n\n​\t在客户端命令行模式下，添加一条数据：\n\n​\t进去 slave 查看数据是否同步。\n# cd &#x2F;usr&#x2F;local&#x2F;replica&#x2F;slave1\n# .&#x2F;redis-cli -p 6380\n\n# 2、docker 下操作\n​\t可以自定义 redis.conf 文件只写要修改的，不改的就别写，这里主要是要书写新的端口号以及父节点的 ip 和端口\n** 注意：** 所有修改必须在容器外，容器内修改无效，在退出重启的那一刻就已经还原了\n我们通常使用  CP 来修改\ndocker  cp  本机文件路径   容器id: 容器内文件路径\n#所有路径是所在文件夹路径，并不是文件的路径，简单来说就是写到文件夹所在路径即可，不需要指定特定文件\n# 1、修改端口号\n同上\n# 2、指定父节点\n同上\n# 3、重启\n（如果在启动前修改不需要，这里是指已经启动了的容器，在修改之后的操作）\ndocker restart 容器id\n# 4、测试并查看\n・同上\nrole\n\n或者\n\ninfo replication\n# 七.  哨兵（Sentinel）\n​\t在 redis 主从默认是只有主具备写的能力，而从只能读。如果主宕机，整个节点不具备写能力。但是如果这是让一个从变成主，整个节点就可以继续工作。即使之前的主恢复过来也当做这个节点的从即可。\n​\tRedis 的哨兵就是帮助监控整个节点的，当节点主宕机等情况下，帮助重新选取主。\n​\tRedis 中哨兵支持单哨兵和多哨兵。单哨兵是只要这个哨兵发现 master 宕机了，就直接选取另一个 master。而多哨兵是根据我们设定，达到一定数量哨兵认为 master 宕机后才会进行重新选取主。我们以多哨兵演示。\n# 1. 没有哨兵下主从效果\n​\t只要杀掉主，整个节点无法在写数据，从身份不会变化，主的信息还是以前的信息。\n\n# 2. 搭建多哨兵\n​\t前提：安装了单机的 redis\n# 2.1 新建目录\n# mkdir &#x2F;usr&#x2F;local&#x2F;sentinel\n# 2.2 复制 redis\n# cp -r &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;* &#x2F;usr&#x2F;local&#x2F;sentinel\n# 2.3 复制配置文件\n​\t从 redis 解压目录中复制 sentinel 配置文件\n# cd &#x2F;usr&#x2F;local&#x2F;tmp&#x2F;redis-5.0.5&#x2F;\n# cp sentinel.conf &#x2F;usr&#x2F;local&#x2F;sentinel&#x2F;\n# 2.4 修改配置文件\n# cd &#x2F;usr&#x2F;local&#x2F;sentinel\n# vim sentinel.conf\n\nport 26379\ndaemonize yes\n#这个提示里面的&#x2F;var&#x2F;log&#x2F;redis&#x2F;redis.log日志文件指的是容器中的文件，千万别理解为宿主机中的路径，如果你在宿主机创建此文件并授权，最后结果也是一样的，理解这一点很重要。\nlogfile “&#x2F;usr&#x2F;local&#x2F;sentinel&#x2F;26379.log”\n\nsentinel monitor mymaster 192.168.93.10 6379 2\n​\t复制 sentinel.conf，命名为 sentinel-26380.conf\n# cp sentinel.conf sentinel-26380.conf\n# vim sentinel-26380.conf\n\nport 26380\ndaemonize yes\nlogfile “&#x2F;usr&#x2F;local&#x2F;sentinel&#x2F;26380.log”\nsentinel monitor mymaster 192.168.93.10 6379 2\n复制 sentinel.conf，命名为 sentinel-26381.conf\n# cp sentinel.conf sentinel-26381.conf\n# vim sentinel-26381.conf\n\nport 26381\ndaemonize yes\nlogfile “&#x2F;usr&#x2F;local&#x2F;sentinel&#x2F;26381.log”\nsentinel monitor mymaster 192.168.93.10 6379 2\n# 2.5 启动主从\n​\t如果已经启动状态，忽略下面命令。如果启动部分，全部 kill 后重新启动。\n​\t使用 kill 杀死全部 redis\n# ps aux|grep redis\n# kill -9 进程号\n​\t启动 redis 主从\n# cd &#x2F;usr&#x2F;local&#x2F;replica\n# .&#x2F;startup.sh\n# 2.6 启动三个哨兵\n# cd &#x2F;usr&#x2F;local&#x2F;sentinel\n# .&#x2F;redis-sentinel sentinel.conf\n# .&#x2F;redis-sentinel sentinel-26380.conf\n# .&#x2F;redis-sentinel sentinel-26381.conf\n# 2.7 查看日志\n# cat 26379.log\n# 2.8 测试宕机\n​\t查看 redis 进程号\n# ps aux|grep redis\n​\t杀死主进程号\n# kill -9 进程号\n​\t查看日志，短暂延迟后会发现，出现新的主。\n# cat 26379.log\n# 八。集群 (Cluster)–nt have doc\n​\t前提：已经安装好 redis 单机版。\n​\t当集群中超过或等于 1/2 节点不可用时，整个集群不可用。为了搭建稳定集群，都采用奇数节点。\n# 1 . 复制 redis 配置文件\n​\t从 /usr/local/redis/bin 下把 redis.conf 复制到当前目录中，命名为 redis-7001.conf\n# cp &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-7001.conf\n# 2. 修改 redis-7001.conf\n# cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin\n# vim redis-7001.conf\n​\t需要修改如下\nport 7001\ncluster-enabled yes\ncluster-config-file nodes-7001.conf\ncluster-node-timeout 15000\n# appendonly yes 如果开启aof默认，需要修改为yes。如果使用rdb，此处不需要修改\ndaemonize yes\nprotected-mode no\npidfile &#x2F;var&#x2F;run&#x2F;redis_7001.pid\n# \n# 3 . 复制配置文件，并修改内容\n​\t把 redis-7001.conf 复制 5 份，分别叫做 redis-7002.conf、redis-7003.conf、redis-7004.conf、redis-7005.conf、redis-7006.conf\n# cp redis-7001.conf redis-7002.conf\n# cp redis-7001.conf redis-7003.conf\n# cp redis-7001.conf redis-7004.conf\n# cp redis-7001.conf redis-7005.conf\n# cp redis-7001.conf redis-7006.conf\n新复制的5个配置文件都需要需改三处。\n\n​\t例如 nodes-7002.conf 中需要把所有 7001 都换成 7002。\n​\t可以使用 :% s/7001/7002/g 进行全局修改。\nport 7002\ncluster-config-file nodes-7002.conf\npidfile &#x2F;var&#x2F;run&#x2F;redis_7002.pid\n# 4 . 启动 6 个 redis\n​\t可以使用 redis-server 结合 6 个配置文件进行启动 6 个实例。\n​\t执行之前一定要先删除 dump.rdb\n# rm -f dump.rdb\n# vim startup.sh\n\n.&#x2F;redis-server redis-7001.conf\n.&#x2F;redis-server redis-7002.conf\n.&#x2F;redis-server redis-7003.conf\n.&#x2F;redis-server redis-7004.conf\n.&#x2F;redis-server redis-7005.conf\n.&#x2F;redis-server redis-7006.conf\n\n\n# chmod a+x startup.sh\n# .&#x2F;startup.sh\n# 5. 查看启动状态\n\n# 6. 建立集群\n​\t在 redis3 的时候需要借助 ruby 脚本实现集群。在 redis5 中可以使用自带的 redis-cli 实现集群功能，比 redis3 的时候更加方便了。\n​\t建议配置静态 ip，ip 改变集群失效\n.&#x2F;redis-cli --cluster create 192.168.93.10:7001 192.168.93.10:7002 192.168.93.10:7003 192.168.93.10:7004 192.168.93.10:7005 192.168.93.10:7006 --cluster-replicas 1\n# 7. 测试\n​\t集群测试时，千万不要忘记最后一个 - c 参数。\n# .&#x2F;redis-cli -p 7001 -c\n# set age 18\n# 8 . 编写关闭脚本\n# vim stop.sh\n# chmod a+x stop.sh\n\n.&#x2F;redis-cli -p 7001 shutdown\n.&#x2F;redis-cli -p 7002 shutdown\n.&#x2F;redis-cli -p 7003 shutdown\n.&#x2F;redis-cli -p 7004 shutdown\n.&#x2F;redis-cli -p 7005 shutdown\n.&#x2F;redis-cli -p 7006 shutdown\n# 八。集群 (Cluster)-PATH:docker\n​\t注：1. 如果是配置修改之前已经创建过的集群时，要先进行第七步操作。\n​\t\t\t2. 要是想重启集群可以省略第一步，但是得先删除已经创建的容器，重新进行 2、3（合并也行）\n# 0、创建网络\n** 目的：** 让宿主机可以访问到自身\ndocker network create net-redis --subnet 172.38.0.0/16\n补充：关于虚拟机的三种网路连接方式区别\nhttp://blog.csdn.net/bifengmiaozhuan/article/details/79887692?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2defaultCTRLISTRate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2defaultCTRLISTRate-1.pc_relevant_default&amp;utm_relevant_index=1\n\n# 1、创建并修改配置文件\n注：\nIn certain deployments, Redis Cluster nodes address discovery fails, because addresses are NAT-ted or because ports are forwarded (the typical case is Docker and other containers).\n\n在某些部署中，Redis群集节点地址发现失败，因为地址是NAT，或者端口是转发的（典型情况是Docker和其他容器）。\n\nIn order to make Redis Cluster working in such environments, a static configuration where each node knows its public address is needed. The following two options are used for this scope, and are:\n\n为了让Redis集群在这样的环境中工作，需要一种静态配置，其中每个节点都知道自己的公共地址。以下两个选项用于此范围，分别是：\n\ncluster-announce-ip\n\ncluster-announce-port\n---------------------------------------------------------------------------------------\n你的docker内网是172，你宿主的IP是192网段\n\n根据redis的配置文件中的解释\n\n要在你的配置文件上加上上面的2个配置\n** 方法一：** 参考上面的方法一样行。\n** 方法二：** 使用脚本\n#cat &lt;&lt;EOF EOF在这里没有特殊的含义，你可以使用FOE或000等;\n#表示以cat &lt;&lt;EOF 开始输入以 EOF 结束结束输入\n#cat>创建文件，并把标准输入输出到后面的filename文件\n\n\n# * cluster-announce-ip\t\t\t\t\t192.168.1.195\t#*群集ip\n# * cluster-announce-port\t\t\t\t700$&#123;port&#125;\t\t#*群集总线端口\n# * cluster-announce-bus-port#*群集ip    1700$&#123;port&#125;\t   #*群集公布端口\n# 集群 ip 是固定+10000\n\n# 可以使用 :  %s/7001/7002/g     进行全局修改。 ---将全局的7001修改成7002\n\nfor port in $(seq 1 6); \\ \ndo \\\nmkdir  -p  /root/myredis/conf700$&#123;port&#125;\ntouch  /root/myredis/conf700$&#123;port&#125;/redis.conf\ncat &lt;&lt;TTT > /root/myredis/conf700$&#123;port&#125;/redis.conf port 6379\nbind 0.0.0.0\nport 700$&#123;port&#125;\ncluster-enabled yes\ncluster-config-file nodes-700$&#123;port&#125;.conf\ncluster-node-timeout 15000\nprotected-mode no\npidfile /var/run/redis_ 700$&#123;port&#125;.pid\ncluster-announce-ip  192.168.1.195 \ncluster-announce-port  700$&#123;port) \ncluster-announce-bus-port 1700$&#123;port) \nappendonly yes \nTTT \ndone\n# 2、创建容器\n** 方法一：** 手动创建容器，并启动\ndocker run -p 7001:7001   -p 17001:17001  --name redis7001  -v /root/myredis/conf7001/redis.conf:/etc/redis/redis.conf -v /root/myredis/data7001:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes\n​\t7002 ~~~7006 同上，自行修改参数\n** 方法二：** 脚本一键启动，效果同上\n​\t注意：\n\n其中要指定两个端口号 **-p 1700port:1700{port}:1700port:1700 {port}** 不要忘记，否则会在创建几群的时候出现  **Waiting for the cluster to join   ** 。【具体原因，我还没查出来，后面补充】\n在 docker 创建集群容器的时候，一定要 指定  ip\n\n补充：\n\n那肯定是你端口没有开启，不要质疑，这里的端口不是 7000-7005，而是 17000-17005，因为 redis 设置集群的端口号是”redis 端口 + 10000“，这个非常重要。并且 7001:7006 也是必须打开的。\n\nfor port in $(seq 1 6);  \\\ndo \\\ndocker run -p 700$&#123;port&#125;:700$&#123;port&#125;   -p 1700$&#123;port&#125;:1700$&#123;port&#125;  --name redis700$&#123;port&#125;  \\\n-v /root/redis/redis700$&#123;port&#125;.conf:/etc/redis/redis.conf \\\n-v /root/redis/data700$&#123;port&#125;:/data \\\n-d --ip 192.168.1.195 redis redis-server /etc/redis/redis.conf \ndone\n# 3、进入容器\ndocker exec -it redis7001 /bin/bash\n# 4、创建集群\n​\t** 注：** 有一步操作，要自行进行确认，一定要输入 yes 而不是 y 或者其他之类的，除了 yes 一律视为 no 。\nredis-cli --cluster create 192.168.1.195:7001 192.168.1.195:7002 192.168.1.195:7003 192.168.1.195:7004 192.168.1.195:7005 192.168.1.195:7006 --cluster-replicas 1\n# 5、测试\n​\t集群测试时，千万不要忘记最后一个 - c 参数。\nredis-cli -p 7001 -c\n# 6、关闭集群\n方法一：\n​\t自行手动一个一个停止，并且删除容器\ndocker stop redis7001 #7002 ~~~7006\n\ndocker rm -f redis7001\n方法二：\n​\t脚本程序，一劳永逸\nfor port in $(seq 1 6);  \\\ndo \\\ndocker stop redis700$&#123;port&#125;\ndocker rm -f redis700$&#123;port&#125;\ndone\n# 7、清空集群文件\nfor port in $(seq 1 6);  \\\ndo \\\nrm  -rf  ./data700$&#123;port&#125;/* \ndone\n# 九. Jedis\n​\tRedis 给 Java 语言提供了客户端 API，称之为 Jedis。\n​\tJedis API 和 Redis 命令几乎是一样的。\n​\t例如：Redis 对 String 值新增时 set 命令，Jedis 中也是 set 方法。所以本课程中没有重点把所有方法进行演示，重要演示 Jedis 如何使用。\n​\tJedis API 特别简单，基本上都是创建对象调用方法即可。\n# 1. 单机版\npublic void testStandalone()&#123;\n    Jedis jedis &#x3D; new Jedis(&quot;192.168.93.10&quot;,6379);\n    jedis.set(&quot;name&quot;,&quot;msb-standalone&quot;);\n    String value &#x3D; jedis.get(&quot;name&quot;);\n    System.out.println(value);\n&#125;\n# 2. 带有连接池\npublic void testPool()&#123;\n    JedisPoolConfig jedisPoolConfig &#x3D; new JedisPoolConfig();\n    jedisPoolConfig.setMaxTotal(20);\n    jedisPoolConfig.setMaxIdle(5);\n    jedisPoolConfig.setMinIdle(3);\n    JedisPool jedisPool &#x3D; new JedisPool(jedisPoolConfig,&quot;192.168.93.10&quot;,6379);\n    Jedis jedis &#x3D; jedisPool.getResource();\n    jedis.set(&quot;name&quot;,&quot;msb-pool&quot;);\n    String value &#x3D; jedis.get(&quot;name&quot;);\n    System.out.println(value);\n&#125;\n# 3. 集群\npublic void testCluster()&#123;\n    Set&lt;HostAndPort&gt; set &#x3D; new HashSet&lt;&gt;();\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7001));\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7002));\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7003));\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7004));\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7005));\n    set.add(new HostAndPort(&quot;192.168.93.10&quot;,7006));\n    JedisCluster jedisCluster &#x3D; new JedisCluster(set);\n    jedisCluster.set(&quot;name&quot;,&quot;bjmsb&quot;);\n    String value &#x3D; jedisCluster.get(&quot;name&quot;);\n    System.out.println(value);\n&#125;\n# 十. 使用 SpringBoot 整合 SpringDataRedis 操作 redis\n​\tSpring Data 是 Spring 公司的顶级项目，里面包含了 N 多个二级子项目，这些子项目都是相对独立的项目。每个子项目是对不同 API 的封装。\n​\t所有 Spring Boot 整合 Spring Data xxxx 的启动器都叫做 spring-boot-starter-data-xxxx\n​\tSpring Data 好处很方便操作对象类型。\n​\t把 Redis 不同值得类型放到一个 opsForXXX 方法中。\n​\t\topsForValue : String 值\n​\t\topsForList : 列表 List\n​\t\topsForHash: 哈希表 Hash\n​\t\topsForZSet: 有序集合 Sorted Set\n​\t\topsForSet : 集合\n# 1. 添加依赖\n&lt;parent&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt;\n  &lt;&#x2F;parent&gt;\n\n  &lt;dependencies&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n          &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n      &lt;&#x2F;dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n          &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n          &lt;version&gt;2.2.5.RELEASE&lt;&#x2F;version&gt;\n      &lt;&#x2F;dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n          &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n          &lt;version&gt;2.1.1&lt;&#x2F;version&gt;\n      &lt;&#x2F;dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n          &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n          &lt;version&gt;5.1.47&lt;&#x2F;version&gt;\n      &lt;&#x2F;dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n          &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;\n          &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt;\n      &lt;&#x2F;dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n          &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n          &lt;version&gt;1.18.20&lt;&#x2F;version&gt;\n      &lt;&#x2F;dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;\n          &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;\n          &lt;version&gt;3.3.0&lt;&#x2F;version&gt;\n      &lt;&#x2F;dependency&gt;\n  &lt;&#x2F;dependencies&gt;\n# 2. 配置配置文件\n注：\n\n\nspring.redis.host=localhost 默认值\n\n\nspring.redis.port=6379 端口号默认值\n\n\nmybatis:\n  mapper-locations: classpath:mybatis&#x2F;*\n  type-aliases-package: com.msb.pojo\nspring:\n  datasource:\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mydb\n    username: root\n    password: root\n    driver-class-name: com.mysql.jdbc.Driver\n  redis:\n    host: 192.168.1.195\n    cluster:\n      nodes: 192.168.1.195:7001,192.168.1.195:7002,192.168.1.195:7003,192.168.1.195:7004,192.168.1.195:7005,192.168.1.195:7006\n# 3. 编写配置类（可直接复制）\n@Configuration\npublic class RedisConfig &#123;\n    @Bean\n    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory \t\t  factory)&#123;\n        RedisTemplate&lt;String,Object&gt; redisTemplate &#x3D; new RedisTemplate&lt;&gt;();\n        redisTemplate.setConnectionFactory(factory);\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\n        redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class));\n        return redisTemplate;\n    &#125;\n&#125;\n# 4. 编写代码\n# 4.1 编写对象新增\n@Autowired\nprivate RedisTemplate&lt;String, Object&gt; redisTemplate;\n\n@Test\npublic void testString() &#123;\n    People peo &#x3D; new People(1, &quot;张三&quot;);\n    redisTemplate.opsForValue().set(&quot;peo1&quot;, peo);\n&#125;\n# 4.2 编写对象获取\n此处必须编写值序列化器。不指定时返回类型为 LinkedHashMap\n@Test\npublic void testGetString() &#123;\n    redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;People&gt;(People.class));\n    People peo &#x3D; (People) redisTemplate.opsForValue().get(&quot;peo1&quot;);\n    System.out.println(peo);\n&#125;\n# 4.3 编写 List\n@Test\npublic void testList() &#123;\n    List&lt;People&gt; list &#x3D; new ArrayList&lt;&gt;();\n    list.add(new People(1, &quot;张三&quot;));\n    list.add(new People(2, &quot;李四&quot;));\n    redisTemplate.opsForValue().set(&quot;list2&quot;, list);\n&#125;\n# 4.4 编写 List 取值\n@Test\npublic void testGetList()&#123;\n    redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;List&gt;(List.class));\n    List&lt;People&gt; list2 &#x3D; (List&lt;People&gt;) redisTemplate.opsForValue().get(&quot;list2&quot;);\n    System.out.println(list2);\n&#125;\n# 十一. 使用 Redis 效果\n​\t使用缓存流程\n​\t1. 先判断缓存中是否存在。如果存在直接从缓存中取出数据。不执行 2，3 步骤\n​\t2. 如果不存在，从 mysql 中获取数据\n​\t3. 获取数据后，把数据缓存到 redis 中\n","slug":"Redis","date":"2022-10-06T16:00:00.000Z","categories_index":"数据库,Redis","tags_index":"分布式,中间件,Redis基础,NoSQL数据库","author_index":"雾都"},{"id":"8fb356cff06527682613922b65983bb1","title":"Solr","content":"# Solr\n# 主要内容\n\n\nSolr 简介\n\n\nSolr 搜索原理\n\n\nSolr 单机版安装\n\n\n可视化管理界面\n\n\n新建核心\n\n\n分词\n\n\nDataimport\n\n\n使用 SolrJ 操作 Solr\n\n\nSpring Data for Apache Solr\n\nSolrCloud\n\n\n\n# 学习目标\n\n\n\n知识点\n要求\n\n\n\n\nSolr 简介\n掌握\n\n\nSolr 搜索原理\n掌握\n\n\nSolr 单机版安装\n掌握\n\n\n可视化管理界面\n掌握\n\n\n新建核心\n掌握\n\n\n分词\n掌握\n\n\nDataimport\n掌握\n\n\n使用 SolrJ 操作 Solr\n掌握\n\n\nSolrCloud\n掌握\n\n\nSpring Data for Apache Solr\n掌握\n\n\n\n# 一、Solr 简介\n# 1. 为什么使用 Solr\n​\t在海量数据下，对 MySQL 或 Oracle 进行模糊查询或条件查询的效率是很低的。而搜索功能在绝大多数项目中都是必须的，如何提升搜索效率是很多互联网项目必须要考虑的问题。\n​\t既然使用关系型数据库进行搜索效率比较低，最直接的解决方案就是使用专用搜索工具进行搜索，从而提升搜索效率。\n# 2. 常见搜索解决方案\n​\t基于 Apache Lucene（全文检索工具库）实现搜索。但是 Lucene 的使用对于绝大多数的程序员都是 “噩梦级” 的。\n​\t基于谷歌 API 实现搜索。\n​\t基于百度 API 实现搜索。\n# 3.Solr 简介\n​\tSolr 是基于 Apache Lucene 构建的用于搜索和分析的开源解决方案。可提供可扩展索引、搜索功能、高亮显示和文字解析功能。\n​\tSolr 本质就是一个 Java web 项目，且内嵌了 Jetty 服务器，所以安装起来非常方便。客户端操作 Solr 的过程和平时我们所写项目一样，就是请求 Solr 中控制器，处理完数据后把结果响应给客户端。\n# 4. 正向索引和反向索引\n​\t只要讨论搜索就不得不提的两个概念：正向索引（forward index）和反向索引 (inverted index)。\n​\t正向索引：从文档内容到词组的过程。每次搜索的实收需要搜索所有文档，每个文档比较搜索条件和词组。\n\n\n\n文档\n词组\n\n\n\n\nI am a chinese\nI,am,a,chinese\n\n\n\n​\t反向索引：是正向索引的逆向。建立词组和文档的映射关系。通过找到词组就能找到文档内容。（和新华字典找字很像）\n\n\n\n词组\n文档\n\n\n\n\nI,am,a,chinese\nI am a chinese\n\n\n\n# 二、Solr 搜索原理\n# 1. 搜索原理\n​\tSolr 能够提升检索效率的主要原因就是分词和索引（反向索引，通过）。\n​\t分词：会对搜索条件 / 存储内容进行分词，分成日常所使用的词语。\n​\t索引：存储在 Solr 中内容会按照程序员的要求来是否建立索引。如果要求建立索引会把存储内容中关键字（分词）建立索引。\n\n# 2.Solr 中数据存储说明\n​\tSolr 为了给内容建立索引，所以 Solr 就必须具备数据存储能力。所有需要被搜索的内容都需要存储在 Solr 中，在开发中需要把数据库中数据添加到 Solr 中进行初始化，每次修改数据库中数据还需要同步 Solr 中的数据。\n​\tSolr 中数据存储是存储在 Document 对象中，对象中可以包含的属性和属性类型都定义在 scheme.xml 中。如果需要自定义属性或自定义属性类型都需要修改 scheme.xml 配置文件。从 Solr5 开始 schema.xml 更改名称为 managed-scheme (没有扩展名)\n# 三、Solr 单机版安装\n​\tSolr 是使用 Java 编写，所以必选先安装 JDK。\n# 1. 上传并解压\n​\t上传压缩包 solr-7.7.2.tgz 到 /usr/local/tmp 中。\n解压\n# cd &#x2F;usr&#x2F;local&#x2F;tmp\n# tar zxf solr-7.7.2.tgz\n# 2. 复制到 /usr/local 中\n# cp -r solr-7.7.2 ..&#x2F;solr\n# 3. 修改启动参数\n​\t修改启动参数，否则启动时报警告。提示设置 SOLR_ULIMIT_CHECKS=false\n# cd &#x2F;usr&#x2F;local&#x2F;solr&#x2F;bin\n# vim solr.in.sh\n\n# 4. 启动 Solr\n​\tSolr 内嵌 Jetty，直接启动即可。监听 8983 端口。\n​\tsolr 默认不推荐 root 账户启动，如果是 root 账户启动需要添加 - force 参数。\n# .&#x2F;solr start -force\n# 四、可视化管理界面\n​\t在关闭防火墙的前提下，可以在 windows 的浏览器中访问 Solr。\n​\t输入: http://192.168.93.10:8983 就可以访问 Solr 的可视化管理界面。\n​\t左侧有 5 个菜单。分别是：\n​\t（1）Dashboard：面板显示 Solr 的总体信息。\n​\t（2）Logging：日志\n​\t（3）Core Admin：Solr 的核心。类似于数据的 Database\n​\t（4）Java Perperties：所有 Java 相关属性。\n​\t（5）Thread Dump：线程相关信息。\n​\t（6）如果有 Core，将显示在此处。\n\n# 五、新建核心\n​\tSolr 安装完成后默认是没有核心的。需要手动配置。\n​\t需要在 solr/server/solr 下新建文件夹，并给定配置文件，否则无法建立。\n\n# 1. 新建目录\n​\t在 /usr/local/solr/server/solr 中新建自定义名称目录。此处示例名称为 testcore。\n# cd &#x2F;usr&#x2F;local&#x2F;solr&#x2F;server&#x2F;solr\n# mkdir testcore\n# 2. 复制配置文件\n​\t在 configsets 里面包含了_default 和 sample_techproducts_configs。里面都是配置文件示例。_default 属于默认配置，较纯净。sample_techproducts_configs 是带有了一些配置示例。\n# cp -r configsets&#x2F;_default&#x2F;conf&#x2F; testcore&#x2F;\n# 3. 填写 Core 信息\n​\t在可视化管理界面中 Core Admin 中编写信息后点击 Add Core 后，短暂延迟后 testcore 就会创建成功。schema 处不用更改。\n\n# 4. 出现 testcore\n​\t在客户端管理界面中，选择新建的 Core 后，就可以按照自己项目的需求进行操作了。\n\n# 六、分词 Analysis\n​\t在 Solr 可视化管理界面中，Core 的管理菜单项中都会有 Analysis。表示根据 Scheme.xml (managed-schema) 中配置要求进行解析。\n​\t对英文解析就比较简单了，只要按照空格把英文语句拆分成英文单词即可。\n\n​\t但是如果条件是中文时，把一句话按照字进行拆分就不是很合理了。正确的方式是按照合理的词组进行拆分。\n# 1. 配置步骤\n​\t上传 ik-analyzer.jar 到 webapps 中。\n​\t去 https://search.maven.org/search?q=com.github.magese 下载对应版本的 ik-analyzer。可以在资料中直接获取。\n# 1.1 上传 jar 到指定目录\n​\t上传 ik-analyzer-7.7.0.jar 到\n​\t/usr/local/solr/server/solr-webapp/webapp/WEB-INF/lib 目录中\n# 1.2 修改配置文件\n​\t修改 /usr/local/solr/server/solr/testcore/conf/managed-schema\nvim /usr/local/solr/server/solr/testcore/conf/managed-schema\n​\t添加下面内容。\n​\t排版：Esc 退出编辑状态下：gg=G\n&lt;field name&#x3D;&quot;myfield&quot; type&#x3D;&quot;text_ik&quot; indexed&#x3D;&quot;true&quot; stored&#x3D;&quot;true&quot; &#x2F;&gt;\n    &lt;fieldType name&#x3D;&quot;text_ik&quot; class&#x3D;&quot;solr.TextField&quot;&gt;\n            &lt;analyzer type&#x3D;&quot;index&quot;&gt;\n                    &lt;tokenizer class&#x3D;&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart&#x3D;&quot;false&quot; conf&#x3D;&quot;ik.conf&quot;&#x2F;&gt;\n                    &lt;filter class&#x3D;&quot;solr.LowerCaseFilterFactory&quot;&#x2F;&gt;\n            &lt;&#x2F;analyzer&gt;\n            &lt;analyzer type&#x3D;&quot;query&quot;&gt;\n                    &lt;tokenizer class&#x3D;&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart&#x3D;&quot;true&quot; conf&#x3D;&quot;ik.conf&quot;&#x2F;&gt;\n                    &lt;filter class&#x3D;&quot;solr.LowerCaseFilterFactory&quot;&#x2F;&gt;\n            &lt;&#x2F;analyzer&gt;\n    &lt;&#x2F;fieldType&gt;\n# 1.3 重启\n# cd &#x2F;usr&#x2F;local&#x2F;solr&#x2F;bin\n# .&#x2F;solr stop -all\n# .&#x2F;solr start -force\n# 1.4 验证\n​\t可以在可视化管理界面中找到 myfield 属性进行验证。\n\n# 2.managed-schema 配置说明\n# 2.1&lt; fieldType/&gt;\n​\t表示定义一个属性类型。在 Solr 中属性类型都是自定义的。在上面配置中 name=”text_ik” 为自定义类型。当某个属性取值为 text_ik 时 IK Analyzer 才能生效。\n# 2.2&lt; field/&gt;\n​\t表示向 Document 中添加一个属性。\n​\t常用属性：\n​\t\tname: 属性名\n​\t\ttype: 属性类型。所有类型都是 solr 使用配置的\n​\t\tindexed: 是否建立索引\n​\t\tstored: solr 是否把该属性值响应给搜索用户。\n​\t\trequired：该属性是否是必须的。默认 id 是必须的。\n​\t\tmultiValued：如果为 true，表示该属性为复合属性，此属性中包含了多个其他的属性。常用在多个列作为搜索条件时，把这些列定义定义成一个新的复合属性，通过搜索一个复合属性就可以实现搜索多个列。当设置为 true 时与 &lt;copyField source=&quot;&quot;dest=&quot;&quot;/&gt; 结合使用\n# 2.3&lt; uniqueKey&gt;\n​\t唯一主键，Solr 中默认定义 id 属性为唯一主键。ID 的值是不允许重复的。\n# 2.4&lt; dynamicField&gt;\n​\t名称中允许 * 进行通配。代表满足特定名称要求的一组属性。\nmsb_java    \n\n​\tmsb_bigdata\n​\tmsb_UI\n​        msb_*\n# 七、Dataimport\n​\t可以使用 Solr 自带的 Dataimport 功能把数据库中数据快速导入到 solr 中.\n​\t必须保证 managed-schema 和数据库中表的列对应。，添加配置\n# 1. 修改配置文件\n​\t修改 solrconfig.xml，添加下面内容\n&lt;!-- 配置数据导入的处理器 --&gt;\n &lt;requestHandler name&#x3D;&quot;&#x2F;dataimport&quot; class&#x3D;&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;&gt;\n   &lt;lst name&#x3D;&quot;defaults&quot;&gt;\n  &lt;!--  加载data-config.xml  --&gt;\n     &lt;str name&#x3D;&quot;config&quot;&gt;data-config.xml&lt;&#x2F;str&gt;\n    &lt;&#x2F;lst&gt;\n &lt;&#x2F;requestHandler&gt;\n# 2. 新建 data-config.xml\n​\t和 solrconfig.xml 同一目录下新建 data-config.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;dataConfig&gt;\n        &lt;dataSource type&#x3D;&quot;JdbcDataSource&quot;   \n                driver&#x3D;&quot;com.mysql.jdbc.Driver&quot;   \n                url&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;192.168.1.135:3306&#x2F;mytest&quot;   \n                user&#x3D;&quot;root&quot;   \n                password&#x3D;&quot;root&quot;&#x2F;&gt;\n        &lt;document&gt;\n            &lt;entity name&#x3D;&quot;product&quot; query&#x3D;&quot;SELECT id,name,price from t_product&quot;&gt;\n                &lt;!-- \n                 实现数据库的列和索引库的字段的映射\n                 column 指定数据库的列表\n                 name  指定索引库的字段名字，必须和schema.xml中定义的一样\n                 --&gt;\n                 &lt;field column&#x3D;&quot;id&quot; name&#x3D;&quot;id&quot;&#x2F;&gt;\n                 &lt;field column&#x3D;&quot;name&quot; name&#x3D;&quot;name&quot;&#x2F;&gt;\n\t\t\t\t &lt;field column&#x3D;&quot;price&quot; name&#x3D;&quot;price&quot;&#x2F;&gt;\n            &lt;&#x2F;entity&gt;\n         &lt;&#x2F;document&gt;\n&lt;&#x2F;dataConfig&gt;\n# 3. 添加 jar\n​\t向 solr-webapp 中添加三个 jar。在 dist 中两个还有一个数据库驱动。\n\n# 4. 操作\n​\t重启 solr 后，在可视化管理页面中进行数据导入。\n​\t注意：\n​\t点击导入按钮后，要记得点击刷新按钮。\n# 八、菜单项目 Documents 使用办法\n​\t以 XML 格式举例\n# 1. 新增 / 修改\n​\t当 id 不存在时新增，当 id 存在修改。\n&lt;doc&gt;\n&lt;field name&#x3D;&quot;id&quot;&gt;8&lt;&#x2F;field&gt;\n&lt;field name&#x3D;&quot;name&quot;&gt;明天更大卖&lt;&#x2F;field&gt;\n&lt;field name&#x3D;&quot;price&quot;&gt;98&lt;&#x2F;field&gt;\n&lt;&#x2F;doc&gt;\n# 2. 删除\n# 2.1 根据主键删除\n&lt;delete&gt;\n\t&lt;id&gt;8&lt;&#x2F;id&gt;\n&lt;&#x2F;delete&gt;\n&lt;commit&#x2F;&gt;\n# 2.2 根据条件删除\n&lt;delete&gt;\n\t&lt;query&gt;*:*&lt;&#x2F;query&gt;\n&lt;&#x2F;delete&gt;\n# 3.solr 可视化界面使用（QUERY）\n\n参数：\n​\t**q：**query，等于。格式  ——&gt; parameter/columns : value\t具有分词时，相当于模糊查询–like\n​\tfq：【在 q 的情况下再加条件】（要有分词功能）注意这里的 keyword 是用来检索的字段，他包含 name、address、gender、expert_skill，这几个属性，所以我搜索 “海” 能够查询出来有海字的记录。\n​\t**sort：** 排序 。 parameter/columns    desc 逆序 /asc\n​\t**start,rows：** 从查询结果的 start 开始，显示到 rows 结束【下标】\n​\t**fl：** 想显示的属性。\n​\t**df：** 不想显示的属性。\n​\t**wt：** 返回值类型\n​\t**hl：** 高亮\n\t*  hl.fl\t\t\t\t\t\t value\n\t*  hl.simple.pre        &lt;font color='red'&gt;\n\t*  hl.simple.post     &lt;/font&gt;\n\n​\n# 九、使用 SolrJ 操作 Solr\n​\tSolrJ 是 Solr 提供的 Java 客户端 API。通过 SolrJ 可以实现 Java 程序对 Solr 中数据的操作。\n​\t大前提：添加 SolrJ 依赖。依赖版本和 Solr 版本严格对应\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.solr&lt;&#x2F;groupId&gt;\n        \t&lt;artifactId&gt;solr-solrj&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;7.7.2&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n# 1. 新增 / 修改实现\nString url &#x3D; &quot;http:&#x2F;&#x2F;192.168.93.10:8983&#x2F;solr&#x2F;testcore&quot;;\nHttpSolrClient solrClient &#x3D;  new HttpSolrClient.Builder(url).build();\nSolrInputDocument inputDocument &#x3D; new SolrInputDocument();\ninputDocument.addField(&quot;id&quot;,&quot;3&quot;);\ninputDocument.addField(&quot;myfield&quot;,&quot;myfield3&quot;);\nsolrClient.add(inputDocument);\nsolrClient.commit();\n\n使用 solrj 进行索引的添加\n\n\n\n每个索引的添加必须要 ID\n\n添加 key 值要和 schema.xml 文件内的 field 域保持一致\n添加数据后一定要提交数据，不然是不存在数据的\n连接 Solr 的对象需要连接到项目名\n每个 document 是一组 Json 数据对象\n\n\n\n\n\n\n\n# 2. 删除实现\nString url &#x3D; &quot;http:&#x2F;&#x2F;192.168.93.10:8983&#x2F;solr&#x2F;testcore&quot;;\nHttpSolrClient solrClient &#x3D;  new HttpSolrClient.Builder(url).build();\nsolrClient.deleteById(&quot;3&quot;);\nsolrClient.commit();\n\n删除\n删除支持两种删除方式\n\n\n\n1. 根据 ID\n\n2. 执行查询删除\n\n\n\n查询删除的格式：查询的域：值\n\n\n\n\n\n\n\n\n\n\n\n# 3. 查询实现\npublic void testQuery()&#123;\n    try &#123;\n        String url &#x3D; &quot;http:&#x2F;&#x2F;192.168.93.10:8983&#x2F;solr&#x2F;testcore&quot;;\n        HttpSolrClient solrClient &#x3D; new HttpSolrClient.Builder(url).build();\n\n        &#x2F;&#x2F;封装了所有查询条件\n        SolrQuery params &#x3D; new SolrQuery();\n        params.setQuery(&quot;name:丰富的&quot;);\n        &#x2F;&#x2F;排序\n        params.setSort(&quot;price&quot;, SolrQuery.ORDER.desc);\n        &#x2F;&#x2F;分页\n        params.setStart(0);\n params.setRows(1);\n        &#x2F;&#x2F;高亮\n        params.setHighlight(true);\n        params.addHighlightField(&quot;name&quot;);\n        params.setHighlightSimplePre(&quot;&lt;span&gt;&quot;);\n        params.setHighlightSimplePost(&quot;&lt;&#x2F;span&gt;&quot;);\n\n        QueryResponse response &#x3D; solrClient.query(params);\n        SolrDocumentList list &#x3D; response.getResults();\n        System.out.println(&quot;总条数：&quot;+list.getNumFound());\n\n        &#x2F;&#x2F;高亮数据\n        Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting &#x3D; response.getHighlighting();\n\n        for(SolrDocument doc :list)&#123;\n            System.out.println(doc.get(&quot;id&quot;));\n            Map&lt;String, List&lt;String&gt;&gt; map &#x3D; highlighting.get(doc.get(&quot;id&quot;));\n            List&lt;String&gt; HLList &#x3D; map.get(&quot;name&quot;);\n            if(HLList!&#x3D;null&amp;&amp;HLList.size()&gt;0)&#123;&#x2F;&#x2F;显示高亮数据\n                System.out.println(HLList.get(0));\n            &#125;else&#123;\n                System.out.println(doc.get(&quot;name&quot;));\n            &#125;\n            System.out.println(doc.get(&quot;price&quot;));\n            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        &#125;\n        solrClient.close();\n    &#125; catch (SolrServerException e) &#123;\n        e.printStackTrace();\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n使用到的对象\n\n1.SolrQuery 查询对象\n\n1.setQuery ()：设置查询的关键字\n 2.set（）: 设置查询的域\n 3.setStart (): 设置开始\n 4.setRows（）：设置结束\n\n\n\n\n\n\n2.QueryResponse：响应结果集\n\n1.getNumFound (): 返回查询到的数量\n 2.getResults（）；返回封装的 list 集合\n\n\n\n3.SolrDocumentList：结果集合\n\n1.get (): 获取指定域的值\n\n\n\n# 十、Spring Data for Apache Solr\n# 1.Spring Data 简介\n​\tSpring Data 是 Spring 的顶级项目。里面包含了 N 多个二级子项目，每个子项目对应一种技术或工具。其目的为了让数据访问更加简单，更加方便的和 Spring 进行整合。\n​\tSpring Data 项目如果单独使用是还需要配置 XML 配置文件的，当和 Spring Boot 整合后使用起来非常方便。spring-boot-starter-data-xx 就是对应的启动器。\n# 2. 实现步骤\n# 2.1 添加依赖\n&lt;dependencies&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n           &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n       &lt;&#x2F;dependency&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n           &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n       &lt;&#x2F;dependency&gt;\n       &lt;dependency&gt;\n           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n           &lt;artifactId&gt;spring-boot-starter-data-solr&lt;&#x2F;artifactId&gt;\n       &lt;&#x2F;dependency&gt;\n   &lt;&#x2F;dependencies&gt;\n# 2.2 编写配置文件\nspring:\n  data:\n    solr:\n      host: http:&#x2F;&#x2F;192.168.9.132:8080&#x2F;solr\n      # zk-host: 192.168.9.132:2181,192.168.9.132:2182,192.168.9.132:2183\n# 2.3 编写测试类\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest(classes &#x3D; MyApplication.class)\npublic class MyTest &#123;\n    @Autowired\n    private SolrTemplate solrTemplate;\n\n    public void testInsert()&#123;\n        SolrInputDocument doc &#x3D; new SolrInputDocument();\n        doc.setField(&quot;id&quot;,&quot;002&quot;);\n        doc.setField(&quot;item_title&quot;,&quot;这是一个手机3&quot;);\n        UpdateResponse ur &#x3D; solrTemplate.saveBean(&quot;collection1&quot;, doc);\n        if(ur.getStatus()&#x3D;&#x3D;0)&#123;\n            System.out.println(&quot;成功&quot;);\n        &#125;else&#123;\n            System.out.println(&quot;失败&quot;);\n        &#125;\n        solrTemplate.commit(&quot;collection1&quot;);\n    &#125;\n\n    public void testDelete()&#123;\n        UpdateResponse ur &#x3D; solrTemplate.deleteByIds(&quot;collection1&quot;, &quot;change.me&quot;);\n        if(ur.getStatus()&#x3D;&#x3D;0)&#123;\n            System.out.println(&quot;成功&quot;);\n        &#125;else&#123;\n            System.out.println(&quot;失败&quot;);\n        &#125;\n        solrTemplate.commit(&quot;collection1&quot;);\n    &#125;\n\n\n    public void query()&#123;\n        SimpleQuery query &#x3D; new SimpleQuery();\n        Criteria c &#x3D; new Criteria(&quot;item_keywords&quot;);\n        c.is(&quot;手机&quot;);\n        query.addCriteria(c);\n        query.setOffset(1L);\n        query.setRows(1);\n        ScoredPage&lt;DemoPojo&gt; sp &#x3D; solrTemplate.queryForPage(&quot;collection1&quot;, query, DemoPojo.class);\n        System.out.println(sp.getContent());\n    &#125;\n\n    @Test\n    public void queryHL()&#123;\n\n        List&lt;DemoPojo&gt; listResult &#x3D; new ArrayList&lt;&gt;();\n        SimpleHighlightQuery query &#x3D; new SimpleHighlightQuery();\n        &#x2F;&#x2F;设置查询条件\n        Criteria c &#x3D; new Criteria(&quot;item_keywords&quot;);\n        c.is(&quot;手机&quot;);\n        query.addCriteria(c);\n        &#x2F;&#x2F;分页\n        query.setOffset(0L);\n        query.setRows(10);\n        &#x2F;&#x2F;排序\n        Sort sort &#x3D; new Sort(Sort.Direction.DESC,&quot;id&quot;);\n        query.addSort(sort);\n        &#x2F;&#x2F;高亮设置\n        HighlightOptions hlo &#x3D; new HighlightOptions();\n        hlo.addField(&quot;item_title item_sell_point&quot;);\n        hlo.setSimplePrefix(&quot;&lt;span style&#x3D;&#39;color:red;&#39;&gt;&quot;);\n        hlo.setSimplePostfix(&quot;&lt;&#x2F;span&gt;&quot;);\n        query.setHighlightOptions(hlo);\n        HighlightPage&lt;DemoPojo&gt; hl &#x3D; solrTemplate.queryForHighlightPage(&quot;collection1&quot;, query, DemoPojo.class);\n&#x2F;&#x2F;        System.out.println(hl.getContent());\n        List&lt;HighlightEntry&lt;DemoPojo&gt;&gt; highlighted &#x3D; hl.getHighlighted();\n        for(HighlightEntry&lt;DemoPojo&gt; hle : highlighted)&#123;\n            List&lt;HighlightEntry.Highlight&gt; list &#x3D; hle.getHighlights();\n            DemoPojo dp &#x3D; hle.getEntity();\n            for (HighlightEntry.Highlight h : list)&#123;&#x2F;&#x2F;一个对象里面可能多个属性是高亮属性\n                if(h.getField().getName().equals(&quot;item_title&quot;))&#123;\n                    dp.setItem_title( h.getSnipplets().get(0));\n                &#125;\n            &#125;\n            listResult.add(dp);\n        &#125;\n        System.out.println(listResult);\n    &#125;\n&#125;\n# 十一。使用 zookeepr 管理 solr 集群\n1. 上传压缩包到 /usr/local/tmp 下 并解压。\n2. 在 /usr/local 下新建文件夹 zookeeper\n# mkdir &#x2F;usr&#x2F;local&#x2F;zookeeper\n3. 把解压的所有文件复制到 zookeeper 下， 并命名为 zk1\n# cp -r &#x2F;usr&#x2F;local&#x2F;temp&#x2F;zookeeper-3.4.8 &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;zk1\n4. 在 zk1 下新建文件夹 data\n5. 在 data 下新建文件 myid, 里面写上 1\n# vim myid\n6. 进入到 zk1/conf 下 把 zoo_sample.cfg 复制一份叫做 zoo.cfg\n7. 编辑 zoo.cfg 内容，设置 dataDIR 为 data 文件夹， 并在文件最下面添加下面内容\nserver.1&#x3D;192.168.93.10:2688:3888\nserver.2&#x3D;192.168.93.10:2689:3889\nserver.3&#x3D;192.168.93.10:2690:3890\n7.1 server.1 中的 1 是 myid 的内容\n7.2 2688 2689 2690 是 zookeeper 内部端口\n7.3 3888 3889 3890 是 leader 端口\n8. 把 zk1 复制两份，分部叫做 zk2  zk3  并修改 myid 的值为 2，3 修改 zoo.cfg 中 dataDIR 和 clientPort\n9. 启动三个 zookeeper\n# .&#x2F;zkServer.sh start\n10. 查看状态\n# .&#x2F;zkServer.sh status\n# 十一。使用 zookeepr 管理 solr 集群 (Dokcer)\n# 1、准备 docker-compose.yml 文件\nversion: '2'\nservices:\n  zoo1:\n    image: zookeeper:3.5\n    restart: always\n    container_name: zoo1\n    ports:\n      - \"2181:2181\"\n    environment:\n      ZOO_MY_ID: 1\n      ZOO_SERVERS: server.1=0.0.0.0:2688:3888 server.2=zoo2:2689:3888 server.3=zoo3:2690:3888\n\n  zoo2:\n    image: zookeeper:3.5\n    restart: always\n    container_name: zoo2\n    ports:\n      - \"2182:2181\"\n    environment:\n      ZOO_MY_ID: 2\n      ZOO_SERVERS: server.1=zoo1:2688:3888 server.2=0.0.0.0:2689:3888 server.3=zoo3:2690:3888\n\n  zoo3:\n    image: zookeeper:3.5\n    restart: always\n    container_name: zoo3\n    ports:\n      - \"2183:2181\"\n    environment:\n      ZOO_MY_ID: 3\n      ZOO_SERVERS: server.1=zoo1:2688:3888 server.2=zoo2:2689:3888 server.3=0.0.0.0:2690:3888\n\n\n# 2、创建镜像\n\n要在创建的 docker-compose.yml 文件中使用命令\n\ndocker-compose up -d\n# 3、进入容器\ndocker exec -it zoo1 /bin/bash\n\n#查看zoo1 的状态\ncd bin\n./zkServer.sh status\n\n如果出现，以下情况：\n\nZooKeeper JMX enabled by default\nUsing config: &#x2F;conf&#x2F;zoo.cfg\nClient port not found in static config file. Looking in dynamic config file.\ngrep: : No such file or directory\nClient port not found in the server configs\nClient port not found. Looking for secureClientPort in the static config.\nUnable to find either secure or unsecure client port in any configs. Terminating.\n​\t通过阅读我们知道他在 conf 中的 zoo.cfg 文件中缺少 **clientPort ** 我们只需要自行添加即可\n#修改之前我们先装一下 vim\napt-get update\n\napt-get install -y vim \n\n#修改zoo.fcg文件\nvim /conf/zoo.fcg\n\nclientPort=2181\n\n\n完事之后重启 zoo1\n\n成功！！\n\n\n# 4、查看所有 zookeeper 的状态\ndocker exec -it zoo3 bash ./bin/zkServer.sh status\n# 5、进去客户端\ndocker exec -it zoo3 zkCli.sh\n# 十二、SolrCloud\n​\tSolr 可以搭建具备容错能力和高可用的 Solr 集群。集群中集群配置、自动负载均衡和查询故障转移、\t\t\tZookeeper 集群实现集群协调管理，这些全部功能统称为 SolrCloud。\n​\tSolrCloud 是基于 Zookeeper 进行管理的。在 Solr 中已经内置了 Zookeeper 相关内容，当执行集群创建命令会自动创建 Zookeeper 相关内容。这个使用的是 Zookeeper 的集群管理功能实现的。\n# 1. 搭建\n# 1.1 创建\n​\tSolrCloud 已经包含在了 Solr 中，可以直接启动 Solr 集群。\n.&#x2F;solr -e cloud -noprompt -force\n​\t此命令等同于# ./solr -e cloud -force 全部参数为默认值。\n​\t运行成功后会在 example 文件夹多出 cloud 文件夹。\n# 1.2 停止\n.&#x2F;solr stop -all\n# 1.3 重新运行\n.&#x2F;solr start -c -p 8983 -s ..&#x2F;example&#x2F;cloud&#x2F;node1&#x2F;solr&#x2F; -force\n.&#x2F;solr start -c -p 7574 -z localhost:9983 -s ..&#x2F;example&#x2F;cloud&#x2F;node2&#x2F;solr&#x2F; -force\n","slug":"Solr","date":"2022-10-06T16:00:00.000Z","categories_index":"分布式,Solr","tags_index":"分布式,中间件,Solr,快速搜索","author_index":"雾都"},{"id":"946249c65165e1a3d66f50e0cb6e89e7","title":"Spring","content":"# 概念：\n\n\nSpring 是 ** 一个轻量级 **Java 开发框架，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的 JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发 Java 应用程序提供全面的基础架构支持。Spring 负责基础架构，因此 Java 开发者可以专注于应用程序的开发。\n\n\nSpring 最根本的使命是 ** 解决企业级应用开发的复杂性，** 即简化 Java 开发。\n\n\nSpring 可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的\n\n\n两个核心特性，也就是依赖注入（dependency injection，DI）和面向切面编程（aspect-\noriented programming，AOP）。\n为了降低 Java 开发的复杂性，Spring 采取了以下 4 种关键策略\n\n\n基于 POJO 的轻量级和最小侵入性编程；\n\n\n通过依赖注入和面向接口实现松耦合；\n\n\n基于切面和惯例进行声明式编程；\n\n\n通过切面和模板减少样板式代码。\n\n\n# Spring 的俩大核心概念\n# IOC（控制翻转）：\n控制翻转，也叫依赖注入，他就是不会直接创建对象，只是把对象声明出来，在代码 中不直\n接与对象和服务进行连接，但是在配置文件中描述了哪一项组件需要哪一项服 务，容器将他\n们组件起来。在一般的 IOC 场景中容器创建了所有的对象，并设置了必 要的属性将他们联系\n在一起，等到需要使用的时候才把他们声明出来，使用注解就跟 方便了，容器会自动根据注\n解把对象组合起来\n# 其中还有一个点 DI (依赖注入)\n# AOP（面对切面编程）\n面对切面编程，这是一种编程模式，他允许程序员通过自定义的横切点进行模块 化，将那些\n影响多个类的行为封装到课重用的模块中。 例子：比如日志输出，不使用 AOP 的话就需要把\n日志的输出语句放在所有类中，方法 中，但是有了 AOP 就可以把日志输出语句封装一个可重\n用模块，在以声明的方式将他 们放在类中，每次使用类就自动完成了日志输出。\n# Bean 的生命周期\n1 通过构造器创建 bean 实例           执行构造器\n 2 为 bean 属性赋值                         执行 set 方法\n 3 初始化 bean                                调用 bean 的初始化方法，需要配置指定调用的方法\n 4 bean 的获取                                容器对象 getBean 方法\n 5 容器关闭销毁 bean                      调用销毁方法，需要配置指定调用的方法\npublic class User &#123;\n    private Integer userid;\n    private String username;\n    private String password;\n    public void initUser()&#123;\n        System.out.println(\"第三步:User初始化\");\n    &#125;\n    public User() &#123;\n        System.out.println(\"第一步:User构造\");\n    &#125;\n    public void destoryUser()&#123;\n        System.out.println(\"第五步:User销毁\");\n    &#125;\n    @Override\n    public String toString() &#123;\n        return \"User&#123;\" +\n                \"userid=\" + userid +\n                \", username='\" + username + '\\'' +\n                \", password='\" + password + '\\'' +\n                '&#125;';\n    &#125;\n    public User(Integer userid, String username, String password) &#123;\n        this.userid = userid;\n        this.username = username;\n        this.password = password;\n    &#125;\n    public void setUserid(Integer userid) &#123;\n        System.out.println(\"setUserid\");\n        this.userid = userid;\n    &#125;\n    public void setUsername(String username) &#123;\n        System.out.println(\"第二步:User属性赋值\");\n        this.username = username;\n    &#125;\n    public void setPassword(String password) &#123;\n        this.password = password;\n    &#125;\n&#125;\n配置 Bean\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:c=\"http://www.springframework.org/schema/c\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    &lt;!--  -->\n    &lt;bean id=\"user\" class=\"com.msb.bean.User\" init-method=\"initUser\" destroy-method=\"destoryUser\">\n        &lt;property name=\"username\" value=\"xiaoming\">&lt;/property>\n    &lt;/bean>\n&lt;/beans>\n根据 Class、property 通过反射去找构造器创建实例，然后对 property 属性根据 set 方法注入依赖也叫赋值，\n通过指定 init-method (初始化方法) 来对我们的对象再次进行操作，第四步获取 Bean 对象，第五步项目结束 Context 销毁，调用销毁方法销毁 Bean\n以上我们是对一般的过程其实在这个基础上我们还可以再次增加两步，这个叫后置处理器，处理后的顺序：\n1 通过构造器创建 bean 实例           执行构造器\n 2 为 bean 属性赋值                         执行 set 方法\n3 把 bean 实例传递给 bean 的后置处理器的方法\n4 初始化 bean                                调用 bean 的初始化方法，需要配置指定调用的方法\n5 把 bean 实例传递给 bean 的后置处理器的方法\n6 bean 的获取                                容器对象 getBean 方法\n 7 容器关闭销毁 bean                      调用销毁方法，需要配置指定调用的方法\n添加后置处理器\n1 创建后置处理器 实现 BeanPostProcesser  重写两个方法\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\n// 1 创建后置处理器 实现 BeanPostProcesser  重写两个方法\npublic class MyBeanProcesser implements BeanPostProcessor &#123;\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;\n        //Object bean      实例化的bean\n        //String beanName  bean的id\n        System.out.println(\"bean:初始化方法之前\");\n        return bean;// 这里必须return bean\n    &#125;\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;\n        System.out.println(\"bean:初始化方法之后\");\n        return bean;// 这里必须returnbean\n    &#125;\n&#125;\n2 配置后置处理器，对容器中的所有 bean 添加后置处理器的生命周期\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:c=\"http://www.springframework.org/schema/c\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    &lt;bean id=\"user\" class=\"com.msb.bean.User\" init-method=\"initUser\" destroy-method=\"destoryUser\">\n        &lt;property name=\"username\" value=\"xiaoming\">&lt;/property>\n    &lt;/bean>\n    \n    &lt;bean id=\"myBeanProcesser\" class=\"com.msb.beanProcesser.MyBeanProcesser\">&lt;/bean>\n&lt;/beans>\nBeanPostProcessor 接口作用：\n\n\n\n\n\n\n\n\n\n如果我们想在 Spring 容器中完成 bean 实例化、配置以及其他初始化方法前后要添加一些自己逻辑处理。我们需要定义一个或多个 BeanPostProcessor 接口实现类，然后注册到 Spring IoC 容器中。\n1、接口中的两个方法都要将传入的 bean 返回，而不能返回 null，如果返回的是 null 那么我们通过 getBean 方法将得不到目标。\n2、ApplicationContext 会自动检测在配置文件中实现了 BeanPostProcessor 接口的所有 bean，并把它们注册为后置处理器，然后在容器创建 bean 的适当时候调用它，因此部署一个后置处理器同部署其他的 bean 并没有什么区别。而使用 BeanFactory 实现的时候，bean 后置处理器必须通过代码显式地去注册，在 IoC 容器继承体系中的 ConfigurableBeanFactory 接口中定义了注册方法\n总结\n完整的过程：\n\n\n\n\n\n\n\n\n\n创建实例 --&gt; set 赋值 --&gt; 再次初始化对象–&gt; 获取 Bean 对象–&gt; 销毁 Bean 对象\n创建实例 --&gt; set 赋值 --&gt; 把 bean 实例传递给 bean 的后置处理器的方法 --&gt; 再次初始化对象 --&gt; 把 bean 实例传递给 bean 的后置处理器的方法 —&gt; 获取 Bean 对象–&gt; 销毁 Bean 对象\n# Bean 自动装配\n通过 property 标签可以手动指定给属性进行注入\n我们也可以通过自动转配，完成属性的自动注入，就是自动装配，可以简化 DI 的配置\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:c=\"http://www.springframework.org/schema/c\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    &lt;bean id=\"dept\" class=\"com.msb.bean.Dept\">&lt;/bean>\n    &lt;!--\n    autowire 属性控制自动将容器中的对象注入到当前对象的属性上\n    byName 根据目标id值和属性值注入,要保证当前对象的属性值和目标对象的id值一致\n    byType 根据类型注入,要保证相同类型的目标对象在容器中只有一个实例\n    -->\n    &lt;bean id=\"emp\" class=\"com.msb.bean.Emp\" autowire=\"byName\">&lt;/bean>\n&lt;/beans>\n# Spring 注解管理 Bean\n# 1 注解方式创建对象 IOC\n导入依赖 aop\n@Component    放在类上，用于标记，告诉 spring 当前类需要由容器实例化 bean 并放入容器中\n该注解有三个子注解\n @Controller   用于实例化 controller 层 bean\n@Service        用于实例化 service 层 bean\n@Repository  用于实例化持久层 bean\n 当不确定是哪一层，就用 Component\n 这几个注解互相混用其实也可以，但是不推荐\n# 2 注解方式依赖注入 DI\n@Autowired   根据属性数据类型自动装配\n @Qualifier      根据属性名称注入依赖\n @Resources   可以根据类型，也可以根据名称注入\n @Value           注入普通数据类型 (8+String)\n// 详解 \n/*\n    * @Autowired\n    * 根据类型到容器中去寻找对应的对象,找到后给当前属性赋值\n    * 不需要依赖 set方法\n    * 属性类型可以是接口,会自动匹配对应的实现类对象\n    * @Autowired配合 @Qualifier,可以通过名称指定注入的对象\n    *\n    * @Resource 如果不配置name 那么就是根据类型注入\n    * @Resource(name=\"userDaoImplB\") 配置name,就是根据名称注入\n    *\n    *\n    * @Resource  是JDK中javax包的注解\n    * @Autowired 和 @Qualifier 是spring中的注解\n    *\n    * @Value 可以个普通属性赋值\n    * @Value 可以使用$&#123;&#125;这种表达式获取系统的变量值\n    *        或者是.properties属性配置文件中的值\n    *\n    * */\n# 代理\n概念：在使用对象的时候，不直接使用用一个代理对象代理他，这样可以在目标对象基础上增强额外的功能。\n分类：静态代理，动态代理\n# 静态代理\n\n\n\n\n\n\n\n\n\n​\t静态代理中代理类与被代理类都需要实现同一个接口，这就说明我们的一个静态代理类只能代理一个类，并且还要事先知道我们要代理哪个类才能写代理类，如果我们有其他类还想使用代理那就必须再写一个代理类。\n​\t然而在实际开发中我们是可能是有非常多的类是需要被代理的，并且事先我们可能并不知道我们要代理哪个类。所以如果继续使用静态代理反而会增加许多的工作量，并且效率低下，代码复用率也不好。\npublic class Test1 &#123;\n    public static void main(String[] args) &#123;\n        /**\n        lawyer律师代替Person张三打官司，不用张三直接打，可以更加清楚\n        */\n        Person person =new Person(\"张三\");\n        Court court=new Lawyer(person);\n        court.doCourt();\n    &#125;\n&#125;\n// 接口\ninterface Court&#123;\n    void doCourt();\n&#125;\n// 代理类\nclass Lawyer implements Court&#123;\n    private Person person;\n    public Lawyer(Person person) &#123;\n        this.person = person;\n    &#125;\n    @Override\n    public void doCourt() &#123;\n        System.out.println(\"律师取证:视频证明张三当时正在旅游,不在案发现场\");\n        System.out.println(\"律师总结:张三不可能去杀人\");\n        person.doCourt();\n    &#125;\n&#125;\n// 被代理的类\nclass Person implements Court&#123;\n    private String name;\n    public Person(String name) &#123;\n        this.name = name;\n    &#125;\n    @Override\n    public void doCourt() &#123;\n        System.out.println(name+\"说:我没有杀人\");\n    &#125;\n&#125;\n# 动态代理\n概念：动态代理可以针对于一些不特定的类或者一些不特定的方法进行代理，我们可以在程序运行时动态的变化代理的规则，代理类在程序运行时才创建的代理模式成为动态代理。这种情况下，代理类并不是在 Java 代码中定义好的，而是在程序运行时根据我们的在 Java 代码中的 “指示” 动态生成的\n实现方法：JDK 自带的 Proxy、CJlib\n\n\n\nProxy\nJDK 动态代理\n面向接口\n\n\n\n\ncglib\n第三方动态代理\n面向父类\n\n\n\n实现案例：\nProxy:\npublic class ProxyTest1 &#123;\n\n    public static void main(String[] args) &#123;\n        Dinner dinner = new Person(\"张三\");\n        ClassLoader loader = dinner.getClass().getClassLoader();\n        Class&lt;?>[] interfaces = dinner.getClass().getInterfaces();\n        /*\n           Object proxy, 代理对象\n           Method method,被代理的方法\n           Object[] args,被代理方法运行时的实参\n         */\n        /*InvocationHandler invocationHandler = (proxy,\n                                              method,\n                                              params)->&#123;\n            System.out.println(\"invoked 方法执行\");\n\n            return null;\n        &#125;;*/\n        InvocationHandler invocationHandler = new InvocationHandler() &#123;\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n                Object res = new Object();\n\n                if (method.getName().equals(\"eat\")) &#123;\n                    System.out.println(\"饭前洗手\");\n                    // 让原有的eat的方法去运行\n                    res =method.invoke(dinner, args);\n                    System.out.println(\"饭后刷碗\");\n                &#125;\n                else&#123;\n                    // 如果是其他方法,那么正常执行就可以了\n                    res =method.invoke(dinner, args);\n                &#125;\n                return res;\n            &#125;\n        &#125;;\n\n        /**\n         * 动态代理\n         * 需要三次个参数 loader代理类，增强的对象，\n         *              interfaces 实现的接口，\n         *              增强方法 invoke()\n         */\n        Dinner dinner1 = (Dinner) Proxy.newProxyInstance(loader,interfaces,invocationHandler);\n        dinner1.eat(\"包子\");\n    &#125;\n&#125;\ninterface Dinner&#123;\n    void eat(String foodName);\n    void drink();\n&#125;\n\nclass Person implements Dinner&#123;\n    private String name;\n    public Person(String name) &#123;\n        this.name = name;\n    &#125;\n    @Override\n    public void eat(String foodName) &#123;\n        System.out.println(name+\"正在吃\"+foodName);\n    &#125;\n    @Override\n    public void drink( ) &#123;\n        System.out.println(name+\"正在喝茶\");\n    &#125;\n&#125;\nclass Student implements Dinner&#123;\n    private String name;\n    public Student(String name) &#123;\n        this.name = name;\n    &#125;\n    @Override\n    public void eat(String foodName) &#123;\n        System.out.println(name+\"正在食堂吃\"+foodName);\n    &#125;\n    @Override\n    public void drink( ) &#123;\n        System.out.println(name+\"正在喝可乐\");\n    &#125;\n&#125;\nCglib\npublic class ProxyTest2 &#123;\n\n    public static void main(String[] args) &#123;\n        // 获取一个Person的代理对象\n        Person person = new Person();\n        // 1 获得一个Enhancer对象\n        Enhancer enhancer = new Enhancer();\n        // 2 设置父类字节码\n        enhancer.setSuperclass(Person.class);\n        // 3 获取MethodIntercepter对象 用于定义增强规则\n        MethodInterceptor methodInterceptor = new MethodInterceptor() &#123;\n            /*\n            * Object o 生成之后的代理对象 personProxy\n            * Method method 父类中原本要执行的方法  Person>>> eat()要增强的方法（还没有被增强，父类方法）\n            * Object[] objects 实际传入的参数\n            * MethodProxy methodProxy 子类中重写父类的方法 personProxy >>> eat()代理对象增强的方法（增强的方法，子类对象）\n            * */\n            @Override\n            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;\n                Object res = null;\n\n                if (method.getName().equals(\"eat\")) &#123;\n                    System.out.println(\"饭前洗手\");\n                    res=methodProxy.invokeSuper(o,objects);\n                    System.out.println(\"饭后刷碗\");\n                &#125;else&#123;\n                    // 如果是其他方法 不增强运行\n                    res=methodProxy.invokeSuper(o,objects); // 子类对象方法在执行,默认会调用父类对应被重写的方法\n                &#125;\n                return res;\n            &#125;\n        &#125;;\n        // 4 设置methodInterceptor\n        enhancer.setCallback(methodInterceptor);\n        // 5 获得代理对象\n        Person personProxy = (Person)enhancer.create();\n        // 6 使用代理对象完成功能\n        personProxy.eat(\"包子\");\n    &#125;\n&#125;\n\nclass Person  &#123;\n    public Person( ) &#123;\n    &#125;\n    public void eat(String foodName) &#123;\n        System.out.println(\"张三正在吃\"+foodName);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n总结\n\n在不修改原有代码的 或者没有办法修改原有代码的情况下  增强对象功能  使用代理对象 代替原来的对象去完成功能进而达到拓展功能的目的\nJDK Proxy 动态代理面向接口的动态代理  一定要有接口和实现类的存在 代理对象增强的是实现类 在实现接口的方法重写的方法   生成的代理对象只能转换成 接口的不能转换成 被代理类代理对象只能增强接口中定义的方法  实现类中其他和接口无关的方法是无法增强的代理对象只能读取到接口中方法上的注解 不能读取到实现类方法上的注解\n\n# AOP\n全名：Aspect Oriented Programmings，面向切面编程，通过预编译和运行时生成动态代理实现程序功能的统一维护的一种技术。AOP 是 OOP 的延续，是 Spring 框架的一个重要内容，是函数式编程的一种衍生范式。利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使各个部分的耦合性降低，提高程序的可重用行，提高开发效率。\n\nAOP 切面编程一般可以帮助我们在不修改现有代码的情况下，对程序的功能进行拓展，往往用于实现 日志处理，权限控制，性能检测，事务控制等\n AOP 实现的原理就是动态代理，在有接口的情况下，使用 JDK 动态代理，在没有接口的情况下使用 cglib 动态代理\n\nAOP 中的术语辨析\n1 连接点 Joint point：类里面那些可以被增强的方法\n2 切入点 Pointcu：实际被增强的方法，称之为切入点\n3 通知 Advice:：实际增强的逻辑部分称为通知 (增加的功能)\n4 目标对象 Target：被增强功能的对象 (被代理的对象)\n5 切面 Aspect： 表现为功能相关的一些 advice 方法放在一起声明成的一个 Java 类\n6 织入 Weaving：创建代理对象并实现功能增强的声明并运行过程\n具体操作\n/*\n事先准备 dao 以及他的实现类\n我们直接编写 Aspect 层的代码\n*/\n\n@Component\n@Aspect\npublic class DaoAspect &#123;\n    /*\n    切入点表达式: 通过一个表达式来确定AOP要增强的是哪个或者那些方法\n    语法结构:execution([权限修饰符][返回值类型][类的全路径名][方法名](参数 列表) )\n    execution(* com.msb.dao.UserDaoImpl.add(..))   //指定切点为UserDaoImpl.add方法\n    execution(* com.msb.dao.UserDaoImpl.*(..))     //指定切点为UserDaoImpl.所有的方法\n    execution(* com.msb.dao.*.*(..))               //指定切点为dao包下所有的类中的所有的方法\n    execution(* com.msb.dao.*.add(..))             // 指定切点为dao包下所有的类中的add的方法\n    execution(* com.msb.dao.*.add*(..))            // 指定切点为dao包下所有的类中的add开头的方法\n    *  */\n    //定义公共切点\n    @Pointcut(\"execution( * com.zjj.aop.dao.*.add*(..) )\")\n    public void addPointCut()&#123;\n\n    &#125;\n\n    /*\n     * 前置通知: 切点方法执行之前先执行的功能\n     * 参数列表可以用JoinPoint接收切点对象\n     * 可以获取方法执行的参数\n     * */\n    @Before(\"addPointCut()\") // 这里用了公共切点，不然又要写一次公共切点上的 @PointCut()\n    public void methodBefore(JoinPoint joinPoint) &#123;\n        System.out.println(\"Before invoked\");\n    &#125;\n\n\n    /*\n     * 后置通知:方法执行之后要增强的功能\n     * 无论切点方法是否出现异常都会执行的方法\n     * 参数列表可以用JoinPoint接收切点对象\n     * */\n    @After(\"addPointCut()\")\n    public void methodAfter(JoinPoint joinPoint)&#123;\n        System.out.println(\"After invoked\");\n    &#125;\n\n    /*\n     * 返回通知:切点方法正常运行结束后增强的功能\n     * 如果方法运行过程中出现异常,则该功能不运行\n     * 参数列表可以用 JoinPoint joinPoint接收切点对象\n     * 可以用Object res接收方法返回值,需要用returning指定返回值名称\n     * */\n    @AfterReturning( value = \"addPointCut()\",returning = \"res\")\n    public void methodAfterReturning(JoinPoint joinPoint,Object res)&#123;\n        System.out.println(\"AfterReturning invoked\");\n    &#125;\n    /*\n     * 异常通知:切点方法出现异常时运行的增强功能\n     * 如果方法运行没有出现异常,则该功能不运行\n     * 参数列表可以用Exception ex接收异常对象 需要通过throwing指定异常名称\n     * */\n    @AfterThrowing( value = \"addPointCut()\",throwing = \"ex\")\n    public void methodAfterThrowing(Exception ex)&#123;\n        System.out.println(\"AfterThrowing invoked\");\n    &#125;\n\n    /*环绕通知:在切点方法之前和之后都进行功能的增强\n     * 需要在通知中定义方法执行的位置,并在执行位置之前和之后自定义增强的功能\n     * 方法列表可以通过ProceedingJoinPoint获取执行的切点\n     * 通过proceedingJoinPoint.proceed()方法控制切点方法的执行位置\n     * proceedingJoinPoint.proceed()方法会将切点方法的返回值获取到,并交给我们,可以做后续处理\n     * 我们在环绕通知的最后需要将切点方法的返回值继续向上返回,否则切点方法在执行时接收不到返回值\n     * */\n    @Around(\"addPointCut()\")\n    public Object methodAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;\n        System.out.println(\"aroundA invoked\");\n        Object proceed = proceedingJoinPoint.proceed();\n        System.out.println(\"aroundB invoked\");\n        return proceed;\n    &#125;\n\n&#125;\n测试\n@SpringBootTest(classes = MyAOPSpringApplication.class)\npublic class SpringAOPTests &#123;\n    @Resource\n    ApplicationContext context;\n    @Test\n    public void t1() &#123;\n        UserService userService = context.getBean(UserService.class);\n        userService.addUser(10, \"小明\");\n    &#125;\n&#125;\n结果：\n\n\n\n\n\n\n\n\n\naroundA invoked\nBefore invoked\nuserDao add … …\nAfterReturning invoked\nAfter invoked\naroundB invoked\n面试题\n如果在不使用框架的前提下你要做权限的校验你会怎么做？\n\n\n\n\n\n\n\n\n\n我会在要鉴权的方法加入环绕通知，在请求到方法前先进行一次查找，一般这些数据我们会在 redis 中也会存储一个，第一次查过来我们去 redis 中找，找到直接让他操作并且在之后提交事务，但是没找到的时候我们先让他去操作，但是不提交事务，同时去数据库中查找他的信息，找到后添加 redis，提交事务，没找到就回滚事务即可。\n# 事务\n# 事务的概念\n事务（Transaction）指的是一个操作序列，该操作序列中的多个操作要么都做，要么都不做，是一个不可分割的工作单位，是数据库环境中的逻辑工作单位，由 DBMS 中的事务管理子系统负责事务的处理。\n目前常用的存储引擎有 InnoDB（MySQL5.5 以后默认的存储引擎）和 MyISAM（MySQL5.5 之前默认的存储引擎），其中 InnoDB 支持事务处理机制，而 MyISAM 不支持。\n# 事务的特性\n事务处理可以确保除非事务性序列内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的序列，可以简化错误恢复并使应用程序更加可靠。\n但并不是所有的操作序列都可以称为事务，这是因为一个操作序列要成为事务，必须满足事务的原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。这四个特性简称为 ACID 特性。\n\n\n\n原子性\n\n\n\n原子是自然界最小的颗粒，具有不可再分的特性。事务中的所有操作可以看做一个原子，事务是应用中不可再分的最小的逻辑执行体。\n使用事务对数据进行修改的操作序列，要么全部执行，要么全不执行。通常，某个事务中的操作都具有共同的目标，并且是相互依赖的。如果数据库系统只执行这些操作中的一部分，则可能会破坏事务的总体目标，而原子性消除了系统只处理部分操作的可能性。\n\n\n 一致性\n\n\n\n一致性是指事务执行的结果必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。\n例如：在转账时，只有保证转出和转入的金额一致才能构成事务。也就是说事务发生前和发生后，数据的总额依然匹配。\n\n\n 隔离性\n\n\n\n隔离性是指各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间既不能看到对方的中间状态，也不能相互影响。\n例如：在转账时，只有当 A 账户中的转出和 B 账户中转入操作都执行成功后才能看到 A 账户中的金额减少以及 B 账户中的金额增多。并且其他的事务对于转账操作的事务是不能产生任何影响的。\n\n\n持久性\n\n\n\n持久性指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库，即使数据库出现故障，提交的数据也应该能够恢复。但如果是由于外部原因导致的数据库故障，如硬盘被损坏，那么之前提交的数据则有可能会丢失。\n# 事务的并发问题\n脏读（Dirty read）\n当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是 “脏数据”，依据 “脏数据” 所做的操作可能是不正确的。\n\n不可重复读\n（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。\n\n幻读\n（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n\n不可重复度和幻读区别：\n不可重复读的重点是修改，幻读的重点在于新增或者删除。\n解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表\n例 1（同样的条件，你读取过的数据，再次读取出来发现值不一样了 ）：事务 1 中的 A 先生读取自己的工资为 1000 的操作还没完成，事务 2 中的 B 先生就修改了 A 的工资为 2000，导 致 A 再读自己的工资时工资变为 2000；这就是不可重复读。\n例 2（同样的条件，第 1 次和第 2 次读出来的记录数不一样 ）：假某工资单表中工资大于 3000 的有 4 人，事务 1 读取了所有工资大于 3000 的人，共查到 4 条记录，这时事务 2 又插入了一条工资大于 3000 的记录，事务 1 再次读取时查到的记录就变为了 5 条，这样就导致了幻读\n# 事务的隔离级别\n事务的隔离级别用于决定如何控制并发用户读写数据的操作。数据库是允许多用户并发访问的，如果多个用户同时开启事务并对同一数据进行读写操作的话，有可能会出现脏读、不可重复读和幻读问题，所以 MySQL 中提供了四种隔离级别来解决上述问题。\n事务的隔离级别从低到高依次为 READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 以及 SERIALIZABLE，隔离级别越低，越能支持高并发的数据库操作。\n​      \n# spring 中可以使用如下方式实现事务的控制\n1 编程式 (不推荐)\n2 声明式 (掌握)\n​\t1) 注解 (简单，必会)\n​\t2) XML 配置 (繁琐，了解)\nSpring 声明式事务的实现方式，底层就是 AOP,AOP 的底层就是动态代理\nSpring 事务管理相关的 API\n事务管理器接口: PlatformTransactionManager  针对不同的框架，提供了不同的实现类\n\n注解方式实现事务控制\n在 applicationContext.xml 配置事务相关的配置\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:c=\"http://www.springframework.org/schema/c\"\n       xmlns:util=\"http://www.springframework.org/schema/util\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/util\n       http://www.springframework.org/schema/util/spring-util.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/aop\n       http://www.springframework.org/schema/aop/spring-aop.xsd\n       http://www.springframework.org/schema/tx\n       http://www.springframework.org/schema/tx/spring-tx.xsd\n\">\n    &lt;!--spring 注解扫描-->\n    &lt;context:component-scan base-package=\"com.msb\"/>\n    &lt;!--读取jdbc配置文件-->\n    &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/>\n    &lt;!--配置德鲁伊连接池-->\n    &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        &lt;property name=\"username\" value=\"$&#123;jdbc_username&#125;\">&lt;/property>\n        &lt;property name=\"password\" value=\"$&#123;jdbc_password&#125;\">&lt;/property>\n        &lt;property name=\"url\" value=\"$&#123;jdbc_url&#125;\">&lt;/property>\n        &lt;property name=\"driverClassName\" value=\"$&#123;jdbc_driver&#125;\">&lt;/property>\n    &lt;/bean>\n    &lt;!--配置JDBCTemplate对象,并向里面注入DataSource-->\n    &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        &lt;!--通过set方法注入连接池-->\n        &lt;property name=\"dataSource\" ref=\"dataSource\">&lt;/property>\n    &lt;/bean>\n    &lt;!--配置一个事务管理器-->\n    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        &lt;!--将数据源注入事务管理器-->\n        &lt;property name=\"dataSource\"  ref=\"dataSource\">&lt;/property>\n    &lt;/bean>\n    &lt;!--开启事务注解-->\n    &lt;tx:annotation-driven transaction-manager=\"transactionManager\"/>\n&lt;/beans>\n@Service\n//@Transactional //加在类上,代表类中的所有方法都添加了事务控制\npublic class AccountServiceImpl implements AccountService &#123;\n    @Autowired\n    private AccountDao accountDao;\n    @Override\n    @Transactional// 放在方法上,就是仅仅对当前方法增加了事务控制\n    public int transMoney(int from, int to, int money) &#123;\n        int rows=0;\n        rows+=accountDao.transMoney(from, 0 - money);\n        int i =1/0;\n        rows+=accountDao.transMoney(to, money);\n        return rows;\n    &#125;\n&#125;\n再次测试，就算是 service 方法运行出现异常，自动会回滚，如果没有，那么自动提交\n@Transactional 注解的一些参数和参数的含义\n @Transactional (propagation = Propagation.REQUIRED,isolation = Isolation.READ_UNCOMMITTED,readOnly = true,rollbackFor = ClassCastException.class,noRollbackFor = NullPointerException.class,timeout = 10)\n@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface Transactional &#123;\n    @AliasFor(\"transactionManager\")\n    String value() default \"\";\n    @AliasFor(\"value\")\n    String transactionManager() default \"\";\n    String[] label() default &#123;&#125;;\n    Propagation propagation() default Propagation.REQUIRED;\n    Isolation isolation() default Isolation.DEFAULT;\n    int timeout() default -1;\n    String timeoutString() default \"\";\n    boolean readOnly() default false;\n    Class&lt;? extends Throwable>[] rollbackFor() default &#123;&#125;;\n    String[] rollbackForClassName() default &#123;&#125;;\n    Class&lt;? extends Throwable>[] noRollbackFor() default &#123;&#125;;\n    String[] noRollbackForClassName() default &#123;&#125;;\n&#125;\n# propagation  事务的传播行为 (面试)\n多事务方法之间调用，事务是如何管理的\n\n\n\n事务传播行为类型\n说明\n\n\n\n\nPROPAGATION_REQUIRED\n如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择 (默认)。\n\n\nPROPAGATION_SUPPORTS\n支持当前事务，如果当前没有事务，就以非事务方式执行。\n\n\nPROPAGATION_MANDATORY\n使用当前的事务，如果当前没有事务，就抛出异常。\n\n\nPROPAGATION_REQUIRES_NEW\n新建事务，如果当前存在事务，把当前事务挂起。\n\n\nPROPAGATION_NOT_SUPPORTED\n以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n\n\nPROPAGATION_NEVER\n以非事务方式执行，如果当前存在事务，则抛出异常。\n\n\nPROPAGATION_NESTED\n如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。\n\n\n\n如果 service 层  add 方法调用了 addDept 和 addEmp 两个方法\nPROPAGATION_REQUIRED\n 如果 add 方法有事务，那么 addDept 和 addEmp 就加入到 add 方法里的事务\n如果 add 方法没有事务，那么就新建一个事务，将 addDept 和 addEmp 加入到这个新的事务中\nPROPAGATION_REQUIRES_NEW\n 无论 add 是否有事务，都建立一个新的事务，所有的方法都加入到新的事务中，add 原来的事务就不用了\nisolation 事务的隔离级别\n\n\nDEFAULT （默认）\n这是一个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与 JDBC 的隔离级别相对应。\nMySQL 默认 REPEATABLE_READ\nOracle 默认 READ_COMMITTED\n\n\nREAD_UNCOMMITTED （读未提交）\n这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。\n\n\nREAD_COMMITTED （读已提交）\n保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。\n\n\nREPEATABLE_READ （可重复读）\n这种事务隔离级别可以防止脏读、不可重复读，但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读。\n\n\nSERIALIZABLE（串行化）\n这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。除了防止脏读、不可重复读外，还避免了幻像读。\n\n\ntimeout 超时时间\n事务一定要在多长时间之内提交，如果不提交就会回滚\nreadOnly 只读事务\n事务是否只能读取数据库的数据，如果为 true, 则不允许进行增删改\nrollbackFor 指定发生回滚的异常\n当方法发生哪些异常时才会回滚\nnoRollbackFor 指定不发生回滚的异常\n当方法发生哪些异常时，不会回滚\n# 面试题\n# spring 的循环依赖是什么？怎么解决？\n循环依赖：\n​\t指循环引用，是两个或多个 Bean 之间相互持有对方的引用\n三种依赖方式：\n​\t1、A 依赖 B ,B 依赖 A \t   \t\t\t\t\t——&gt; 直接依赖\n​\t2、A 依赖 C，C 依赖 B，B 依赖 A\t   ——&gt; 间接依赖\n​\t3、A 依赖 A \t\t\t\t\t\t\t\t\t\t\t——&gt; 自我依赖\n为什么会产生这个问题呢？\n​\t因为我们的 Spring 其中一大特点就是 Spring IOC 、DI，Spring 会自动帮我们创建对象和对对象赋值，而一旦产生循环依赖问题就会导致我们初始化的时候陷入阻塞状态，最终导致 Spring 容器都无法启动\n解决办法\n\n\n\n\n\n\n\n\n\n​\t使用缓存，缓存就是将所有缓存好的 Bean，全部放在一个容器中缓存起来，并且呢，将已经完全实例化，但是没有完成赋值的 Bean 标记起来。然后呢，再 Bean 第一次实例化完成后，在扫描一次容器将没有完成赋值的 Bean 的属性完成赋值就可以了。(@Autowriter 的对象)\n目前循环依赖只在属性 set 注入且单例的情况下才能解决\n# 解决循环依赖问题一定要使用二级缓存吗？\n不一定，但是为什么又要设计二级缓存？假设我们只有一个缓存容器，并且缓存是直接开放给用户可以调用的，未完成赋值的 Bean 和已完成赋值的 Bean 全部放入一个容器的话，调用者就有可能会拿到未赋值的 Bean，这对于用户来说是没有意义的，可能会造成空指针异常。所以基于这样的考虑，Spring 将能够直接提供给用户使用的 Bean 放在了一级缓存中，这样的 Bean 称之为终态 Bean；将已经完成初始化，但还不能提供给用户使用的 Bean 放在了二级缓存，称之为临时 Bean。\n# 为什么在二级缓存的基础上还要创建三级缓存\nSpring 中的有很多的注入的 Bean 需要去创建代理的 Bean，但是不是所有的 Bean 都需要去实例化之后就立马要创建代理 Bean，是要等到 Bean 初始化之后，完成之后才能够去创建代理 Bean，因此的循环依赖呢 Spring 又不得不去提前的创建代理 Bean，如果不创建代理 Bean，注入原始的 Bean 就会产生错误。所以 Spring 设计三级缓存专门存储这些代理 Bean，但是每个代理 Bean 的 Bean 的创建规则他又不一样，因此呢，Spring 的三级缓存中并不是直接去保存代理 Bean 的引用，而是保存了创建代理 Bean 的 Factory\n# 什么是 Spring 三级缓存？\nsingletonObjects   \t\t \t\t&lt;ConCurrentHashMap&lt;&gt; \t  ——&gt;   \t 一级缓存\nearlySingletonObjects\t \t&lt;HashMap&lt;&gt;\t\t\t\t  \t\t\t——&gt;   \t 二级缓存\nsingletonFactories\t\t\t\t&lt;HashMap&lt;&gt;\t\t\t\t\t\t \t ——&gt;   \t 三级缓存\n一级缓存就是终态缓存；二级缓存就是临时缓存；三级缓存就是代理工厂的缓存\n\n# 什么情况下循环依赖无法解决？\n1、多实例 Bean 通过 set 注入无法解决\n2、构造器注入注入的 Bean 无法解决\n3、单里的代理 Bean 通过 set 注入无法解决\n4、设置 @DependsOn 注解的 Bean 注入无法解决\n# 后序补充…\n","slug":"Spring","date":"2022-10-06T16:00:00.000Z","categories_index":"Spring","tags_index":"框架,Spring","author_index":"雾都"},{"id":"af912e0d33a827f03582ef107fe8a87d","title":"SpringBoot","content":"# 简介\n# 原有 Spring 优缺点分析\n优点：\n\n\n\n\n\n\n\n\n\nSpring 是 Java 企业版（JAVAEE) 开发的一种相对简单的方法，通过依赖注入和面向切面编程，用简单 的 Java 对象实现了 EJB==(Enterprise Java Beans 技术的简称，又被称为企业 Java Beans)== 的功能\n缺点：\n\n虽然 Spring 的组件代码是轻量级的，但它的配置却是重量级的\n依赖管理也是一件耗时耗力的事情，会产生版本不兼容的问题\n\n# SpringBoot 概念简介\n\n\n\n\n\n\n\n\n\nSpring Boot 是 Spring 公司的一个顶级项目，和 Spring Framework 是一个级别的。\nSpring Boot 实际上是利用 Spring Framework 4 自动配置特性完成。编写项目时不需要编写 xml 文件。发展到现在，Spring Boot 已经具有很很大的生态圈，各种主流技术已经都提供了 Spring Boot 的启动器。\n# 什么是启动器\n\n\n\n\n\n\n\n\n\nSpring 框架在项目中作用是 Spring 整合各种其他技术，让其他技术使用更加方便。Spring Boot 的启动器实际上就是一个依赖。这个依赖中包含了整个这个技术的相关 jar 包，还包含了这个技术的自动配置，以前绝大多数 XML 配置都不需要配置了。当然了，启动器中自动配置无法实现所有内容的自动配置，在使用 Spring Boot 时还需要进行少量的配置（这个配置不是在 xml 中了，而是在 properties 或 yml 中即可）。如果是 Spring 自己封装的启动器的 artifact id 名字满足：spring-boot-starter-xxxx，如果是第三方公司提供的启动满足：xxxx-spring-boot-starter。以后每次使用 Spring Boot 整合其他技术时首先需要考虑导入启动器。\n# Spring Boot 优点\n①　使用 Spring Boot 可以创建独立的 Spring 应用程序\n②　在 Spring Boot 中直接嵌入了 Tomcat、Jetty、Undertow 等 Web  容器，在使用 SpringBoot 做 Web 开发时不需要部署 WAR 文件\n③　通过提供自己的启动器 (Starter) 依赖，简化项目构建配置\n④　尽量的自动配置 Spring 和第三方库\n⑤　绝对没有代码生成，也不需要 XML 配置文件\n# Spring Boot 的核心\n起步依赖：起步依赖本质上是一个 Maven 项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。\n自动配置 ：Spring Boot 的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定 Spring 配置应该用哪个，不该用哪个。该过程是 Spring 自动完成的。\n# 启动原理分析\n\nstatic class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;\n        register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));\n    &#125;\n    @Override\n    public Set&lt;Object> determineImports(AnnotationMetadata metadata) &#123;\n        return Collections.singleton(new PackageImports(metadata));\n    &#125;\n&#125;\n将配置类 @SpringBootApplication 标注的类所在包及下面所有子包里的所有组件扫描到 spring 容器\nprotected List&lt;String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;\n\t\tList&lt;String> configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),\n\t\t\t\tgetBeanClassLoader());\n\t\tAssert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \"\n\t\t\t\t+ \"are using a custom packaging, make sure that file is correct.\");\n\t\treturn configurations;\n\t&#125;\n通过 getCandidateConfigurations 读取自带的配置文件，得到他们的全路径名，通过反射创建他们\n# 异常处理和拦截器\n均与 SpringMVC 中处理一致\n# 分页\n主要参数：\n当前页 、一页 n 个 (每页的数量)、 总条数\n# 属性介绍\n\n\n\n属性名\n类型\n默认值\n描述\n\n\n\n\noverflow\nboolean\nfalse\n溢出总页数后是否进行处理(默认不处理，参见  插件#continuePage  方法)\n\n\nmaxLimit\nLong\n\n单页分页条数限制(默认无限制，参见  插件#handlerLimit  方法)\n\n\ndbType\nDbType\n\n数据库类型(根据类型获取应使用的分页方言，参见  插件#findIDialect  方法)\n\n\ndialect\nIDialect\n\n方言实现类(参见  插件#findIDialect  方法)\n\n\n\n\n\n\n\n\n\n\n\n\n建议单一数据库类型的均设置 dbType\n@GetMapping(\"/test\")\n   public Response test()&#123;\n       Page&lt;Produce> producePage = new Page&lt;>(1,1);\n       Page&lt;Produce> page = produceService.page(producePage);\n       System.out.println(producePage == page);\n       List&lt;Produce> records = page.getRecords();\n       for (Produce record : records) &#123;\n           System.out.println(record);\n       &#125;\n       return new Response&lt;>(records, ResultEnum.SUCCESS);\n   &#125;\n\n\n默认是会查询总条数，都有 get、set 方法，可以根据自己的需求设置（点开 Page 类看看）\n\n# 项目打包和部署\n# 打包\nSpringBoot 项目打包在 linux 服务器中运行:\n①jar 类型项目会打成 jar 包:\njar 类型项目使用 SpringBoot 打包插件打包时，会在打成的 jar 中内置一个 tomcat 的 jar。所以我们可以使用 jdk 直接运行该 jar 项目可，jar 项目中有一个功能，将功能代码放到其内置的 tomcat 中运行。我们直接使用浏览器访问即可。\n②war 类型项目会打成 war 包:\n 在打包时需要将内置的 tomcat 插件排除，配置 servlet 的依赖。将 war 正常的放到 tomcat 服务器中运行即可。\n\n# 部署\n注：这里是部署到 Tomcat（war），jar 直接编译启动\n# 第一步：\n在部署到Tomcat 之前我们要将我们项目中的Tomcat(==它在Web中==)去掉，但是我们在项目中又有可能要使用他提供的jar包 HttpServlet 之类的，所以我们还需要再将它手动导入，但是他不需要他打包。\n\n&lt;!--配置SpringBoot的web启动器-->\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n    &lt;!--排除web启动中自动依赖的tomcat插件-->\n    &lt;exclusions>\n        &lt;exclusion>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-tomcat&lt;/artifactId>\n        &lt;/exclusion>\n    &lt;/exclusions>\n&lt;/dependency>\n\n&lt;!--\n    手动依赖tomcat插件，但是表明项目打包时该依赖不会被打进去，目的主要是保证开发阶段本地SpringBoot\n    项目可以正常运行\n-->\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-tomcat&lt;/artifactId>\n    &lt;!--打包的时候可以不用包进去，别的设施会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。\n        相当于compile，但是打包阶段做了exclude操作-->\n    &lt;scope>provided&lt;/scope>\n&lt;/dependency>\n# 第二步：\nSpringBoot 的启动类继承 SpringBootServletInitializer，并重写 configure\n@SpringBootApplication\npublic class MyApplication extends SpringBootServletInitializer &#123;\n    //重写配置方法\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;\n        return application.sources(MyApplication.class);\n    &#125;\n    public static void main(String[] args) &#123;\n        //启动SpringBoot\n        SpringApplication.run(MyApplication.class,args);\n    &#125;\n&#125;\n使用 package 命令打包项目，并将 war 包放到 tomcat 下的 webapps 下，启动 tomcat 即可。\n# 注：\n\n部署到 tomcat 之后我们的 URL 就会变化，tomcat 会自动编译 war 包，我们的项目名和 war 包同名，所以不想改变提前修改\n端口号也是 tomcat 的端口号（tomcat/conf/server.xml）\n\n# 面试题\n# SpringBoot 约定大于配置理解\n约定大于配置是一种开发原则，就是减少人为的配置，直接用默认的配置就能获得我们想要的结果。\n　　SpringBoot 的约定大于配置，按我的理解是：对比 SpringMVC，需要在 web.xml 里面配置前端控制器，还需要在核心配置文件（*-servlet.xml）中配置视图解析器啥的，更要配置第三方的 Tomcat 服务器。而 SpringBoot 就不需要我们配置这些，他内嵌了 Tomcat 服务器，我们只需要在 Maven 配置文件（Pom.xml）里面导入 SpringMVC 所需要的依赖就可以了。\n　　这就是 SpringBoot 的优势，在传统所需要配置的地方，SpringBoot 都进行了约定（配置好了），开发人员能配置得更少，更直接地开发项目，写业务逻辑代码。\nspring boot 和 maven 的约定大于配置体现 点：\n　　1.maven 的目录文件结构\n　　1）默认有 resources 文件夹，存放资源配置文件。src-main-resources,src-main-java\n 默认的编译生成的类都在 targetwen。\n　　2）默认有 target 文件夹，将生成 class 文件盒编程生成的 jar 存放在 target 文件夹下\n2.spring boot 默认的配置文件必须是，也只能是 application. 命名的 yml 文件或者 properties 文件，且唯一\n1）spring boot 默认只会去 src-main-resources 文件夹下去找 application 配置文件\n这个问题呢，我从四个方面来回答。\n首先，约定优于配置是一种软件设计的范式，它的核心思想，是减少软件开发人员对于配置项的。从而让开发人员更加聚焦在业务逻辑上\n第二个呢，Spring boot 就是约定优于配置这一理念下的产物，它类似于 spring 框架下的一个脚手架，通过 spring boot，我们可以快速开发基于 spring 生态下的应用程序。基于传统的 spring 框架开发 web 应用的时候，我们需要做很多和业务无关，并且只需要做一次的配置项，比如\n\n\n管理架包的依赖\n\n\nweb.xml 的维护\n\n\nspring MVC 中的一个叫 Dispatch-Servlet.x ml 配置项的一个维护\n\n\n应用需要自己手动去部署到 web 容器\n\n\n第三方组件集成到 spring IOC 容器中，我们需要做配置项的维护\n\n\n而在 SpringBoot 中，我们不再需要去做这些繁琐的配置，因为 SpringBoot 已经帮我们自动完成了，而完成这样一个动作的前提就是基于约定优于配置这样一个思想。\n最后呢，Spring boot 约定优于配置的体现有很多，\n比如第一个 spring boat start 启动依赖，它能够帮助我们管理所有的 jar 包版本。\n第二个，如果当前的应用依赖了 web 这样一个 jar 包，那么 spring boot 会自动内置 Tomcat，他们看着容器来去运行 web 应用，我们不再需要去单独进行应用部署。\n第三，Spring boot 的自动装配机制的实现中，通过扫描约定路径下的 spring.factory 文件去进行识别配置类，从而去实现类的自动装载\n第四，Spring boot？默认会加载 resource 目录下的 application.property 文件。总的来说啊，约定优于配置呢，是一个比较常见的软件设计思想，它的核心本质都是为了去更加高效，以及更加便捷的去实现软件系统的开发和维护。\n自我总结：\n​\t约定大于配置，不是说我们要设定啥，原来规定的是什么就不能改变，不是这个意思。他真正的意思是说当我们配置某个选项时，springboot 会自动帮我们加载可能会与其相关的配置，就好比我们应用依赖了 web，那么 spring boot 会自动内置 Tomcat，他们看着容器来去运行 web 应用，我们不再需要去单独进行应用部署。\n​\t总的来说啊，约定优于配置呢，是一个比较常见的软件设计思想，它的核心本质都是为了去更加高效，以及更加便捷的去实现软件系统的开发和维护。\n","slug":"SpringBoot","date":"2022-10-06T16:00:00.000Z","categories_index":"Spring,SpringBoot","tags_index":"框架,Spring,SpringBoot","author_index":"雾都"},{"id":"cd53cdbf97b8f99c953dd3eda45eed25","title":"SpringMVC","content":"# 简介\n\nM   model      模型层   DAO 封装        &gt;&gt;&gt; Mybatis\nV    view         视图层   html css js  jsp\nC    controller 控制层   Servlet 封装    &gt;&gt;&gt; springMVC\nSpringMVC 是 spring 为展现层提供的基于 MVC 设计理念的优秀 WEB 框架，是目前最主流的 MVC 框架之一\n SpringMVC 通过一套注解，可以让普通的 JAVA 类成为 contrllor 控制器，无需继承 Servlet, 实现了控制层和 Servlet 之间的解耦\n SpringMVC 支持 Rest 风格的 URL 写法\n SpringMVC 采用了松耦合，可热插的主键结构，比其他的框架更具扩展性和灵活性\n# 执行流程\n\n\n1DispatcherServlet：前端控制器\n用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。\n2 HandlerMapping：处理器映射器\n HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。\n3 Handler：处理器 (自己定义的 Controller 处理单元)\n 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。\n4 HandlAdapter：处理器适配器\n通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行\n5 View Resolver：视图解析器\n View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名 即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。\n6 View：视图\n SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView 等。我们最常用的视图就是 jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开 发具体的页面。\n7 mvc:annotation-driven 说明\n在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。\n使 用 mvc:annotation-driven 自动加载 RequestMappingHandlerMapping （处理映射器） 和 RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用 mvc:annotation-driven 替代注解处理器和适配器的配置。\nHandlerMapping 的实现类的作用\n实现类 RequestMappingHandlerMapping，它会处理 @RequestMapping 注解，并将其注册到请求映射表中。\nHandlerAdapter 的实现类的作用\n实现类 RequestMappingHandlerAdapter，则是处理请求的适配器，确定调用哪个类的哪个方法，并且构造方法参数，返回值。\n当配置了 mvc:annotation-driven / 后，Spring 就知道了我们启用注解驱动。然后 Spring 通过 context:component-scan / 标签的配置，会自动为我们将扫描到的 @Component，@Controller，@Service，@Repository 等注解标记的组件注册到工厂中，来处理我们的请求，这个时候接收返回 json 数据、参数验证、统一异常等功能。\n# 重要注解\n# 1、RequestMapping\n紧耦合方式 (了解)\n DispatcherServlet 中的 service 方法直接将此次请求的 request 对象传递给调用的单元方法即可。同时在单元方法上声明形参 HttpServletRequest 来接收 request 实参即可。\n解耦合方式 (熟练)\n DispatcherServlet 在其 service 方法中将请求数据根据需求从 request 对象中获取出来后，将数据直接传递给对应的单元方法使用。同时在单元方法上直接声明对应的形参接收请求数据即可。在单元方法上声明形参来接收请求数据时，形参名必须和请求数据的键名一致，DispatcherServlet 会将调用单元方法的形参名作为请求数据的键名获取请求数据，然后传递给单元方法。\n@RestController\npublic class TestDataController &#123;\n    /*紧耦合方式参数注入\n    * 使用传统的HttpServletRequest对象获取参数  javax.servlet\n    * */\n    @RequestMapping(\"/getParamByRequest.do\")\n    public String getParam1(HttpServletRequest req, HttpServletResponse resp)&#123;\n        String username = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        System.out.println(\"username:\"+username+\"   password:\"+password);\n        return \"getParamSuccess\";\n    &#125;\n    /*解耦合方式参数注入\n    * HttpServletRequest对象获取参数 通过SpringMVC框架功能,自动转换参数\n    * 处理单元参数列表中参数名必须和请求中的参数名一致\n                                        * 如不一致,可以通过@RequestParma注解进行转换\n    * */\n    @RequestMapping(\"/getParamByArgName.do\")\n    public String getParam2(String username,@RequestParam(\"pwd\") int password)&#123;\n        System.out.println(\"username:\"+username+\"   password:\"+password);\n        return \"getParamSuccess\";\n    &#125;\n&#125;\n# 2、PathVariable 注解和 RESTful 风格的支持\n普通形式的 url\n*/contextPath/aaa.do\n*/contextPath/aaa.jsp\n*/contextPath/aaa.html\n*/contextPath/css/aaa.css\n*/contextPath/js/aaa.js\n*/contextPath/aaa.do?id=10&amp;username=root\nrestFul 风格的 url\n*/contextPath/aaa/10/root\n*/contextPath/aaa\n@Controller\npublic class PathController &#123;\n    @RequestMapping(\"/testPathVariable/&#123;id&#125;/&#123;username&#125;\")\n    public String testPathVariable(@PathVariable(\"id\") Integer id, @PathVariable(\"username\") String username)&#123;\n        System.out.println(\"id:\"+id);\n        System.out.println(\"username:\"+username);\n        System.out.println(\"testPathVariable1\");\n        return \"success\";\n    &#125;\n&#125;\n\n\n# 响应处理\n\n1、单元方法返回值为 void\n\n\n\n\n\n\n\n\n\n\n在 SpringMVC 中如果对于当前的控制单元，没有写对应的返回值，这个时候 SpringMVC 就会找和自己控制单元名称一致的页面展示，如果没有配置视图解析器的前缀和后缀是没有产生 404, 需要注意控制单元仍然可以进。\n2、转发和重定向 ServletAPI 实现\n@RequestMapping(\"demo1\")\n    public void testDemo1(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n        // 请求转发\n        //request.getRequestDispatcher(\"/forward.jsp\").forward(request,response);\n        // 响应重定向\n        response.sendRedirect(request.getContextPath()+\"/redirect.jsp\");\n    &#125;\n\n\n\n\n\n\n\n\n\n单元方法的返回值类型设置 void。因为使用 response 对象在单元方法中直接对此次请求进行了响应，不再通过 DispatcherServlet 了，既然已经响应了，就不需要再给 DispatcherServlet 返回值了。在单元方法上声明 HttpServletResponse 形参，来接收此次请求的 response 对象。\n3、使用 forward 关键字完成响应\n/*\n   * 返回字符串告诉DispatcherServlet跳转的路径\n   * 在路径之前放上一个forward: 关键字,就是请求转发\n   * 如果路径前的关键字是forward,那么可以省略不写\n   * */\n   @RequestMapping(\"demo2\")\n   public String testDemo2() throws Exception &#123;\n       //return \"forward:/forwardPage.jsp\";\n       return \"/forwardPage.jsp\";\n   &#125;\n使用通过单元方法的返回值来告诉 DispatcherServlet 请求转发指定的资源，如果是请求转发，forward 关键字可以省略不写的\n4、使用 redirect 关键字完成响应\n/*\n     * 返回字符串告诉DispatcherServlet跳转的路径\n     * 在路径之前放上一个redirect: 关键字,就是重定向\n     * 如果路径前的关键字是redirect,那么不可以省略\n     * /表示当前项目下.这里不需要项目的上下文路径\n     * */\n    @RequestMapping(\"demo3\")\n    public String testDemo3() throws Exception &#123;\n        return \"redirect:/redirectPage.jsp\";\n    &#125;\n使用通过单元方法的返回值来告诉 DispatcherServlet 重定向指定的资源，注意这个 redirect 关键字不可以省去\n5、使用 View 视图转发和重定向\n@RequestMapping(\"demo4\")\n   public View testDemo4(HttpServletRequest req)   &#123;\n       View  view =null;\n       // 请求转发\n       //view =new InternalResourceView(\"/forwardPage.jsp\");\n       // 重定向\n       view=new RedirectView(req.getContextPath()+\"/redirectPage.jsp\");\n       return view;\n   &#125;\n\n\n\n\n\n\n\n\n\nRedirectView 中所做的操作，最终的实现是在 renderMergedOutputModel 中完成实现的，简单来说 RedirectView 实现了链接的重定向，并且将数据保存到 FlashMap 中，这样在跳转后的链接中可以获取一些数据.\n6、使用 ModelAndView 转发重定向\n@RequestMapping(\"demo5\")\n    public ModelAndView testDemo5(HttpServletRequest req)   &#123;\n        ModelAndView mv=new ModelAndView();\n        // 请求转发\n        //mv.setViewName(\"forward:/forwardPage.jsp\");\n        //mv.setView(new InternalResourceView(\"/forwardPage.jsp\"));\n        // 重定向\n        //mv.setViewName(\"redirect:/redirectPage.jsp\");\n        mv.setView(new RedirectView(req.getContextPath()+\"/redirectPage.jsp\"));\n        return mv;\n    &#125;\n​\tModelAndView 中的 Model 代表模型，View 代表视图，这个名字就很好地解释了该类的作用。业务处理器调用模型层处理完用户请求后，把结果数据存储在该类的 model 属性中，把要返回的视图信息存储在该类的 view 属性中，然后让该 ModelAndView 返回该 Spring MVC 框架。\n# 作用域传参\n\n\n\n\n\n\n\n\n\n\nPageContext 对象\n作用域范围：当前 jsp 页面内有效\n\n\n\n\n\n\n\n\n\nrequest 对象\n作用域范围：一次请求内。\n作用：解决了一次请求内的资源的数据共享问题\n\n\n\n\n\n\n\n\n\nsession 对象\n作用域范围：一次会话内有效。\n说明：浏览器不关闭，并且后台的 session 不失效，在任意请求中都可以获取到同一个 session 对象。\n作用：解决了一个用户不同请求的数据共享问题。\n\n\n\n\n\n\n\n\n\napplication (ServletContext) 对象\n作用域范围：整个项目内有效。\n特点：一个项目只有一个，在服务器启动的时候即完成初始化创建无论如何获取都是同一个项目。\n作用：解决了不同用户的数据共享问题。\n# 拦截器\n# 引入\n\n\n\n\n\n\n\n\n\n过滤器的作用是保护请求的服务器资源，在请求资源被执行之前，如果请求地址符合拦截范围，则会先执行过滤器。过滤器的执行时机，是在 Servlet 之前执行的。但是在使用了 SpringMVC 后，Servlet 只有一个了，也就是 DisptcherServlet。那么，如果我们仍然使用过滤器来完成请求的拦截，因为过滤器是在 Servlet 之前执行的，就会造成，过滤器会拦截 DispatcherServlet 所有的请求。那么，如果我们有部分请求不想被拦截，怎么办？\n# 拦截器使用\n\nSpring MVC 中的拦截器（Interceptor）类似于 Servlet 中的过滤器（Filter），它主要用于拦截用户请求并作相应的处理。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。\n要使用 Spring MVC 中的拦截器，就需要对拦截器类进行定义和配置。通常拦截器类可以通过两种方式来定义。\n1. 通过实现 HandlerInterceptor 接口，或继承 HandlerInterceptor 接口的实现类（如 HandlerInterceptorAdapter）来定义。\n2. 通过实现 WebRequestInterceptor 接口，或继承 WebRequestInterceptor 接口的实现类来定义。\n# 拦截器和过滤器的区别\n\n\n拦截器 SpringMVC 的，而过滤器是 servlet 的。\n\n\n拦截器不依赖与 servlet 容器，由 spring 容器初始化，过滤器依赖与 servlet 容器，由 servlet 容器初始化。.\n\n\n拦截器只能对 action 请求起作用，而过滤器则可以对几乎所有的请求起作用。\n\n\n拦截器可以访问 action 上下文、值栈里的对象，而过滤器不能访问。\n\n\n在 action 的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。\n\n\n拦截器可以获取 IOC 容器中的各个 bean，而过滤器就不太方便，这点很重要，在拦截器里注入一个 service，可以调用业务逻辑。\n\n\npublic class MyInterceptor implements HandlerInterceptor &#123;\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        /*在请求到达我们定义的handler之前工作的*/\n        System.out.println(\"MyInterceptor preHandle\");\n        /*返回的是true,代表放行,可以继续到达handler*/\n        return true;\n    &#125;\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n        System.out.println(\"MyInterceptor postHandle\");\n        /*handler 处理单元返回ModelAndView 时候进行 拦截*/\n    &#125;\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        /*\n        页面渲染完毕,但是还没有给浏览器响应数据的时候\n         */\n        System.out.println(\"MyInterceptor afterCompletion\");\n    &#125;\n&#125;\n# 多个拦截器执行顺序\n多个拦截器同时存在时，执行的顺序由配置顺序决定。先配置谁，谁就先执行。多个拦截器可以理解为拦截器栈，先进后出 (后进先出), 如图所示:\n\n# 异常处理\n# SpringMVC 异常简介\n​\t系统中异常包括两类：预期异常 (检查型异常) 和运行时异常 RuntimeException，前者通过捕获异常从而获取异常信息， 后者主要通过规范代码开发、测试通过手段减少运行时异常的发生\n# 具体实现\n# 1 使用 @ExceptionHandler 注解处理异常\n缺点：只能处理当前 Controller 中的异常。\n@ExceptionHandler(value =&#123;ArithmeticException.class,NullPointerException.class&#125; )\n   public ModelAndView handelException()&#123;\n       ModelAndView mv =new ModelAndView();\n       mv.setViewName(\"error1.jsp\");\n       return mv;\n   &#125;\n# 2 使用：@ControllerAdvice+@ExceptionHandler\n此处优先级低于局部异常处理器\n@ControllerAdvice\npublic class GloableExceptionHandler1 &#123;\n    @ExceptionHandler(value =&#123;ArithmeticException.class,NullPointerException.class&#125; )\n    public ModelAndView handelException()&#123;\n        ModelAndView mv =new ModelAndView();\n        mv.setViewName(\"error1.jsp\");\n        return mv;\n    &#125;\n&#125;\n# 3 使用：SimpleMappingExceptionResolver\n/**\n * 全局异常\n */\n  @Configuration\n  public class GloableException2 &#123;\n    @Bean\n    public SimpleMappingExceptionResolver getSimpleMappingExceptionResolver()&#123;\n        SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver();\n        Properties prop = new Properties();\n        prop.put(\"java.lang.NullPointerException\",\"error1.jsp\");\n        prop.put(\"java.lang.ArithmeticException\",\"error2.jsp\");\n        resolver.setExceptionMappings(prop);\n        return resolver;\n    &#125;\n&#125;\n# 4 自定义的 HandlerExceptionResolver\n/**\n * 全局异常\n * HandlerExceptionResolve\n */\n  @Configuration\n  public class GloableException3 implements HandlerExceptionResolver &#123;\n    @Override\n    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123;\n        ModelAndView mv = new ModelAndView();\n        if(e instanceof NullPointerException)&#123;\n                mv.setViewName(\"error1\");\n        &#125;\n        if(e instanceof ArithmeticException)&#123;\n                mv.setViewName(\"error2\");\n        &#125;\n        mv.addObject(\"msg\",e);\n        return mv;\n    &#125;&#125;\n# 其他注解\n# @RequestBody\n作用：\n​\t用于获取请求体 json 格式的字符串内容。直接使用得到是 key=value&amp;key=value… 结构的数据，get 请求方式不适用。\n属性：\n​\trequired：是否必须有请求体。默认值是:true。当取值为 true 时，get 请求方式会报错。如果取值 为 false，get 请求得到是 null。\n# @CrossOrigin\n作用：\n​\t解决 ajax 请求之间的跨域问题\n属性:\norigins  ： 允许可访问的域列表 IP\nmaxAge：准备响应前的缓存持续的最大时间（以秒为单位）。\n","slug":"SpringMVC","date":"2022-10-06T16:00:00.000Z","categories_index":"Spring,SpringMVC","tags_index":"框架,Spring,SpringMVC","author_index":"雾都"},{"id":"acc58c8b616a5ba0b044984346d44fef","title":"第10章_常用类","content":"","slug":"第10章_常用类","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,常用类","tags_index":"JavaSE","author_index":"雾都"},{"id":"fceed54d2b78e915f81cbddb878dcc7f","title":"SpringSecurity","content":"\nSpring Security\n# 一、简介\n​\t\tSpring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架 Shiro，它提供了更丰富的功能，社区资源也比 Shiro 丰富。\n​\t一般来说中大型的项目都是使用 SpringSecurity 来做安全框架。小项目有 Shiro 的比较多，因为相比与 SpringSecurity，Shiro 的上手更加的简单。\n​\t 一般 Web 应用的需要进行认证和授权。\n​\t\t认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户\n​\t\t授权：经过认证后判断当前用户是否有权限进行某个操作\n​\t而认证和授权也是 SpringSecurity 作为安全框架的核心功能。\n# 二、第一个 Spring Security 项目\n# 1. 导入依赖\n​\tSpring Security 已经被 Spring boot 进行集成，使用时直接引入启动器即可。\n   &lt;properties>\n       &lt;java.version>1.8&lt;/java.version>\n       &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding>\n       &lt;project.reporting.outputEncoding>UTF-8&lt;/project.reporting.outputEncoding>\n       &lt;spring-boot.version>2.3.7.RELEASE&lt;/spring-boot.version>\n   &lt;/properties>\t\n\n&lt;dependencies>\n       &lt;!--thymeleaf-->\n       &lt;dependency>\n           &lt;groupId>org.springframework.boot&lt;/groupId>\n           &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId>\n       &lt;/dependency>\n       &lt;!--druid-->\n       &lt;dependency>\n           &lt;groupId>com.alibaba&lt;/groupId>\n           &lt;artifactId>druid-spring-boot-starter&lt;/artifactId>\n           &lt;version>1.2.8&lt;/version>\n       &lt;/dependency>\n       &lt;!--mysql-->\n       &lt;dependency>\n           &lt;groupId>mysql&lt;/groupId>\n           &lt;artifactId>mysql-connector-java&lt;/artifactId>\n       &lt;/dependency>\n       &lt;!--mybatis-plus-->\n       &lt;dependency>\n           &lt;groupId>com.baomidou&lt;/groupId>\n           &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId>\n           &lt;version>3.4.2&lt;/version>\n       &lt;/dependency>\n       &lt;!--redis依赖-->\n       &lt;dependency>\n           &lt;groupId>org.springframework.boot&lt;/groupId>\n           &lt;artifactId>spring-boot-starter-data-redis&lt;/artifactId>\n       &lt;/dependency>\n       &lt;!--fastjson依赖-->\n       &lt;dependency>\n           &lt;groupId>com.alibaba&lt;/groupId>\n           &lt;artifactId>fastjson&lt;/artifactId>\n           &lt;version>1.2.33&lt;/version>\n       &lt;/dependency>\n       &lt;!--jwt依赖-->\n       &lt;dependency>\n           &lt;groupId>io.jsonwebtoken&lt;/groupId>\n           &lt;artifactId>jjwt&lt;/artifactId>\n           &lt;version>0.9.0&lt;/version>\n       &lt;/dependency>\n       &lt;!--spring-security-->\n       &lt;dependency>\n           &lt;groupId>org.springframework.boot&lt;/groupId>\n           &lt;artifactId>spring-boot-starter-security&lt;/artifactId>\n       &lt;/dependency>\n       &lt;!--lombok-->\n       &lt;dependency>\n           &lt;groupId>org.projectlombok&lt;/groupId>\n           &lt;artifactId>lombok&lt;/artifactId>\n           &lt;optional>true&lt;/optional>\n       &lt;/dependency>\n       &lt;!--spring-web-->\n       &lt;dependency>\n           &lt;groupId>org.springframework.boot&lt;/groupId>\n           &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n       &lt;/dependency>\n       &lt;!--Spring test-->\n       &lt;dependency>\n           &lt;groupId>org.springframework.boot&lt;/groupId>\n           &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n           &lt;scope>test&lt;/scope>\n           &lt;exclusions>\n               &lt;exclusion>\n                   &lt;groupId>org.junit.vintage&lt;/groupId>\n                   &lt;artifactId>junit-vintage-engine&lt;/artifactId>\n               &lt;/exclusion>\n           &lt;/exclusions>\n       &lt;/dependency>\n   &lt;/dependencies>\n# 2. 写一个控制器\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController &#123;\n\n    @RequestMapping(\"/hello\")\n    public String hello()&#123;\n        return \"hello\";\n    &#125;\n&#125;\n\n# 3. 访问页面\n​\t导入 spring-boot-starter-security 启动器后，Spring Security 已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。\n​\t在项目中新建 login.html 页面后\n​\t在浏览器输入：http://localhost:8080/login.html 后会显示下面页面\n\n​\t默认的 username 为 user，password 打印在控制台中。当然了，每个人的显示的肯定和我的不一样。\n​\t\t在浏览器中输入账号和密码后会显示 login.html 页面内容。\n# 三、用户认证\n# 3.1 登陆校验流程\n\n# 3.2 原理初探\n​\t想要知道如何实现自己的登陆流程就必须要先知道入门案例中 SpringSecurity 的流程。\n# 3.2.1 SpringSecurity 完整流程\n​\tSpringSecurity 的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。\n\n​\t图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。\nUsernamePasswordAuthenticationFilter: 负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。\n**ExceptionTranslationFilter：** 处理过滤器链中抛出的任何 AccessDeniedException 和 AuthenticationException 。\n**FilterSecurityInterceptor：** 负责权限校验的过滤器。\n​\n​\t我们可以通过 Debug 查看当前系统中 SpringSecurity 过滤器链中有哪些过滤器及它们的顺序。\n\n# 3.2.2 认证流程详解\n\n概念速查:\nAuthentication 接口：它的实现类，表示当前访问系统的用户，封装了用户相关信息。\nAuthenticationManager 接口：定义了认证 Authentication 的方法\nUserDetailsService 接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。\nUserDetails 接口：提供核心用户信息。通过 UserDetailsService 根据用户名获取处理的用户信息要封装成 UserDetails 对象返回。然后将这些信息封装到 Authentication 对象中。\n# 3.3 实现方式\n\n前后端不分离，登录页面由自己提供 ——3.1 (不推荐)\n前后端分离，登录页面由前端提供     ——3.2 (推荐，后序我们其他授权和别的操作，均以这个为主)\n\n在第二部分的基础上，进行操作\n# 3.3.1 前后端不分离\n# 1 准备工作\n# application.yml\nspring:\n  application:\n    name: msb-spring-security\n  datasource:\n    druid:\n      url: jdbc:mysql://localhost:3306/mydb?characterEncoding=utf-8&amp;serverTimezone=UTC\n      username: root\n      password: root\n      driver-class-name: com.mysql.cj.jdbc.Driver\n\nmybatis-plus:\n  mapper-locations: classpath:mapper/*.xml\nlogging:\n  level:\n    com:\n      zjj:\n        mapper: debug\nserver:\n  port: 8081\n# 数据库准备\n\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for sys_menu\n-- ----------------------------\nDROP TABLE IF EXISTS `sys_menu`;\nCREATE TABLE `sys_menu`  (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `menu_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'NULL' COMMENT '菜单名',\n  `path` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '路由地址',\n  `component` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '组件路径',\n  `visible` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '菜单状态（0显示 1隐藏）',\n  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '菜单状态（0正常 1停用）',\n  `perms` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '权限标识',\n  `icon` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '#' COMMENT '菜单图标',\n  `create_by` bigint(20) NULL DEFAULT NULL,\n  `create_time` datetime NULL DEFAULT NULL,\n  `update_by` bigint(20) NULL DEFAULT NULL,\n  `update_time` datetime NULL DEFAULT NULL,\n  `del_flag` int(11) NULL DEFAULT 0 COMMENT '是否删除（0未删除 1已删除）',\n  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '菜单表' ROW_FORMAT = Dynamic;\n\nDROP TABLE IF EXISTS `sys_role`;\nCREATE TABLE `sys_role`  (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,\n  `role_key` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '角色权限字符串',\n  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '角色状态（0正常 1停用）',\n  `del_flag` int(1) NULL DEFAULT 0 COMMENT 'del_flag',\n  `create_by` bigint(200) NULL DEFAULT NULL,\n  `create_time` datetime NULL DEFAULT NULL,\n  `update_by` bigint(200) NULL DEFAULT NULL,\n  `update_time` datetime NULL DEFAULT NULL,\n  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '角色表' ROW_FORMAT = Dynamic;\n\nDROP TABLE IF EXISTS `sys_role_menu`;\nCREATE TABLE `sys_role_menu`  (\n  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT '角色ID',\n  `menu_id` bigint(200) NOT NULL DEFAULT 0 COMMENT '菜单id',\n  PRIMARY KEY (`role_id`, `menu_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;\n\nDROP TABLE IF EXISTS `sys_user`;\nCREATE TABLE `sys_user`  (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `user_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'NULL' COMMENT '用户名',\n  `nick_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'NULL' COMMENT '昵称',\n  `password` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'NULL' COMMENT '密码',\n  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '账号状态（0正常 1停用）',\n  `email` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '邮箱',\n  `phonenumber` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '手机号',\n  `sex` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '用户性别（0男，1女，2未知）',\n  `avatar` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '头像',\n  `user_type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '1' COMMENT '用户类型（0管理员，1普通用户）',\n  `create_by` bigint(20) NULL DEFAULT NULL COMMENT '创建人的用户id',\n  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',\n  `update_by` bigint(20) NULL DEFAULT NULL COMMENT '更新人',\n  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',\n  `del_flag` int(11) NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '用户表' ROW_FORMAT = Dynamic;\n\n\nDROP TABLE IF EXISTS `sys_user_role`;\nCREATE TABLE `sys_user_role`  (\n  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT '用户id',\n  `role_id` bigint(200) NOT NULL DEFAULT 0 COMMENT '角色id',\n  PRIMARY KEY (`user_id`, `role_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;\n\n\n\nINSERT INTO `sys_menu` VALUES (2, 'demo:select', NULL, NULL, '0', '0', NULL, '#', NULL, NULL, NULL, NULL, 0, NULL);\nINSERT INTO `sys_menu` VALUES (3, 'demo:update', NULL, NULL, '0', '0', NULL, '#', NULL, NULL, NULL, NULL, 0, NULL);\nINSERT INTO `sys_menu` VALUES (4, 'demo:insert', NULL, NULL, '0', '0', NULL, '#', NULL, NULL, NULL, NULL, 0, NULL);\nINSERT INTO `sys_menu` VALUES (5, 'demo:delete', NULL, NULL, '0', '0', NULL, '#', NULL, NULL, NULL, NULL, 0, NULL);\n\nINSERT INTO `sys_role` VALUES (3, '管理员', NULL, '0', 0, NULL, NULL, NULL, NULL, NULL);\nINSERT INTO `sys_role` VALUES (4, '员工', NULL, '0', 0, NULL, NULL, NULL, NULL, NULL);\nINSERT INTO `sys_role` VALUES (5, '普通用户', NULL, '0', 0, NULL, NULL, NULL, NULL, NULL);\n\nINSERT INTO `sys_role_menu` VALUES (1, 1);\nINSERT INTO `sys_role_menu` VALUES (1, 2);\nINSERT INTO `sys_role_menu` VALUES (1, 3);\nINSERT INTO `sys_role_menu` VALUES (1, 4);\nINSERT INTO `sys_role_menu` VALUES (2, 1);\nINSERT INTO `sys_role_menu` VALUES (2, 4);\nINSERT INTO `sys_role_menu` VALUES (3, 1);\n\nINSERT INTO `sys_user` VALUES (1, 'zhangsan', 'zhangsan', '$2a$10$CFr1dsdBA3XDNrNRtsfX3ezUj/pUVsEhkg6cpKa9QG0oraGBMOZ5u', '0', '12@qq.com', '123', '1', NULL, '0', NULL, '2022-08-03 08:51:48', NULL, '2022-08-27 08:51:54', 0);\nINSERT INTO `sys_user` VALUES (2, 'lisi', 'lisi', '$2a$10$GRjbaR73zd9c9tCnj0BnnexqGSbQzXCVrXTPVEiOJqaypwCijbe4O', '0', '65.@126.com', '456', '0', NULL, '0', NULL, '2022-08-19 08:51:51', NULL, '2022-08-27 08:51:59', 0);\nINSERT INTO `sys_user` VALUES (3, 'wangwu', 'wangwu', '$2a$10$PsFb4a4bn0A.5pf4Rq5kheKaOkrhJOaz6hlu2WmBnkE8H9wZOoNXS', '0', NULL, NULL, NULL, NULL, '1', NULL, NULL, NULL, NULL, 0);\n\nINSERT INTO `sys_user_role` VALUES (1, 1);\nINSERT INTO `sys_user_role` VALUES (2, 2);\nINSERT INTO `sys_user_role` VALUES (3, 3);\n# 实体类 1\n​\t这里目前只提供了登录所需要的 User 对象，以及我们自己封装的 USerDetails 对象，其余对象自己后续生成。（easycode 、 mybatisX、… 都行）\npackage com.zjj.pojo;\n\nimport java.util.Date;\nimport com.baomidou.mybatisplus.extension.activerecord.Model;\nimport java.io.Serializable;\nimport lombok.*;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport com.baomidou.mybatisplus.annotation.TableField;\n\n/**\n * 用户表(User)表实体类\n *\n * @author makejava\n * @since 2022-08-24 21:09:13\n */\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@ToString\n@TableName(value = \"sys_user\")\npublic class User implements Serializable &#123;\n    /**\n    * 主键    \n    */ \n    @TableField(\"id\")\n    private Long id;\n    \n    /**\n    * 用户名    \n    */ \n    @TableField(\"user_name\")\n    private String username;\n    \n    /**\n    * 昵称    \n    */ \n    @TableField(\"nick_name\")\n    private String nickName;\n    \n    /**\n    * 密码    \n    */ \n    @TableField(\"password\")\n    private String password;\n    \n    /**\n    * 账号状态（0正常 1停用）    \n    */ \n    @TableField(\"status\")\n    private String status;\n    \n    /**\n    * 邮箱    \n    */ \n    @TableField(\"email\")\n    private String email;\n    \n    /**\n    * 手机号    \n    */ \n    @TableField(\"phonenumber\")\n    private String phonenumber;\n    \n    /**\n    * 用户性别（0男，1女，2未知）    \n    */ \n    @TableField(\"sex\")\n    private String sex;\n    \n    /**\n    * 头像    \n    */ \n    @TableField(\"avatar\")\n    private String avatar;\n    \n    /**\n    * 用户类型（0管理员，1普通用户）    \n    */ \n    @TableField(\"user_type\")\n    private String userType;\n    \n    /**\n    * 创建人的用户id    \n    */ \n    @TableField(\"create_by\")\n    private Long createBy;\n    \n    /**\n    * 创建时间    \n    */ \n    @TableField(\"create_time\")\n    private Date createTime;\n    \n    /**\n    * 更新人    \n    */ \n    @TableField(\"update_by\")\n    private Long updateBy;\n    \n    /**\n    * 更新时间    \n    */ \n    @TableField(\"update_time\")\n    private Date updateTime;\n    \n    /**\n    * 删除标志（0代表未删除，1代表已删除）    \n    */ \n    @TableField(\"del_flag\")\n    private Integer delFlag;\n    \n\n&#125;\n# 实体类 2\nimport com.alibaba.fastjson.annotation.JSONField;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@ToString\npublic class LoginUser implements UserDetails &#123;\n    private User user;\n\n    private List&lt;String> permission;\n\n    public LoginUser(User user, List&lt;String> permission) &#123;\n        this.user = user;\n        this.permission = permission;\n    &#125;\n\n    @JSONField(serialize = false) //redis存储的话会出现问题，不让他序列化，主要为了安全\n    List&lt;SimpleGrantedAuthority> authorities ;\n    @Override\n    public Collection&lt;? extends GrantedAuthority> getAuthorities() &#123;\n        // 把permission中的String类型的权限信息封装成 SimpleGrantedAuthority 对象\n        if (null != authorities) return authorities;//要是有信息就不用再授权了\n        authorities = permission.stream()\n                .map(SimpleGrantedAuthority::new)\n                .collect(Collectors.toList());\n        return authorities;\n    &#125;\n\n    @Override\n    public String getPassword() &#123;\n        return user.getPassword();\n    &#125;\n\n    @Override\n    public String getUsername() &#123;\n        return user.getUsername();\n    &#125;\n\n    @Override\n    public boolean isAccountNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isAccountNonLocked() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isCredentialsNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isEnabled() &#123;\n        return true;\n    &#125;\n&#125;\n# 2 重写一个登录服务 (ServiceImpl)\n​\t这里要实现一个实现 UserDetailsService ，重写 loadUserByUsername，因为这里是我们认证的地方，在下一个章节我们会具体说明\npackage com.zjj.service.impl;\n\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\nimport com.zjj.mapper.UserMapper;\nimport com.zjj.pojo.LoginUser;\nimport com.zjj.pojo.User;\nimport com.zjj.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * 用户表(User)表服务实现类\n * @author makejava\n * @since 2022-08-24 21:09:13\n */\n@Service(\"userService\")\npublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User>\n        implements UserService, UserDetailsService &#123;\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        LambdaQueryWrapper&lt;User> qw = new LambdaQueryWrapper&lt;>();\n        qw.eq(User::getUsername, username);\n        User user = userMapper.selectOne(qw);\n        if (Objects.isNull(user)) &#123;\n            throw new UsernameNotFoundException(\"没有该用户\");\n        &#125;\n\n        // TODO 权限信息后序添加\n        List&lt;String> menus = userMapper.findMenuByUserId(user.getId());\n        List&lt;String> roles = userMapper.findRoleByUserId(user.getId());\n        List&lt;String> res = new ArrayList&lt;>();\n\n        for (String menu : menus) &#123;\n            res.add(menu);\n        &#125;\n        for (String role : roles) &#123;\n            res.add(\"ROLE_\"+role);\n        &#125;\n        // 用户的权限和角色直接赋值 的话 要注意写法\n        /*\n        1、我们没有user对象直接往回 new UserDetails(username,password,Authorities) 对象时，\n            要注意Authorities手动String转化可以用 AuthorityUtils.commaSeparatedStringToAuthorityList(String str)\n                但是里面的 str里面包含了权限以及角色，每个要用 “,” 间隔，而且角色开头要要拼接 ROLE_\n\n        2、我们自定义了user 实现了 UserDetails 对象 我们重写了 getAuthorities属性，具体看这个类的注释\n            他在初始化值的时候我们传参传递的是一个list对象，这个时候我们不需要用 “，” 间隔，但是角色前要加 ROLE_\n         */\n        return new LoginUser(user,res);\n    &#125;\n&#125;\n# 3 重写 mapper 层和对应的映射文件\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.zjj.pojo.User;\nimport org.apache.ibatis.annotations.Mapper;\n\nimport java.util.List;\n\n/**\n * 用户表(User)表数据库访问层\n *\n * @author makejava\n * @since 2022-08-24 21:09:13\n */\n\n@Mapper\npublic interface UserMapper extends BaseMapper&lt;User> &#123;\n    public List&lt;String> findMenuByUserId(Long id);\n    public List&lt;String> findRoleByUserId(Long id);\n\n&#125;\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.zjj.mapper.UserMapper\">\n\n    &lt;sql id=\"AllUserColumn\">id , user_name , nick_name , password , status , email , phonenumber , sex , avatar , user_type , create_by , create_time , update_by , update_time , del_flag &lt;/sql>   \n    &lt;resultMap type=\"com.zjj.pojo.User\" id=\"UserMap\">\n        &lt;result property=\"id\" column=\"id\" />\n        &lt;result property=\"userName\" column=\"user_name\" />\n        &lt;result property=\"nickName\" column=\"nick_name\" />\n        &lt;result property=\"password\" column=\"password\" />\n        &lt;result property=\"status\" column=\"status\" />\n        &lt;result property=\"email\" column=\"email\" />\n        &lt;result property=\"phonenumber\" column=\"phonenumber\" />\n        &lt;result property=\"sex\" column=\"sex\" />\n        &lt;result property=\"avatar\" column=\"avatar\" />\n        &lt;result property=\"userType\" column=\"user_type\" />\n        &lt;result property=\"createBy\" column=\"create_by\" />\n        &lt;result property=\"createTime\" column=\"create_time\" />\n        &lt;result property=\"updateBy\" column=\"update_by\" />\n        &lt;result property=\"updateTime\" column=\"update_time\" />\n        &lt;result property=\"delFlag\" column=\"del_flag\" />\n    &lt;/resultMap>\n    &lt;select id=\"findMenuByUserId\" resultType=\"java.lang.String\">\n        SELECT\n            distinct(m.menu_name)\n        FROM\n            sys_user_role ur\n                LEFT JOIN sys_user u on u.id = ur.user_id\n                LEFT JOIN sys_role r ON ur.role_id = r.id\n                LEFT JOIN sys_role_menu rm ON ur.role_id = rm.role_id\n                LEFT JOIN sys_menu m ON m.id = rm.menu_id\n        WHERE\n            u.id = #&#123;args1&#125;\n          AND r.status = 0\n          AND m.status = 0\n    &lt;/select>\n    &lt;select id=\"findRoleByUserId\" resultType=\"java.lang.String\">\n        SELECT\n            distinct(r.name)\n        FROM\n            sys_user_role ur\n                LEFT JOIN sys_user u on u.id = ur.user_id\n                LEFT JOIN sys_role r ON ur.role_id = r.id\n                LEFT JOIN sys_role_menu rm ON ur.role_id = rm.role_id\n                LEFT JOIN sys_menu m ON m.id = rm.menu_id\n        WHERE\n            u.id = #&#123;args1&#125;\n          AND r.status = 0\n          AND m.status = 0\n    &lt;/select>\n    \n\n&lt;/mapper>\n# 4 导入我们的登录页面\n&lt;!DOCTYPE html>\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n    &lt;head>\n        &lt;meta charset=\"UTF-8\">\n        &lt;title>内容&lt;/title>\n    &lt;/head>\n    &lt;body>\n        &lt;form action=\"/login\" method=\"post\">\n            username:&lt;input type=\"text\" name=\"username\"/>&lt;br/>\n            password:&lt;input type=\"password\" name=\"password\"/>&lt;br/>\n            &lt;input type=\"submit\" value=\"提交\"/>\n        &lt;/form>\n\n    &lt;/body>\n&lt;/html>\n# 5 提供登录接口\n​\t就是一个页面的跳转指定我们的登录页面 (要配置的)\nimport com.zjj.pojo.User;\nimport com.zjj.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n@Controller\npublic class LoginController &#123;\n    @Autowired\n    private UserService userService;\n\n    @RequestMapping(\"/demo\")\n    @ResponseBody\n    public String demo() &#123;\n        return \"demo\";\n    &#125;\n\n    // 登录页面\n    @RequestMapping(\"/showLogin\")\n    public String logint() &#123;\n        System.out.println(\"logint invoked\");\n        return \"login\";\n    &#125;\n&#125;\n# 6 修改配置类\n​\t主要内容和细节，在 formLogin 里面，一定仔细查看注释，小细节很多\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\n@Configuration\npublic class MySecurityCore extends WebSecurityConfigurerAdapter &#123;\n    @Bean\n    public PasswordEncoder getPasswordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n\n        // http.formLogin() 所有和表单有关系的\n        http.formLogin()\n                // 登录页面，走一个controller\n                // 注意要和，LoginProcessingUrl 配合使用，不然在表单中的action中 url 失效\n                // 因为只配置loginPage()， 会导致在初始化的时候将loginProcessingUrl的配置相同化，可以自己debug 在AbstractAuthenticationFilterConfigurer 的 updateAuthenticationDefaults 方法\n                // 也就是说loginPage(\"/login\")  loginProcessingUrl(\"/login\"),导致提交信息失败最终导致认证失败\n                .loginPage(\"/showLogin\")\n                // 当发现什么URL时，把请求转发给自定义登录逻辑\n                // 表单提交的地址 action ,他就会直接去认证进入到 UserDetailsServiceImpl\n                // 去这里进行用户的验证 和 用户权限信息的集体封装\n                .loginProcessingUrl(\"/login\")\n                // 登录成功的操作\n                // 下面两种方法都可以，推荐第二种，两种同时写第一个直接失效\n                // 第一种写法，要注意在写映射的时候要注意请求的方法 get/post\n                .successForwardUrl(\"/showMain\")\n                .successHandler((request, response, authentication) -> &#123;\n                    System.out.println(\"successHandler invoked\");\n                    // 我们在每次请求同一个页面尽量使用重定向，要是请求转发\n                    // 因为请求转发是浏览器的行为，每次都要请求服务器并且重复提交表单，不好\n                    // response.sendRedirect(\"/fail\");\n                    LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n                    for (String s : loginUser.getPermission()) &#123;\n                        System.out.println(s);\n                    &#125;\n                &#125;)\n                // 登录失败的操作\n                // 内容和上述情况相同，只是一个成功的一个失败的\n                .failureForwardUrl(\"/fail\")\n                // 当前端表单传递过来的用户名参数、密码参数名和后端不对应，可以利用下列方法\n                // 指定前端传递过来的用户名参数名称，默认 username\n                //.usernameParameter(\"MyuserName\")\n                // 指定前端传递过来的密码参数名称，默认 password\n                //.passwordParameter(\"MypassWord\")\n        ;\n\n        // http.authorizeRequests() 所有和授权相关\n        http.authorizeRequests()\n                // 这里面支持 正则 和 ant表达式\n                .antMatchers(\"/showLogin\").anonymous()\n                .antMatchers(\"/js/**\").permitAll()\n                .anyRequest().authenticated();\n\n\n        // http.csrf\n        http.csrf().disable()\n                // 不通过Session获取SecurityContext\n                // 因为我们使用了前后端分离的思想，在session中不存在参数，要用让东西存在它里面，所以不让他生成\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n\n    &#125;\n&#125;\n# 7 启动测试\n这个时候我们的用户名、密码都是我们在数据库中存储的（密码必须使我们提供的加密方式加密之后的）\n\n登录是否成功，一方面看是否请求被阻拦\n\n另一方面，我在配置中设置了认证成功之后的操作 successHandler (request,response.authentication) 我在里面将我们获得认证的用户权限信息全部打印在了控制台，如果错误了也可同样配置一些信息，具体配置将在后序章节详细总结我们的配置类中的配置，现在主要目的是理清逻辑即可\n\n# 8 补充 —— 密码加密\n实际项目中我们不会把密码明文存储在数据库中。\n​\t默认使用的 PasswordEncoder 要求数据库中的密码格式为：{id} password 。它会根据 id 去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换 PasswordEncoder。\n​\t我们一般使用 SpringSecurity 为我们提供的 BCryptPasswordEncoder。\n​\t我们只需要使用把 BCryptPasswordEncoder 对象注入 Spring 容器中，SpringSecurity 就会使用该 PasswordEncoder 来进行密码校验。\n​\t我们可以定义一个 SpringSecurity 的配置类，SpringSecurity 要求这个配置类要继承 WebSecurityConfigurerAdapter。\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n    \n    @Bean\n    public PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n&#125;\n# 3.3.2  前后端分离\n# 1 准备工作\n数据库、实体类均和 3.3.1 中相同\napplication.yml\nspring:\n  application:\n    name: spring-security\n  datasource:\n    druid:\n      url: jdbc:mysql://localhost:3306/mydb?characterEncoding=utf-8&amp;serverTimezone=UTC\n      username: root\n      password: root\n      driver-class-name: com.mysql.cj.jdbc.Driver\n  redis:\n    host: localhost\n    port: 6379\nmybatis-plus:\n  mapper-locations: classpath:mapper/*.xml\nlogging:\n  level:\n    com:\n      zjj:\n        mapper: debug\n统一返回类\npackage com.zjj.common;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\n\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic class ResponseResult&lt;T> &#123;\n    /**\n     * 状态码\n     */\n    private Integer code;\n    /**\n     * 提示信息，如果有错误时，前端可以获取该字段进行提示\n     */\n    private String msg;\n    /**\n     * 查询到的结果数据，\n     */\n    private T data;\n\n    public ResponseResult(Integer code, String msg) &#123;\n        this.code = code;\n        this.msg = msg;\n    &#125;\n\n    public ResponseResult(Integer code, T data) &#123;\n        this.code = code;\n        this.data = data;\n    &#125;\n\n    public Integer getCode() &#123;\n        return code;\n    &#125;\n\n    public void setCode(Integer code) &#123;\n        this.code = code;\n    &#125;\n\n    public String getMsg() &#123;\n        return msg;\n    &#125;\n\n    public void setMsg(String msg) &#123;\n        this.msg = msg;\n    &#125;\n\n    public T getData() &#123;\n        return data;\n    &#125;\n\n    public void setData(T data) &#123;\n        this.data = data;\n    &#125;\n\n    public ResponseResult(Integer code, String msg, T data) &#123;\n        this.code = code;\n        this.msg = msg;\n        this.data = data;\n    &#125;\n&#125;\n工具类\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.serializer.SerializerFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport org.springframework.data.redis.serializer.RedisSerializer;\nimport org.springframework.data.redis.serializer.SerializationException;\nimport com.alibaba.fastjson.parser.ParserConfig;\nimport org.springframework.util.Assert;\nimport java.nio.charset.Charset;\n\n/**\n * Redis使用FastJson序列化\n * \n * @author sg\n */\npublic class FastJsonRedisSerializer&lt;T> implements RedisSerializer&lt;T>\n&#123;\n\n    public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\");\n\n    private Class&lt;T> clazz;\n\n    static\n    &#123;\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n    &#125;\n\n    public FastJsonRedisSerializer(Class&lt;T> clazz)\n    &#123;\n        super();\n        this.clazz = clazz;\n    &#125;\n\n    @Override\n    public byte[] serialize(T t) throws SerializationException\n    &#123;\n        if (t == null)\n        &#123;\n            return new byte[0];\n        &#125;\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\n    &#125;\n\n    @Override\n    public T deserialize(byte[] bytes) throws SerializationException\n    &#123;\n        if (bytes == null || bytes.length &lt;= 0)\n        &#123;\n            return null;\n        &#125;\n        String str = new String(bytes, DEFAULT_CHARSET);\n\n        return JSON.parseObject(str, clazz);\n    &#125;\n\n\n    protected JavaType getJavaType(Class&lt;?> clazz)\n    &#123;\n        return TypeFactory.defaultInstance().constructType(clazz);\n    &#125;\n&#125;\npackage com.zjj.util;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.JwtBuilder;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\n\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\nimport java.util.Date;\nimport java.util.UUID;\n\n/**\n * JWT工具类\n */\npublic class JwtUtil &#123;\n\n    //有效期为\n    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时\n    //设置秘钥明文\n    public static final String JWT_KEY = \"sangeng\";\n\n    public static String getUUID()&#123;\n        String token = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n        return token;\n    &#125;\n    \n    /**\n     * 生成jtw\n     * @param subject token中要存放的数据（json格式）\n     * @return\n     */\n    public static String createJWT(String subject) &#123;\n        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间\n        return builder.compact();\n    &#125;\n\n    /**\n     * 生成jtw\n     * @param subject token中要存放的数据（json格式）\n     * @param ttlMillis token超时时间\n     * @return\n     */\n    public static String createJWT(String subject, Long ttlMillis) &#123;\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间\n        return builder.compact();\n    &#125;\n\n    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123;\n        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;\n        SecretKey secretKey = generalKey();\n        long nowMillis = System.currentTimeMillis();\n        Date now = new Date(nowMillis);\n        if(ttlMillis==null)&#123;\n            ttlMillis=JwtUtil.JWT_TTL;\n        &#125;\n        long expMillis = nowMillis + ttlMillis;\n        Date expDate = new Date(expMillis);\n        return Jwts.builder()\n                .setId(uuid)              //唯一的ID\n                .setSubject(subject)   // 主题  可以是JSON数据\n                .setIssuer(\"sg\")     // 签发者\n                .setIssuedAt(now)      // 签发时间\n                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥\n                .setExpiration(expDate);\n    &#125;\n\n    /**\n     * 创建token\n     * @param id\n     * @param subject\n     * @param ttlMillis\n     * @return\n     */\n    public static String createJWT(String id, String subject, Long ttlMillis) &#123;\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间\n        return builder.compact();\n    &#125;\n\n    public static void main(String[] args) throws Exception &#123;\n        String token = \"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\";\n        Claims claims = parseJWT(token);\n        System.out.println(claims);\n    &#125;\n\n    /**\n     * 生成加密后的秘钥 secretKey\n     * @return\n     */\n    public static SecretKey generalKey() &#123;\n        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \"AES\");\n        return key;\n    &#125;\n    \n    /**\n     * 解析\n     *\n     * @param jwt\n     * @return\n     * @throws Exception\n     */\n    public static Claims parseJWT(String jwt) throws Exception &#123;\n        SecretKey secretKey = generalKey();\n        return Jwts.parser()\n                .setSigningKey(secretKey)\n                .parseClaimsJws(jwt)\n                .getBody();\n    &#125;\n\n\n&#125;\npackage com.zjj.util;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.BoundSetOperations;\nimport org.springframework.data.redis.core.HashOperations;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.core.ValueOperations;\nimport org.springframework.stereotype.Component;\n\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\n@SuppressWarnings(value = &#123; \"unchecked\", \"rawtypes\" &#125;)\n@Component\npublic class RedisCache\n&#123;\n    @Autowired\n    public RedisTemplate redisTemplate;\n\n    /**\n     * 缓存基本的对象，Integer、String、实体类等\n     *\n     * @param key 缓存的键值\n     * @param value 缓存的值\n     */\n    public &lt;T> void setCacheObject(final String key, final T value)\n    &#123;\n        redisTemplate.opsForValue().set(key, value);\n    &#125;\n\n    /**\n     * 缓存基本的对象，Integer、String、实体类等\n     *\n     * @param key 缓存的键值\n     * @param value 缓存的值\n     * @param timeout 时间\n     * @param timeUnit 时间颗粒度\n     */\n    public &lt;T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\n    &#123;\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\n    &#125;\n\n    /**\n     * 设置有效时间\n     *\n     * @param key Redis键\n     * @param timeout 超时时间\n     * @return true=设置成功；false=设置失败\n     */\n    public boolean expire(final String key, final long timeout)\n    &#123;\n        return expire(key, timeout, TimeUnit.SECONDS);\n    &#125;\n\n    /**\n     * 设置有效时间\n     *\n     * @param key Redis键\n     * @param timeout 超时时间\n     * @param unit 时间单位\n     * @return true=设置成功；false=设置失败\n     */\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\n    &#123;\n        return redisTemplate.expire(key, timeout, unit);\n    &#125;\n\n    /**\n     * 获得缓存的基本对象。\n     *\n     * @param key 缓存键值\n     * @return 缓存键值对应的数据\n     */\n    public &lt;T> T getCacheObject(final String key)\n    &#123;\n        ValueOperations&lt;String, T> operation = redisTemplate.opsForValue();\n        return operation.get(key);\n    &#125;\n\n    /**\n     * 删除单个对象\n     *\n     * @param key\n     */\n    public boolean deleteObject(final String key)\n    &#123;\n        return redisTemplate.delete(key);\n    &#125;\n\n    /**\n     * 删除集合对象\n     *\n     * @param collection 多个对象\n     * @return\n     */\n    public long deleteObject(final Collection collection)\n    &#123;\n        return redisTemplate.delete(collection);\n    &#125;\n\n    /**\n     * 缓存List数据\n     *\n     * @param key 缓存的键值\n     * @param dataList 待缓存的List数据\n     * @return 缓存的对象\n     */\n    public &lt;T> long setCacheList(final String key, final List&lt;T> dataList)\n    &#123;\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\n        return count == null ? 0 : count;\n    &#125;\n\n    /**\n     * 获得缓存的list对象\n     *\n     * @param key 缓存的键值\n     * @return 缓存键值对应的数据\n     */\n    public &lt;T> List&lt;T> getCacheList(final String key)\n    &#123;\n        return redisTemplate.opsForList().range(key, 0, -1);\n    &#125;\n\n    /**\n     * 缓存Set\n     *\n     * @param key 缓存键值\n     * @param dataSet 缓存的数据\n     * @return 缓存数据的对象\n     */\n    public &lt;T> BoundSetOperations&lt;String, T> setCacheSet(final String key, final Set&lt;T> dataSet)\n    &#123;\n        BoundSetOperations&lt;String, T> setOperation = redisTemplate.boundSetOps(key);\n        Iterator&lt;T> it = dataSet.iterator();\n        while (it.hasNext())\n        &#123;\n            setOperation.add(it.next());\n        &#125;\n        return setOperation;\n    &#125;\n\n    /**\n     * 获得缓存的set\n     *\n     * @param key\n     * @return\n     */\n    public &lt;T> Set&lt;T> getCacheSet(final String key)\n    &#123;\n        return redisTemplate.opsForSet().members(key);\n    &#125;\n\n    /**\n     * 缓存Map\n     *\n     * @param key\n     * @param dataMap\n     */\n    public &lt;T> void setCacheMap(final String key, final Map&lt;String, T> dataMap)\n    &#123;\n        if (dataMap != null) &#123;\n            redisTemplate.opsForHash().putAll(key, dataMap);\n        &#125;\n    &#125;\n\n    /**\n     * 获得缓存的Map\n     *\n     * @param key\n     * @return\n     */\n    public &lt;T> Map&lt;String, T> getCacheMap(final String key)\n    &#123;\n        return redisTemplate.opsForHash().entries(key);\n    &#125;\n\n    /**\n     * 往Hash中存入数据\n     *\n     * @param key Redis键\n     * @param hKey Hash键\n     * @param value 值\n     */\n    public &lt;T> void setCacheMapValue(final String key, final String hKey, final T value)\n    &#123;\n        redisTemplate.opsForHash().put(key, hKey, value);\n    &#125;\n\n    /**\n     * 获取Hash中的数据\n     *\n     * @param key Redis键\n     * @param hKey Hash键\n     * @return Hash中的对象\n     */\n    public &lt;T> T getCacheMapValue(final String key, final String hKey)\n    &#123;\n        HashOperations&lt;String, String, T> opsForHash = redisTemplate.opsForHash();\n        return opsForHash.get(key, hKey);\n    &#125;\n\n    /**\n     * 删除Hash中的数据\n     * \n     * @param key\n     * @param hkey\n     */\n    public void delCacheMapValue(final String key, final String hkey)\n    &#123;\n        HashOperations hashOperations = redisTemplate.opsForHash();\n        hashOperations.delete(key, hkey);\n    &#125;\n\n    /**\n     * 获取多个Hash中的数据\n     *\n     * @param key Redis键\n     * @param hKeys Hash键集合\n     * @return Hash对象集合\n     */\n    public &lt;T> List&lt;T> getMultiCacheMapValue(final String key, final Collection&lt;Object> hKeys)\n    &#123;\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\n    &#125;\n\n    /**\n     * 获得缓存的基本对象列表\n     *\n     * @param pattern 字符串前缀\n     * @return 对象列表\n     */\n    public Collection&lt;String> keys(final String pattern)\n    &#123;\n        return redisTemplate.keys(pattern);\n    &#125;\n&#125;\npackage com.zjj.util;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class WebUtils\n&#123;\n    /**\n     * 将字符串渲染到客户端\n     * \n     * @param response 渲染对象\n     * @param string 待渲染的字符串\n     * @return null\n     */\n    public static String renderString(HttpServletResponse response, String string) &#123;\n        try\n        &#123;\n            response.setStatus(200);\n            response.setContentType(\"application/json\");\n            response.setCharacterEncoding(\"utf-8\");\n            response.getWriter().print(string);\n        &#125;\n        catch (IOException e)\n        &#123;\n            e.printStackTrace();\n        &#125;\n        return null;\n    &#125;\n&#125;\npackage com.zjj.config;\n\nimport com.zjj.util.FastJsonRedisSerializer;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Configuration\npublic class RedisConfig &#123;\n\n    @Bean\n    @SuppressWarnings(value = &#123; \"unchecked\", \"rawtypes\" &#125;)\n    public RedisTemplate&lt;Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)\n    &#123;\n        RedisTemplate&lt;Object, Object> template = new RedisTemplate&lt;>();\n        template.setConnectionFactory(connectionFactory);\n\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\n\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(serializer);\n\n        // Hash的key也采用StringRedisSerializer的序列化方式\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(serializer);\n\n        template.afterPropertiesSet();\n        return template;\n    &#125;\n&#125;\n# 2  重写登录服务 (ServiceImpl)\n​\t这里我们需要写一个 LoginService 、LoginServiceImpl 以及认证服务  UserDetailServiceImpl (后续会详细解释)\npackage com.zjj.service.impl;\n\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.zjj.mapper.UserMapper;\nimport com.zjj.pojo.LoginUser;\nimport com.zjj.pojo.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\n@Service\npublic class UserDetailServiceImpl implements UserDetailsService &#123;\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        LambdaQueryWrapper&lt;User> qw = new LambdaQueryWrapper&lt;>();\n        qw.eq(User::getUserName, username);\n        User user = userMapper.selectOne(qw);\n        if (Objects.isNull(user)) &#123;\n            throw new UsernameNotFoundException(\"没有该用户\");\n        &#125;\n\n        // TODO 权限信息后序添加\n        List&lt;String> menus = userMapper.findMenuByUserId(user.getId());\n        List&lt;String> roles = userMapper.findRoleByUserId(user.getId());\n        List&lt;String> res = new ArrayList&lt;>();\n\n        \n        for (String menu : menus) &#123;\n            res.add(menu);\n        &#125;\n        for (String role : roles) &#123;\n            res.add(\"ROLE_\"+role);\n        &#125;\n        // 用户的权限和角色直接赋值 的话 要注意写法\n        /*\n        1、我们没有user对象直接往回 new UserDetails(username,password,Authorities) 对象时，\n            要注意Authorities手动String转化可以用 AuthorityUtils.commaSeparatedStringToAuthorityList(String str)\n                但是里面的 str里面包含了权限以及角色，每个要用 “,” 间隔，而且角色开头要要拼接 ROLE_\n\n        2、我们自定义了user 实现了 UserDetails 对象 我们重写了 getAuthorities属性，具体看这个类的注释\n            他在初始化值的时候我们传参传递的是一个list对象，这个时候我们不需要用 “，” 间隔，但是角色前要加 ROLE_\n         */\n        return new LoginUser(user,res);\n    &#125;\n&#125;\npublic interface LoginService &#123;\n    public ResponseResult login(User user);\n\n    ResponseResult logout();\n&#125;\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.zjj.mapper.UserMapper;\nimport com.zjj.pojo.LoginUser;\nimport com.zjj.pojo.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\n@Service\npublic class UserDetailServiceImpl implements UserDetailsService &#123;\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        LambdaQueryWrapper&lt;User> qw = new LambdaQueryWrapper&lt;>();\n        qw.eq(User::getUserName, username);\n        User user = userMapper.selectOne(qw);\n        if (Objects.isNull(user)) &#123;\n            throw new UsernameNotFoundException(\"没有该用户\");\n        &#125;\n\n        // TODO 权限信息后序添加\n        List&lt;String> menus = userMapper.findMenuByUserId(user.getId());\n        List&lt;String> roles = userMapper.findRoleByUserId(user.getId());\n        List&lt;String> res = new ArrayList&lt;>();\n\n        for (String menu : menus) &#123;\n            res.add(menu);\n        &#125;\n        for (String role : roles) &#123;\n            res.add(\"ROLE_\"+role);\n        &#125;\n        // 用户的权限和角色直接赋值 的话 要注意写法\n        /*\n        1、我们没有user对象直接往回 new UserDetails(username,password,Authorities) 对象时，\n            要注意Authorities手动String转化可以用 AuthorityUtils.commaSeparatedStringToAuthorityList(String str)\n                但是里面的 str里面包含了权限以及角色，每个要用 “,” 间隔，而且角色开头要要拼接 ROLE_\n\n        2、我们自定义了user 实现了 UserDetails 对象 我们重写了 getAuthorities属性，具体看这个类的注释\n            他在初始化值的时候我们传参传递的是一个list对象，这个时候我们不需要用 “，” 间隔，但是角色前要加 ROLE_\n         */\n        return new LoginUser(user,res);\n    &#125;\n&#125;\n# 3 重写 mapper 层和对应的映射文件\n和 3.3.1 的准备相同\n# 4 配置类配置\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n\n    @Bean\n    public PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n    &#125;\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception &#123;\n        return super.authenticationManagerBean();\n    &#125;\n&#125;\n# 5 对接登录接口\n假定登录接口为\t“/user/login”\n@Controller\npublic class LoginController &#123;\n\n    @Autowired\n    private LoginService loginService;\n\n    @RequestMapping(\"/user/login\")\n    @ResponseBody\n    public ResponseResult login(@RequestBody User user)&#123;\n        return loginService.login(user);\n    &#125;\n    @RequestMapping(\"/user/logout\")\n    @ResponseBody\n    public ResponseResult logout() &#123;\n        return loginService.logout();\n    &#125;\n&#125;\n5 测试接口\n这里用接口测试工具即可，我们没有登录页面，页面是前端提供的，所以我们只需要确保接口测试正确即可\nhttp://localhost:8080/user/login\n&#123;\n    \"userName\":\"zhangsan\",\n    \"password\":\"zhangsan\"\n    // \"userName\":\"lisi\",\n    // \"password\":\"lisi\"\n    // \"userName\":\"wangwu\",\n    // \"password\":\"wangwu\"\n&#125;\n\n# 6 优化认证 —— 引入 Redis\n​\t我们在项目中，不可能每次这种常用数据都去数据库访问，这样会给数据库造成极大的负担，导致我们的数据库宕机。因此我们引入的 NoSQL 数据库、缓存数据库 Redis 用来存储我们短期常用数据。但是问题又来了。怎么存储呢？\n​\t引入 3.2.1SpringSecurity 完整流程\n\n​\t我们每次的登录验证都需要经过 UsernamePasswordAuthenticationFilter ，在这个过滤器下我们必须得到一个认证的用户，所以我们在这里为了得到用户的认证信息我们老办法就是去数据库中查找，但是我们现在不想让他老去数据库中找，在他之前我们要是直接能得到这个认证过的用户岂不皆大欢喜，所以我们在他之前也加上一个过滤器用来查找每次请求是否有这个认证用户有的话我们就可以省略掉去数据库中查找他的信息的过程。\n​\t那么问题又来了我们如何存储一个用户的信息呢？\n这里我们可以利用 JWT 根据我们的用户 ID 生成一个 Token，以他为键值存储到 redis 中\nJWT 详解 ：除了讲解 JWT，还很好的帮忙回顾了 Token 的优势\npackage com.zjj.filter;\n\nimport com.zjj.pojo.LoginUser;\nimport com.zjj.util.JwtUtil;\nimport com.zjj.util.RedisCache;\nimport io.jsonwebtoken.Claims;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.filter.OncePerRequestFilter;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Objects;\n\n@Component\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123;\n\n    @Autowired\n    private RedisCache redisCache;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;\n        //获取token\n        String token = request.getHeader(\"token\");\n        if (!StringUtils.hasText(token)) &#123;\n            //放行\n            /*\n            * 解释一下，为什么没有Token还放行，因为没有token可以但是可能他是登录请求\n            * 我们还是要放行的，不然所有人都登录不了，但是问题是如果不是为什么还要放行\n            * 这里不用担心，如果不是登录请求他就可能会存在User对象的账户和密码，就无法完成第一步的认证工作，跟别说后面的鉴权了，所以他会直接被挡住\n            * 其次我们倒数第二个过滤器就是为我们处理我们出现的问题的过滤器，出了问题让他解决就行了，这里的问题其实大多数都是token错误，需要重新认证\n            * */\n            filterChain.doFilter(request, response);\n            return;\n        &#125;\n        //解析token\n        String userid;\n        try &#123;\n            Claims claims = JwtUtil.parseJWT(token);\n            userid = claims.getSubject();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            throw new RuntimeException(\"token非法\");\n        &#125;\n        //从redis中获取用户信息\n        String redisKey = \"login:\" + userid;\n        LoginUser loginUser = redisCache.getCacheObject(redisKey);\n        if(Objects.isNull(loginUser))&#123;\n            throw new RuntimeException(\"用户未登录\");\n        &#125;\n        //存入SecurityContextHolder ——> 认证成功的对象都在这\n        //TODO 获取权限信息封装到Authentication中\n        /*\n        * 三参构造可以获取该对象是否是以认证状态\n        *  */\n        UsernamePasswordAuthenticationToken authenticationToken =\n                new UsernamePasswordAuthenticationToken(loginUser,null,loginUser.getAuthorities());\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n        //放行\n        filterChain.doFilter(request, response);\n    &#125;\n&#125;\n# 7 修改配置类\npackage com.zjj.config;\n\nimport com.zjj.filter.JwtAuthenticationTokenFilter;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.web.AuthenticationEntryPoint;\nimport org.springframework.security.web.access.AccessDeniedHandler;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\n\n\n@Configuration\npublic class SpringSecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n    @Autowired\n    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\n    @Autowired\n    private AuthenticationEntryPoint authenticationEntryPoint;\n    @Autowired\n    private AccessDeniedHandler accessDeniedHandler;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n\n        // 认证、授权错误处理\n        http.exceptionHandling()\n                .authenticationEntryPoint(authenticationEntryPoint)\n                .accessDeniedHandler(accessDeniedHandler);\n        // 认证过滤器添加\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n\n        // url拦截\n        http.authorizeRequests()\n                // anonymous 匿名 没有认证的才可以访问，permitALL 谁都能访问，不需要认证\n                .antMatchers(\"/user/login\",\"/login\",\"/loginPage\").anonymous()\n                .antMatchers(\"/login.html\",\"/fail.html\").permitAll()\n                // authenticated 认证了才能访问\n                .anyRequest().authenticated();\n\n        //关闭CSRF\n        http.csrf().disable()\n                // 不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n        // Cors\n        http.cors();\n    &#125;\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception &#123;\n        return super.authenticationManagerBean();\n    &#125;\n\n\n    @Bean\n    public PasswordEncoder getPasswordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n&#125;\n# 8 测试\n这里要打开你的 redis 服务端 ，如果不是本地的，你要去配置中添加配置\n最后根据 步骤 5 再次测试，成功后你的 redis 中会多出一组数据，这就是我们的 Token，具体步骤不再演示！\n# 四、UserDetailsService 详解\n​\t当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制 ** 认证逻辑 **。\n\n​\t如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。接口定义如下：\n\n# 1. 返回值\n​\t返回值 UserDetails 是一个接口，定义如下\n\n​\t要想返回 UserDetails 的实例就只能返回接口的实现类。Spring Security 中提供了如下的实例。对于我们只需要使用里面的 User 类即可。注意 User 的全限定路径是：\n​\torg.springframework.security.core.userdetails.User\n​\t此处经常和系统中自己开发的 User 类弄混。\n\n​\t在 User 类中提供了很多方法和属性。\n\n​\t其中构造方法有两个，调用其中任何一个都可以实例化 UserDetails 实现类 User 类的实例。而三个参数的构造方法实际上也是调用 7 个参数的构造方法。\n​\tusername: 用户名\n​\tpassword: 密码\n​\tauthorities：用户具有的权限。此处不允许为 null\n\n​\t此处的用户名应该是客户端传递过来的用户名。而密码应该是从数据库中查询出来的密码。Spring Security 会根据 User 中的 password 和客户端传递过来的 password 进行比较。如果相同则表示认证通过，如果不相同表示认证失败。\n​\tauthorities 里面的权限对于后面学习授权是很有必要的，包含的所有内容为此用户具有的权限，如有里面没有包含某个权限，而在做某个事情时必须包含某个权限则会出现 403。通常都是通过 AuthorityUtils.commaSeparatedStringToAuthorityList (“”) 来创建 authorities 集合对象的。参数是一个字符串，多个权限使用逗号分隔，角色信息前要加  ROLE_  来标识不然会当成权限信息处理。\n建议\n\n\n\n\n\n\n\n\n\n​\t我们的项目中对于用户信息的表，肯定是不同的，我们可以利用这个类，对于用来认证的 UserDetails 对象进行进一步封装，自定义我们的认证对象。例如：\npackage com.zjj.pojo;\n\nimport com.alibaba.fastjson.annotation.JSONField;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@ToString\npublic class LoginUser implements UserDetails &#123;\n    private User user;\n\n    private List&lt;String> permission;\n\n    public LoginUser(User user, List&lt;String> permission) &#123;\n        this.user = user;\n        this.permission = permission;\n    &#125;\n\n    @JSONField(serialize = false) //redis存储的话会出现问题，不让他序列化，主要为了安全\n    List&lt;SimpleGrantedAuthority> authorities ;\n    @Override\n    public Collection&lt;? extends GrantedAuthority> getAuthorities() &#123;\n        // 把permission中的String类型的权限信息封装成 SimpleGrantedAuthority 对象\n        if (null != authorities) return authorities;//要是有信息就不用再授权了\n        authorities = permission.stream()\n                .map(SimpleGrantedAuthority::new)\n                .collect(Collectors.toList());\n        return authorities;\n    &#125;\n\n    @Override\n    public String getPassword() &#123;\n        return user.getPassword();\n    &#125;\n\n    @Override\n    public String getUsername() &#123;\n        return user.getUsername();\n    &#125;\n\n    @Override\n    public boolean isAccountNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isAccountNonLocked() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isCredentialsNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isEnabled() &#123;\n        return true;\n    &#125;\n&#125;\n​\t这里只是一个例子，我重写了 getAuthorities () ，其他的信息我们可以根据我们自己的数据库的 User 信息进行初始化，这里我为了测试方便其余都事 TRUE 打开了他们的权限\n​\t这里我自定义个 permission 用来存储我们查询到的权限信息，用它来对 authorities 来初始化 以及对 getAuthorities () 的重写，authorities 是我们根据 SpringSecurity 要求封装的权限集合 ，但是要注意，不要让他存储到 redis 中，redis 存储的话会出现问题，不要让他序列化，主要为了安全。\n​\t这样我们每次认证的时候就直接可以利用这个认证对象，而我们的原生 User 还可以进行别的操作，这样做更加灵活。推荐 ********\n# 2. 方法参数\n​\t方法参数表示用户名。此值是客户端表单传递过来的数据。默认情况下必须叫 username，否则无法接收。\n# 3. 异常\n​\tUsernameNotFoundException 用户名没有发现异常。在 loadUserByUsername 中是需要通过自己的逻辑从数据库中取值的。如果通过用户名没有查询到对应的数据，应该抛出 UsernameNotFoundException，系统就知道用户名没有查询到。\n# 五、配置类说明 1 — 认证配置\n# 1. 失败跳转\n​\t表单处理中成功会跳转到一个地址，失败也可以跳转到一个地址中。\n# 1.1 编写页面\n​\t在 src/main/resources/static 下新建 fail.html 并编写如下内容\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n    &lt;head>\n        &lt;meta charset=\"UTF-8\">\n        &lt;title>Title&lt;/title>\n    &lt;/head>\n    &lt;body>\n        操作失败，请重新登录. &lt;a href=\"/login.html\">跳转&lt;/a>\n    &lt;/body>\n&lt;/html>\n# 1.2 修改表单配置\n​\t在配置方法中表单认证部分添加 failureForwardUrl () 方法，表示登录失败跳转的 url。此处依然是 POST 请求，所以跳转到可以接收 POST 请求的控制器 /fail 中。\n// 表单认证\nhttp.formLogin()\n    .loginProcessingUrl(\"/login\")   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl\n    .successForwardUrl(\"/toMain\")   //此处是post请求\n    .failureForwardUrl(\"/fail\")     //登录失败跳转地址\n    .loginPage(\"/login.html\");\n# 1.3 添加控制器方法\n​\t在控制器类中添加控制器方法，方法映射路径 /fail。此处要注意：由于是 POST 请求访问 /fail。所以如果返回值直接转发到 fail.html 中，及时有效果，控制台也会报警告，提示 fail.html 不支持 POST 访问方式。\n@PostMapping(\"/fail\")\npublic String fail()&#123;\n    return \"redirect:/fail.html\";\n&#125;\n# 1.4 设置 fail.html 不需要认证\n​\t认证失败跳转到 fail.html 页面中，所以必须配置 fail.html 不需要被认证。需要修改配置类中内容\n// url 拦截\nhttp.authorizeRequests()\n        .antMatchers(\"/login.html\").permitAll() //login.html不需要被认证\n        .antMatchers(\"/fail.html\").permitAll()  //fail.html不需要被认证\n        .anyRequest().authenticated();//所有的请求都必须被认证。必须登录后才能访问。\n# 2. 设置请求账户和密码的参数名\n# 2.1 源码简介\n​\t当进行登录时会执行 UsernamePasswordAuthenticationFilter 过滤器。\n​\tusernamePasrameter: 账户参数名\n​\tpasswordParameter: 密码参数名\n​\tpostOnly=true: 默认情况下只允许 POST 请求。\n\n# 2.2 修改配置\n// 表单认证\nhttp.formLogin()\n        .loginProcessingUrl(\"/login\")   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl\n        .successForwardUrl(\"/toMain\")   //此处是post请求\n        .failureForwardUrl(\"/fail\")     //登录失败跳转地址\n        .loginPage(\"/login.html\")\n        .usernameParameter(\"myusername\")\n        .passwordParameter(\"mypassword\");\n# 2.3 修改页面\n​\t修改 login.html\n&lt;form action = \"/login\" method=\"post\">\n    用户名：&lt;input type=\"text\" name=\"myusername\"/>&lt;br/>\n    密码:&lt;input type=\"password\" name=\"mypassword\"/>&lt;br/>\n    &lt;input type=\"submit\" value=\"登录\"/>\n&lt;/form>\n# 3. 自定义登录成功处理器\n# 3.1 源码分析\n​\t使用 successForwardUrl () 时表示成功后转发请求到地址。内部是通过 successHandler（）方法进行控制成功后交给哪个类进行处理\n\n​\tForwardAuthenticationSuccessHandler 内部就是最简单的请求转发。由于是请求转发，当遇到需要跳转到站外或在前后端分离的项目中就无法使用了。\n\n​\t当需要控制登录成功后去做一些事情时，可以进行自定义认证成功控制器。\n# 3.2 代码实现\n# 3.2.1 自定义类\n​\t新建类 MyAuthenticationSuccessHandler 实现 AuthenticationSuccessHandler ，编写如下：\npublic class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123;\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123;\n        //Principal 主体，存放了登录用户的信息\n        User user = (User)authentication.getPrincipal();\n        System.out.println(user.getUsername());\n        System.out.println(user.getPassword());//密码输出为null\n        System.out.println(user.getAuthorities());\n        //重定向到百度。这只是一个示例，具体需要看项目业务需求\n        httpServletResponse.sendRedirect(\"http://www.baidu.com\");\n    &#125;\n&#125;\n# 3.2.2 修改配置项\n使用 successHandler () 方法设置成功后交给哪个对象进行处理\n// 表单认证\nhttp.formLogin()\n        .loginProcessingUrl(\"/login\")   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl\n        .successHandler(new MyAuthenticationSuccessHandler())\n        //.successForwardUrl(\"/toMain\")   //此处是post请求\n        .failureForwardUrl(\"/fail\")     //登录失败跳转地址\n        .loginPage(\"/login.html\");\n# 4. 自定义登录失败处理器\n# 4.1 源码分析\n​\tfailureForwardUrl () 内部调用的是 failureHandler () 方法\n​\tForwardAuthenticationFailureHandler 中也是一个请求转发，并在 request 作用域中设置\t\t\t SPRING_SECURITY_LAST_EXCEPTION 的 key，内容为异常对象。\n\n# 4.2 代码实现\n# 4.2.1 新建控制器\n​\t新建 MyForwardAuthenticationFailureHandler 实现 AuthenticationFailureHandler 。在方法中添加重定向语句\npublic class MyForwardAuthenticationFailureHandler implements AuthenticationFailureHandler &#123;\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123;\n        httpServletResponse.sendRedirect(\"/fail.html\");\n    &#125;\n&#125;\n# 4.2.2 修改配置类\n​\t修改配置类中表单登录部分。设置失败时交给失败处理器进行操作。failureForwardUrl 和 failureHandler 不可共存。\n        // 表单认证\n        http.formLogin()\n                .loginProcessingUrl(\"/login\")   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl\n                .successHandler(new MyAuthenticationSuccessHandler())\n                //.successForwardUrl(\"/toMain\")   //此处是post请求\n                .failureHandler(new MyForwardAuthenticationFailureHandler())\n//                .failureForwardUrl(\"/fail\")     //登录失败跳转地址\n                .loginPage(\"/login.html\");\n# 5 总结\n// http.formLogin() 所有和表单有关系的\n      http.formLogin()\n              // 登录页面，走一个controller\n              // 注意要和，LoginProcessingUrl 配合使用，不然在表单中的action中 url 失效\n              // 因为只配置loginPage()， 会导致在初始化的时候将loginProcessingUrl的配置相同化，可以自己debug 在AbstractAuthenticationFilterConfigurer 的 updateAuthenticationDefaults 方法\n              // 也就是说loginPage(\"/login\")  loginProcessingUrl(\"/login\"),导致提交信息失败最终导致认证失败\n              .loginPage(\"/showLogin\")\n              // 当发现什么URL时，把请求转发给自定义登录逻辑\n              // 表单提交的地址 action ,他就会直接去认证进入到 UserDetailsServiceImpl\n              // 去这里进行用户的验证 和 用户权限信息的集体封装\n              .loginProcessingUrl(\"/login\")\n          \n              // 登录成功的操作\n              // 下面两种方法都可以，推荐第二种，两种同时写第一个直接失效\n              // 第一种写法，要注意在写映射的时候要注意请求的方法 get/post\n              .successForwardUrl(\"/showMain\")\n              .successHandler((request, response, authentication) -> &#123;\n                  System.out.println(\"successHandler invoked\");\n                  // 我们在每次请求同一个页面尽量使用重定向，要是请求转发\n                  // 因为请求转发是浏览器的行为，每次都要请求服务器并且重复提交表单，不好\n                  // response.sendRedirect(\"/fail\");\n                  LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n                  for (String s : loginUser.getPermission()) &#123;\n                      System.out.println(s);\n                  &#125;\n              &#125;)\n              // 登录失败的操作\n              // 内容和上述情况相同，只是一个成功的一个失败的\n              .failureForwardUrl(\"/fail\")\n              // 当前端表单传递过来的用户名参数、密码参数名和后端不对应，可以利用下列方法\n              // 指定前端传递过来的用户名参数名称\n              //.usernameParameter(\"MyuserName\")\n              // 指定前端传递过来的密码参数名称\n              // .passwordParameter(\"MypassWord\")\n      ;\n# 六、用户授权\n# 1 权限系统的作用\n​\t例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。\n​\t总结起来就是不同的用户可以使用不同的功能。这就是权限系统要去实现的效果。\n# 2 授权基本流程\n​\t在 SpringSecurity 中，会使用默认的 FilterSecurityInterceptor 来进行权限校验。在 FilterSecurityInterceptor 中会从 SecurityContextHolder 获取其 Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。\n​\t所以我们在项目中只需要把当前登录用户的权限信息也存入 Authentication。然后设置我们的资源所需要的权限即可。\n# 3 RBAC 权限模型\n参考博客：https://blog.csdn.net/qzw752890913/article/details/124461952\n​\tRBAC（Role Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联，而不是直接将权限赋予用户。\n​\t一个用户拥有若干个角色，每个角色拥有若干个权限，这样就构成了 “用户 - 角色 - 权限” 的授权模型。这种授权模型的好处在于，不必每次创建用户时都进行权限分配的操作，只要分配用户相应的角色即可，而且角色的权限变更比用户的权限变更要少得多，减少频繁设置。\nRBAC 模型中，用户与角色之间、角色与权限之间，一般是多对多的关系。\n所谓 “多对多”，就是双向的一对多。\n\n​\t\n# 4 授权实现\n\n基于配置 —— 在 SpringSecurity 的配置类中和登录页一样进行权限配置 (不推荐，过程繁琐，开发麻烦)\n基于注解 —— 直接可以对我们次处理，也就是对我们的控制层进行权限的设置 (强烈推荐)\n\n# 4.1 基于配置授权\n这里没什么好说的，从刚开始我们就开始写了权限的认证，就是我们重写的配置类\n// http.authorizeRequests() 所有和授权相关\nhttp.authorizeRequests()\n    // 这里面支持 正则 和 ant表达式\t\n    // anonymous 匿名 没有认证的才可以访问，permitALL 谁都能访问，不需要认证\n    .antMatchers(\"/user/login\",\"/login\",\"/loginPage\").anonymous()\n    .antMatchers(\"/js/**\").permitAll()\n    // authenticated 认证了才能访问\n    .anyRequest().authenticated();\n这样写，除了静态资源权限需要这么写，其余请求折磨写太麻烦，我们的业务众多，这样写极大的增加了业务开发的负担，再加上静态资源我们都已经前后端分离也就涉及不到他的权限问题，所以这种方式了解就好。主要重点放在注解学习上。\n# 4.2 基于注解授权\n# 准备阶段\n​\tSpringSecurity 为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。\n​\t但是要使用它我们需要先开启相关配置。，不打开直接用会 500\n@EnableGlobalMethodSecurity(prePostEnabled = true)//启动类上添加注解\n# 找到对应的接口\n这里我们找到需要授权的接口，对他们进行授权，主要有 3 个主要注解\n\n@Secured\n@PerAuthorize() 、@PostAuthorize\n\n只要对我们的接口上添加相对应的注解即可，例如\n@Controller\npublic class loginController&#123;\n    @Secured(\"ROLE_abc\") //专门用于判断是否具有角色的。能写在方法或类上。参数要以ROLE_开头。\n    @RequestMapping(\"/toMain\")\n    public String toMain()&#123;\n        return \"redirect:/main.html\";\n    &#125;\n    \n    @RequestMapping(\"/hello3\")\n    @ResponseBody\n    // 是方法或类级别注解。\n    @PreAuthorize(\"hasAnyAuthority('demo:delete')\")\n    public String testThree()&#123;\n        return \"success!\";\n    &#125;\n\n    @RequestMapping(\"/hello4\")\n    @ResponseBody\n    //  是方法或类级别注解。\n    @PostAuthorize(\"hasAnyRole('ROLE_管理员')\")\n    public String testFour()&#123;\n        return \"success!\";\n    &#125;\n&#125;\n# 七、配置类说明 2 — 访问控制\n在前面讲解了认证中所有常用配置，主要是对 http.formLogin () 进行操作。而在配置类中\t\thttp.authorizeRequests () 主要是对 url 进行控制，也就是我们所说的授权（访问控制）。http.authorizeRequests () 也支持连缀写法，总体公式为：\n​\turl 匹配规则。权限控制方法\n通过上面的公式可以有很多 url 匹配规则和很多权限控制方法。这些内容进行各种组合就形成了 Spring Security 中的授权。\n​\t在所有匹配规则中取所有规则的交集。配置顺序影响了之后授权效果，越是具体的应该放在前面，越是笼统的应该放到后面。\n# 1.anyRequest()\n​\t在之前认证过程中我们就已经使用过 anyRequest ()，表示匹配所有的请求。一般情况下此方法都会使用，设置全部内容都需要进行认证。\n​\t代码示例:\nanyRequest().authenticated();\n# 2.antMatcher()\n​\t方法定义如下：\npublic C antMatchers(String... antPatterns)\n​\t参数是不定向参数，每个参数是一个 正则 /ant 表达式，用于匹配 URL 规则。\n​\t规则如下：\n​\t? 匹配一个字符\n​\t* 匹配 0 个或多个字符\n​\t** 匹配 0 个或多个目录\n​\t在实际项目中经常需要放行所有静态资源，下面演示放行 js 文件夹下所有脚本文件。\n.antMatchers(\"/js/**\").permitAll()\n还有一种配置方式是只要是.js 文件都放行\nantMatchers(\"/**/*.js\").permitAll()\n# 3.regexMatchers()\n# 3.1 介绍\n使用正则表达式进行匹配。和 antMatchers () 主要的区别就是参数，antMatchers () 参数是 ant 表达式，regexMatchers () 参数是正则表达式。\n演示所有以.js 结尾的文件都被放行。\n.regexMatchers(\".+[.]js\").permitAll()\n# 3.2 两个参数时使用方式\n无论是 antMatchers () 还是 regexMatchers () 都具有两个参数的方法，其中第一个参数都是 HttpMethod，表示请求方式，当设置了 HttpMethod 后表示只有设定的特定的请求方式才执行对应的权限设置。\n枚举类型 HttpMethod 内置属性如下：\n\n# 4 内置访问控制方法介绍\n​\tSpring Security 匹配了 URL 后调用了 permitAll () 表示不需要认证，随意访问。在 Spring Security 中提供了多种内置控制。\n# 1.permitAll()\n​\tpermitAll () 表示所匹配的 URL 任何人都允许访问。\n# 2.authenticated()\n​\tauthenticated () 表示所匹配的 URL 都需要被认证才能访问。\n# 3.anonymous()\n​\tanonymous () 表示可以匿名访问匹配的 URL。和 permitAll () 效果类似，只是设置为 anonymous () 的 url 会执行 filter 链中\n​\t官方源码定义如下：\n\n# 4.denyAll()\n​\tdenyAll () 表示所匹配的 URL 都不允许被访问。\n\n# 5.rememberMe()\n​\t被 “remember me” 的用户允许访问\n\n# 6.fullyAuthenticated()\n​\t如果用户不是被 remember me 的，才可以访问。\n\n# 7.hasIpAddress(String)\n如果请求是指定的 IP 就运行访问。\n​\t可以通过 request.getRemoteAddr () 获取 ip 地址。\n​\t需要注意的是在本机进行测试时 localhost 和 127.0.0.1 输出的 ip 地址是不一样的。\n​\t当浏览器中通过 localhost 进行访问时控制台打印的内容：\n\n​\t当浏览器中通过 127.0.0.1 访问时控制台打印的内容：\n\n​\t当浏览器中通过具体 ip 进行访问时控制台打印内容：\n\n​\t使用 Spring Security 时经常会看见 403（无权限），默认情况下显示的效果如下：\n\n​\t而在实际项目中可能都是一个异步请求，显示上述效果对于用户就不是特别友好了。Spring Security 支持自定义权限受限。\n# 1. 新建类\n​\t新建类实现 AccessDeniedHandler\n@Component\npublic class MyAccessDeniedHandler implements AccessDeniedHandler &#123;\n    @Override\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException &#123;\n        httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);\n        httpServletResponse.setHeader(\"Content-Type\",\"application/json;charset=utf-8\");\n        PrintWriter out = httpServletResponse.getWriter();\n        out.write(\"&#123;\\\"status\\\":\\\"error\\\",\\\"msg\\\":\\\"权限不足，请联系管理员!\\\"&#125;\");\n        out.flush();\n        out.close();\n    &#125;\n&#125;\n# 2. 修改配置类\n​\t配置类中重点添加异常处理器。设置访问受限后交给哪个对象进行处理。\n​\tmyAccessDeniedHandler 是在配置类中进行自动注入的。\n//异常处理\nhttp.exceptionHandling()\n        .accessDeniedHandler(myAccessDeniedHandler);\n# 5 总结\n在选择特定请求时 2/3 任选其一 效果相同，主要注意内置访问控制方法的选择\n# 八、配置类说明 3 — 基于表达式的访问控制\n# 1.access () 方法使用\n​\t之前学习的登录用户权限判断实际上底层实现都是调用 access (表达式)\n\n​\t可以通过 access () 实现和之前学习的权限控制完成相同的功能。\n# 1.1 以 hasRole 和 permitAll 举例\n​\t下面代码和直接使用 permitAll () 和 hasRole () 是等效的。\n\n# 2. 自定义权限验证方法\n​\t虽然这里面已经包含了很多的表达式 (方法) 但是在实际项目中很有可能出现需要自己自定义逻辑的情况。\n​\t判断登录用户是否具有访问当前 URL 权限。\n# 2.1 新建接口及实现类\n​\t新建接口 com.msb.service.MyService 后新建实现类。\npublic interface MyService &#123;\n    boolean hasPermission(HttpServletRequest request, Authentication authentication);\n&#125;\n@Component\npublic class MyServiceImpl implements MyService &#123;\n    @Override\n    public boolean hasPermission(HttpServletRequest request, Authentication authentication) &#123;\n        Object obj = authentication.getPrincipal();\n        if(obj instanceof UserDetails)&#123;\n            UserDetails user = (UserDetails) obj;\n            Collection&lt;? extends GrantedAuthority> authorities = user.getAuthorities();\n            return authorities.contains(new SimpleGrantedAuthority(request.getRequestURI()));\n        &#125;\n        return false;\n    &#125;\n&#125;\n# 2.2 修改配置类\n​\t在 access 中通过 @bean 的 id 名。方法 (参数) 的形式进行调用\n​\t配置类中修改如下：\n // url 拦截 (授权)\nhttp.authorizeRequests()\n        .antMatchers(\"/login.html\").access(\"permitAll\")\n        .antMatchers(\"/fail.html\").permitAll()\n    \t// @Bean的名字，表示引入某个Bean，我们的Bean在主动命名的情况下，都是以首字母小写命名\n        .anyRequest().access(\"@myServiceImpl.hasPermission(request,authentication)\");\n# 九、基于注解的访问控制\n​\t在 Spring Security 中提供了一些访问控制的注解。这些注解都是默认是都不可用的，需要通过 @EnableGlobalMethodSecurity 进行开启后使用。\n​\t如果设置的条件允许，程序正常执行。如果不允许会报 500\n​\t这些注解可以写到 Service 接口或方法上上也可以写到 Controller 或 Controller 的方法上。通常情况下都是写在控制器方法上的，控制接口 URL 是否允许被访问。\n# 1.@Secured\n​\t@Secured 是专门用于判断是否具有角色的。能写在方法或类上。参数要以 ROLE_开头。\n\n# 1.1 实现步骤\n# 1.1.1 开启注解\n​\t在启动类 (也可以在配置类等能够扫描的类上) 上添加 @EnableGlobalMethodSecurity (securedEnabled = true)\n@SpringBootApplication\n@EnableGlobalMethodSecurity(securedEnabled = true)\npublic class MyApp &#123;\n    public static void main(String [] args)&#123;\n        SpringApplication.run(MyApp.class,args);\n    &#125;\n&#125;\n# 1.1.2 在控制器方法上添加 @Secured 注解\n​\t在 LoginController 中方法上添加注解\n@Secured(\"ROLE_abc\")\n@RequestMapping(\"/toMain\")\npublic String toMain()&#123;\n    return \"redirect:/main.html\";\n&#125;\n# 1.1.3 配置类\n​\t配置类中方法配置保留最基本的配置即可。\nprotected void configure(HttpSecurity http) throws Exception &#123;\n    // 表单认证\n    http.formLogin()\n            .loginProcessingUrl(\"/login\")   //当发现/login时认为是登录，需要执行UserDetailsServiceImpl\n            .successForwardUrl(\"/toMain\")   //此处是post请求\n            .loginPage(\"/login.html\");\n\n    // url 拦截\n    http.authorizeRequests()\n            .antMatchers(\"/login.html\").permitAll() //login.html不需要被认证\n            .anyRequest().authenticated();//所有的请求都必须被认证。必须登录后才能访问。\n\n    //关闭csrf防护\n    http.csrf().disable();\n\n&#125;\n# 2.@PreAuthorize/@PostAuthorize\n​\t@PreAuthorize 和 @PostAuthorize 都是方法或类级别注解。\n​\t**@PreAuthorize ** 表示访问方法或类在执行之前先判断权限，大多情况下都是使用这个注解，注解的参数和 access () 方法参数取值相同，都是权限表达式。\n​\t@PostAuthorize 表示方法或类执行结束后判断权限，此注解很少被使用到。\n\n# 2.1 实现步骤\n# 2.1.1 开启注解\n​\t在启动类中开启 @PreAuthorize 注解。\n@SpringBootApplication\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class MyApp &#123;\n    public static void main(String [] args)&#123;\n        SpringApplication.run(MyApp.class,args);\n    &#125;\n&#125;\n# 2.1.2 添加 @PreAuthorize\n​\t在控制器方法上添加 @PreAuthorize，参数可以是任何 access () 支持的表达式\n@PreAuthorize(\"hasRole('abc')\")\n@RequestMapping(\"/toMain\")\npublic String toMain()&#123;\n    return \"redirect:/main.html\";\n&#125;\n# 3. 自定义权限校验方法 (针对 Pre 注解)\n我们如果觉得单纯验证不合适，或者说不符合我们的业务我们也可以自定义方法\n# 其它权限校验方法\n​\t我们前面都是使用 @PreAuthorize 注解，然后在在其中使用的是 hasAuthority 方法进行校验。SpringSecurity 还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole 等。\n​\t这里我们先不急着去介绍这些方法，我们先去理解 hasAuthority 的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。\n​\thasAuthority 方法实际是执行到了 SecurityExpressionRoot 的 hasAuthority，大家只要断点调试既可知道它内部的校验原理。\n​\t它内部其实是调用 authentication 的 getAuthorities 方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。\n​\thasAnyAuthority 方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。\n@PreAuthorize(\"hasAnyAuthority('admin','test','system:dept:list')\")\npublic String hello()&#123;\n    return \"hello\";\n&#125;\n​\thasRole 要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。\n@PreAuthorize(\"hasRole('system:dept:list')\")\npublic String hello()&#123;\n    return \"hello\";\n&#125;\n​\thasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。\n@PreAuthorize(\"hasAnyRole('admin','system:dept:list')\")\npublic String hello()&#123;\n    return \"hello\";\n&#125;\n# 自定义权限校验方法\n​\t我们也可以定义自己的权限校验方法，在 @PreAuthorize 注解中使用我们的方法。\n@Component(\"ex\")\npublic class MyExpressionRoot &#123;\n\t// 一定要返回一个Bool值\n    public boolean hasAuthority(String authority)&#123;\n        //获取当前用户的权限\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n        List&lt;String> permissions = loginUser.getPermissions();\n        //判断用户权限集合中是否存在authority\n        return permissions.contains(authority);\n    &#125;\n&#125;\n​\t 在 SPEL 表达式中使用 @ex 相当于获取容器中 bean 的名字为 ex 的对象。然后再调用这个对象的 hasAuthority 方法\n@RequestMapping(\"/hello\")\n@PreAuthorize(\"@ex.hasAuthority('system:dept:list')\")\npublic String hello()&#123;\n    return \"hello\";\n&#125;\n# 十、自定义失败处理\n​\t我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的 json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道 SpringSecurity 的异常处理机制。\n​\t在 SpringSecurity 中，如果我们在认证或者授权的过程中出现了异常会被 ExceptionTranslationFilter 捕获到。在 ExceptionTranslationFilter 中会去判断是认证失败还是授权失败出现的异常。\n​\t如果是认证过程中出现的异常会被封装成 AuthenticationException 然后调用 AuthenticationEntryPoint 对象的方法去进行异常处理。\n​\t如果是授权过程中出现的异常会被封装成 AccessDeniedException 然后调用 AccessDeniedHandler 对象的方法去进行异常处理。\n​\t所以如果我们需要自定义异常处理，我们只需要自定义 AuthenticationEntryPoint 和 AccessDeniedHandler 然后配置给 SpringSecurity 即可。\n# ①自定义实现类\n@Component\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler &#123;\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123;\n        ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), \"权限不足\");\n        String json = JSON.toJSONString(result);\n        WebUtils.renderString(response,json);\n    &#125;\n&#125;\n\n@Component\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint &#123;\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123;\n        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), \"认证失败请重新登录\");\n        String json = JSON.toJSONString(result);\n        WebUtils.renderString(response,json);\n    &#125;\n&#125;\n\n# ②配置给 SpringSecurity\n​\t先注入对应的处理器\n@Autowired\nprivate AuthenticationEntryPoint authenticationEntryPoint;\n\n@Autowired\nprivate AccessDeniedHandler accessDeniedHandler;\n​\t然后我们可以使用 HttpSecurity 对象的方法去配置。\nhttp.exceptionHandling()\n    .authenticationEntryPoint(authenticationEntryPoint)\n    .accessDeniedHandler(accessDeniedHandler);\n# 十一、Remember Me 功能实现\n​\tSpring Security 中 Remember Me 为 “记住我” 功能，用户只需要在登录时添加 remember-me 复选框，取值为 true。Spring Security 会自动把用户信息存储到数据源中，以后就可以不登录进行访问。\n# 1. 添加依赖\n​\tSpring Security 实现 Remember Me 功能时底层实现依赖 Spring-JDBC，所以需要导入 Spring-JDBC。以后多使用 MyBatis 框架而很少直接导入 spring-jdbc，所以此处导入 mybatis 启动器\n同时还需要添加 MySQL 驱动\n&lt;dependency>\n    &lt;groupId>org.mybatis.spring.boot&lt;/groupId>\n    &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId>\n    &lt;version>2.1.1&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>mysql&lt;/groupId>\n    &lt;artifactId>mysql-connector-java&lt;/artifactId>\n    &lt;version>5.1.6&lt;/version>\n&lt;/dependency>\n# 2. 配置数据源\n​\t在 application.properties 中配置数据源。请确保数据库中已经存在 security 数据库\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/mashibing\nspring.datasource.username=root\nspring.datasource.password=root\n# 3. 编写配置\n​\t新建 com.msb.config.RememberMeConfig 类，并创建 Bean 对象\n@Configuration\npublic class RememberMeConfig &#123;\n    @Autowired\n    private DataSource dataSource;\n    @Bean\n    public PersistentTokenRepository getPersistentTokenRepository() &#123;\n        JdbcTokenRepositoryImpl jdbcTokenRepositoryImpl=new JdbcTokenRepositoryImpl();\n        jdbcTokenRepositoryImpl.setDataSource(dataSource);\n        //自动建表，第一次启动时需要，第二次启动时注释掉\n//        jdbcTokenRepositoryImpl.setCreateTableOnStartup(true);\n        return jdbcTokenRepositoryImpl;\n    &#125;\n&#125;\n# 4. 修改 SecurityConfig\n​\t在 SecurityConfig 中添加 RememberMeConfig 和 UserDetailsService 实现类对象，并自动注入。\n​\t在 configure 中添加下面配置内容。\nhttp.rememberMe()\n    .userDetailsService(userDetailsService) //登录逻辑交给哪个对象\n    .tokenRepository(repository);   //持久层对象\n# 5. 在客户端页面中添加复选框\n​\t在客户端登录页面中添加 remember-me 的复选框，只要用户勾选了复选框下次就不需要进行登录了。\n&lt;form action = \"/login\" method=\"post\">\n    用户名：&lt;input type=\"text\" name=\"username\"/>&lt;br/>\n    密码:&lt;input type=\"text\" name=\"password\"/>&lt;br/>\n    &lt;input type=\"checkbox\" name=\"remember-me\" value=\"true\"/> &lt;br/>\n    &lt;input type=\"submit\" value=\"登录\"/>\n&lt;/form>\n# 6. 有效时间\n​\t默认情况下重启项目后登录状态失效了。但是可以通过设置状态有效时间，即使项目重新启动下次也可以正常登录。\n//remember Me\nhttp.rememberMe()\n        .tokenValiditySeconds(120)//单位：秒\n        .tokenRepository(repository)\n        .userDetailsService(userDetailsServiceImpl);\n# 十二、Thymeleaf 中 Spring Security 的使用\n​\tSpring Security 可以在一些视图技术中进行控制显示效果。例如：JSP 或 Thymeleaf。在非前后端分离且使用 Spring Boot 的项目中多使用 Thymeleaf 作为视图展示技术。\n​\tThymeleaf 对 Spring Security 的支持都放在 thymeleaf-extras-springsecurityX 中，目前最新版本为 5。所以需要在项目中添加此 jar 包的依赖和 thymeleaf 的依赖。\n&lt;dependency>\n    &lt;groupId>org.thymeleaf.extras&lt;/groupId>\n    &lt;artifactId>thymeleaf-extras-springsecurity5&lt;/artifactId>\n    &lt;version>3.0.4.RELEASE&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId>\n&lt;/dependency>\n​\t在 html 页面中引入 thymeleaf 命名空间和 security 命名空间\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\n      xmlns:th=\"http://www.thymeleaf.org\"\nxmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\">\n# 1. 获取属性\n​\t可以在 html 页面中通过 sec:authentication=&quot;&quot; 获取 UsernamePasswordAuthenticationToken 中所有 getXXX 的内容，包含父类中的 getXXX 的内容。\n​\t根据源码得出下面属性：\n​\tl name：登录账号名称\n​\tl principal：登录主体，在自定义登录逻辑中是 UserDet ails\n​\tl credentials：凭证\n​\tl authorities：权限和角色\n​\tl details：实际上是 WebAuthenticationDetails 的实例。可以获取 remoteAddress (客户端 ip) 和 sessionId (当\t前 sessionId)\n# 1.1 实现步骤：\n# 1.1.1 新建 demo.html\n​\t在项目 resources 中新建 templates 文件夹，在 templates 中新建 demo.html 页面\n\n# 1.1.2 编写 demo.html\n​\t在 demo.html 中编写下面内容，测试获取到的值\n&lt;!DOCTYPE html>\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\n      xmlns:th=\"http://www.thymeleaf.org\"\n      xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\">\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;title>Title&lt;/title>\n&lt;/head>\n&lt;body>\n    登录账号:&lt;span sec:authentication=\"name\">&lt;/span>&lt;br/>\n    登录账号:&lt;span sec:authentication=\"principal.username\">&lt;/span>&lt;br/>\n    凭证：&lt;span sec:authentication=\"credentials\">&lt;/span>&lt;br/>\n    权限和角色：&lt;span sec:authentication=\"authorities\">&lt;/span>&lt;br/>\n    客户端地址：&lt;span sec:authentication=\"details.remoteAddress\">&lt;/span>&lt;br/>\n    sessionId：&lt;span sec:authentication=\"details.sessionId\">&lt;/span>&lt;br/>\n&lt;/body>\n&lt;/html>  \n# 1.1.3 编写控制器\n​\tthymeleaf 页面需要控制转发，在控制器类中编写下面方法\n@RequestMapping(\"/demo\")\npublic String demo()&#123;\n    return \"demo\";\n&#125;\n# 2. 权限判断\n​\t在 html 页面中可以使用 sec:authorize=” 表达式” 进行权限控制，判断是否显示某些内容。表达式的内容和 access (表达式) 的用法相同。如果用户具有指定的权限，则显示对应的内容；如果表达式不成立，则不显示对应的元素。\n# 2.1 不同权限的用户显示不同的按钮\n# 2.1.1 设置用户角色和权限\n​\t设定用户具有 admin，/insert，/delete 权限 ROLE_abc 角色。\nreturn new User(username,password, \n                AuthorityUtils.commaSeparatedStringToAuthorityList(\"admin,ROLE_abc,/insert,/delete\"));\n# 2.1.2 控制页面显示效果\n在页面中根据用户权限和角色判断页面中显示的内容\n通过权限判断：\n&lt;button sec:authorize=\"hasAuthority('/insert')\">新增&lt;/button>\n&lt;button sec:authorize=\"hasAuthority('/delete')\">删除&lt;/button>\n&lt;button sec:authorize=\"hasAuthority('/update')\">修改&lt;/button>\n&lt;button sec:authorize=\"hasAuthority('/select')\">查看&lt;/button>\n&lt;br/>\n通过角色判断：\n&lt;button sec:authorize=\"hasRole('abc')\">新增&lt;/button>\n&lt;button sec:authorize=\"hasRole('abc')\">删除&lt;/button>\n&lt;button sec:authorize=\"hasRole('abc')\">修改&lt;/button>\n&lt;button sec:authorize=\"hasRole('abc')\">查看&lt;/button>\n# 十三、SpringSecurity 的 &quot;跨域&quot; 问题\n​\t浏览器出于安全的考虑，使用 XMLHttpRequest 对象发起 HTTP 请求时必须遵守同源策略，否则就是跨域的 HTTP 请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。\n​\t前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。\n​\t所以我们就要处理一下，让前端能进行跨域请求。\n# ①先对 SpringBoot 配置，运行跨域请求\n这里的方式多种多想可以 配置类，也可以对跨域的请求直接加注解 ，自己视情况而定\n@Configuration\npublic class CorsConfig implements WebMvcConfigurer &#123;\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) &#123;\n      // 设置允许跨域的路径\n        registry.addMapping(\"/**\")\n                // 设置允许跨域请求的域名\n                .allowedOriginPatterns(\"*\")\n                // 是否允许cookie\n                .allowCredentials(true)\n                // 设置允许的请求方式\n                .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\")\n                // 设置允许的header属性\n                .allowedHeaders(\"*\")\n                // 跨域允许时间\n                .maxAge(3600);\n    &#125;\n&#125;\n# ②开启 SpringSecurity 的跨域访问\n由于我们的资源都会收到 SpringSecurity 的保护，所以想要跨域访问还要让 SpringSecurity 运行跨域访问。\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n    http\n            //关闭csrf\n            .csrf().disable()\n            //不通过Session获取SecurityContext\n            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            .and()\n            .authorizeRequests()\n            // 对于登录接口 允许匿名访问\n            .antMatchers(\"/user/login\").anonymous()\n            // 除上面外的所有请求全部需要鉴权认证\n            .anyRequest().authenticated();\n\n    //添加过滤器\n    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n\n    //配置异常处理器\n    http.exceptionHandling()\n            //配置认证失败处理器\n            .authenticationEntryPoint(authenticationEntryPoint)\n            .accessDeniedHandler(accessDeniedHandler);\n\n    //允许跨域\n    http.cors();\n&#125;\n\n# 十三、退出登录\n​\t用户只需要向 Spring Security 项目中发送 /logout 退出请求即可。\n# 1. 退出实现\n实现退出非常简单，只要在页面中添加 /logout 的超链接即可。\n&lt;a href=\"/logout\">退出登录&lt;/a>\n\n​\t为了实现更好的效果，通常添加退出的配置。默认的退出 url 为 /logout，退出成功后跳转到 /login?logout\n​\t如果不希望使用默认值，可以通过下面的方法进行修改。\nhttp.logout()     \n    .logoutUrl(**\"/logout\"**)     \n    .logoutSuccessUrl(**\"/login.html\"**);\n# 2.logout 其他常用配置源码解读\n# 2.1.addLogoutHandler(LogoutHandler)\n​\t默认是 contextLogoutHandler\n​\t默认实例内容\n\n# 2.2clearAuthentication(boolean)\n​\t是否清除认证状态，默认为 true\n# 2.3invalidateHttpSession(boolean)\n​\t是否销毁 HttpSession 对象，默认为 true\n# 2.4logoutSuccessHandler(LogoutSuccessHandler)\n​\t退出成功处理器。\n​\t也可以自己进行定义退出成功处理器。只要实现了 LogoutSuccessHandler 接口。与之前讲解的登录成功处理器和登录失败处理器极其类似。\n# 十四、Spring Security 中 CSRF\n​\t从刚开始学习 Spring Security 时，在配置类中一直存在这样一行代码：http.csrf ().disable (); 如果没有这行代码导致用户无法被认证。这行代码的含义是：关闭 csrf 防护。\n# 1. 什么是 CSRF\n​\tCSRF（Cross-site request forgery）跨站请求伪造，也被称为 “One Click Attack” 或者 Session Riding。通过伪造用户请求访问受信任站点的非法请求访问。\n​\t跨域：只要网络协议，ip 地址，端口中任何一个不相同就是跨域请求。\n​\t客户端与服务进行交互时，由于 http 协议本身是无状态协议，所以引入了 cookie 进行记录客户端身份。在 cookie 中会存放 session id 用来识别客户端身份的。在跨域的情况下，session id 可能被第三方恶意劫持，通过这个 session id 向服务端发起请求时，服务端会认为这个请求是合法的，可能发生很多意想不到的事情。\n# 2.Spring Security 中 CSRF\n​\t从 Spring Security4 开始 CSRF 防护默认开启。默认会拦截请求。进行 CSRF 处理。CSRF 为了保证不是其他第三方网站访问，要求访问时携带参数名为_csrf 值为 token (token 在服务端产生) 的内容，如果 token 和服务端的 token 匹配成功，则正常访问。\n# 2.1 实现步骤\n# 2.1.1 编写控制器方法\n​\t编写控制器方法，跳转到 templates 中 login.html 页面。\n@GetMapping(\"/showLogin\")\npublic String showLogin() &#123;\n    return \"login\";\n&#125;\n# 2.1.2 新建 login.html\n在项目 resources 下新建 templates 文件夹，并在文件夹中新建 login.html 页面。红色部分是必须存在的否则无法正常登录。\n&lt;!DOCTYPE html>\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\n      xmlns:th=\"http://www.thymeleaf.org\">\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;title>Title&lt;/title>\n&lt;/head>\n&lt;body>\n&lt;form action = \"/login\" method=\"post\">\n    &lt;input type=\"hidden\" th:value=\"$&#123;_csrf.token&#125;\" name=\"_csrf\" th:if=\"$&#123;_csrf&#125;\"/>\n    用户名：&lt;input type=\"text\" name=\"username\"/>&lt;br/>\n    密码:&lt;input type=\"password\" name=\"password\"/>&lt;br/>\n    &lt;input type=\"submit\" value=\"登录\"/>\n&lt;/form>\n&lt;/body>\n&lt;/html>     \n# 2.1.3 修改配置类\n在配置类中注释掉 CSRF 防护失效\n//关闭csrf防护\n//http.csrf().disable();\n","slug":"SpringSecurity","date":"2022-10-06T16:00:00.000Z","categories_index":"Spring,SpringSecurity","tags_index":"框架,Spring,SpringSecurity","author_index":"雾都"},{"id":"378d10f920f265d272d287ff94d367ee","title":"第12章IO","content":"# 12 IO 流\n# File 类\n# 1 对文件进行操作\npublic class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //将文件封装为一个File类的对象：\n        File f = new File(\"d:\\\\test.txt\");\n        File f1 = new File(\"d:\\\\test.txt\");\n        File f2 = new File(\"d:/test.txt\");\n        //File.separator属性帮我们获取当前操作系统的路径拼接符号\n       //在windows，dos下，系统默认用“\\”作为路径分隔符 ，在unix，url中，使用“/”作为路径分隔符。\n        File f3 = new File(\"d:\"+File.separator+\"test.txt\");//建议使用这种\n        //常用方法：\n        System.out.println(\"文件是否可读：\"+f.canRead());\n        System.out.println(\"文件是否可写：\"+f.canWrite());\n        System.out.println(\"文件的名字：\"+f.getName());\n        System.out.println(\"上级目录：\"+f.getParent());\n        System.out.println(\"是否是一个目录：\"+f.isDirectory());\n        System.out.println(\"是否是一个文件：\"+f.isFile());\n        System.out.println(\"是否隐藏：\"+f.isHidden());\n        System.out.println(\"文件的大小：\"+f.length());\n        System.out.println(\"是否存在：\"+f.exists());\n        /*if(f.exists())&#123;//如果文件存在，将文件删除操作\n            f.delete();\n        &#125;else&#123;//如果不存在，就创建这个文件\n            f.createNewFile();\n        &#125;*/\n        System.out.println(f == f1);//比较两个对象的地址\n        System.out.println(f.equals(f1));//比较两个对象对应的文件的路径\n        //跟路径相关的：\n        System.out.println(\"绝对路径：\"+f.getAbsolutePath());\n        System.out.println(\"相对路径：\"+f.getPath());\n        System.out.println(\"toString:\"+f.toString());\n        System.out.println(\"----------------------\");\n        File f5 = new File(\"demo.txt\");\n        if(!f5.exists())&#123;\n            f5.createNewFile();\n        &#125;\n        //绝对路径指的就是：真实的一个精准的，完整的路径\n        System.out.println(\"绝对路径：\"+f5.getAbsolutePath());\n        //相对路径：有一个参照物，相对这个参照物的路径。\n        //在main方法中，相对位置指的就是：D:\\IDEA_workspace\\TestJavaSE\n        //在junit的测试方法中，相对路径指的就是模块位置\n        System.out.println(\"相对路径：\"+f5.getPath());\n        //toString的效果永远是  相对路径\n        System.out.println(\"toString:\"+f5.toString());\n        File f6 = new File(\"a/b/c/demo.txt\");\n        if(!f5.exists())&#123;\n            f5.createNewFile();\n        &#125;\n        System.out.println(\"绝对路径：\"+f6.getAbsolutePath());\n        System.out.println(\"相对路径：\"+f6.getPath());\n    &#125;\n&#125;\n# 2 对目录进行操作\npublic class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //将目录封装为File类的对象：\n        File f = new File(\"D:\\\\IDEA_workspace\");\n        System.out.println(\"文件是否可读：\"+f.canRead());\n        System.out.println(\"文件是否可写：\"+f.canWrite());\n        System.out.println(\"文件的名字：\"+f.getName());\n        System.out.println(\"上级目录：\"+f.getParent());\n        System.out.println(\"是否是一个目录：\"+f.isDirectory());\n        System.out.println(\"是否是一个文件：\"+f.isFile());\n        System.out.println(\"是否隐藏：\"+f.isHidden());\n        System.out.println(\"文件的大小：\"+f.length());\n        System.out.println(\"是否存在：\"+f.exists());\n        System.out.println(\"绝对路径：\"+f.getAbsolutePath());\n        System.out.println(\"相对路径：\"+f.getPath());\n        System.out.println(\"toString:\"+f.toString());\n        //跟目录相关的方法：\n        File f2 = new File(\"D:\\\\a\\\\b\\\\c\");\n        //创建目录：\n        //f2.mkdir();//创建单层目录\n        //f2.mkdirs();//创建多层目录\n        //删除：如果是删除目录的话，只会删除一层，并且前提：这层目录是空的，里面没有内容，如果内容就不会被删除\n        f2.delete();\n        //查看：\n        String[] list = f.list();//文件夹下目录/文件对应的名字的数组\n        for(String s:list)&#123;\n            System.out.println(s);\n        &#125;\n        System.out.println(\"=========================\");\n        File[] files = f.listFiles();//作用更加广泛\n        for(File file:files)&#123;\n            System.out.println(file.getName()+\",\"+file.getAbsolutePath());\n        &#125;\n    &#125;\n&#125;\n# IO 流\n# 1 引入\n【1】File 类：封装文件 / 目录的各种信息，对目录 / 文件进行操作，但是我们不可以获取到文件 / 目录中的内容。\n【2】引入：IO 流：\nI/O ： Input/Output 的缩写，用于处理设备之间的数据的传输。\n【3】形象理解：IO 流 当做一根 “管”：\n\n【4】IO 流的体系结构：\n\n# 2 案例：通过 java 程序完成文件的复制操作\n# 功能分解 1：文件–》程序：FileReader\n一个字符一个字符的将文件中的内容读取到程序中了：\npublic class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //文件--》程序：\n        //1.有一个文件：----》创建一个File类的对象\n        File f = new File(\"d:\\\\Test.txt\");\n        //2.利用FileReader这个流，这个“管”怼到源文件上去   ---》创建一个FileReader的流的对象\n        FileReader fr = new FileReader(f);\n        //3.进行操作“吸”的动作  ---》读取动作\n        /*下面的代码我们验证了：如果到了文件的结尾处，那么读取的内容为-1\n        int n1 = fr.read();\n        int n2 = fr.read();\n        int n3 = fr.read();\n        int n4 = fr.read();\n        int n5 = fr.read();\n        int n6 = fr.read();\n        System.out.println(n1);\n        System.out.println(n2);\n        System.out.println(n3);\n        System.out.println(n4);\n        System.out.println(n5);\n        System.out.println(n6);*/\n        //方式1：\n        /*int n = fr.read();\n        while(n!=-1)&#123;\n            System.out.println(n);\n            n = fr.read();\n        &#125;*/\n        //方式2：\n        int n;\n        while((n = fr.read())!=-1)&#123;\n            System.out.println((char)n);\n        &#125;\n        //4.“管”不用了，就要关闭  ---》关闭流\n        //流，数据库，网络资源，靠jvm本身没有办法帮我们关闭，此时必须程序员手动关闭：\n        fr.close();\n    &#125;\n&#125;\n想一次性读取五个字符，不够的话下次再读五个字符：\npublic class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //文件--》程序：\n        //1.创建一个File类的对象\n        File f = new File(\"d:\\\\Test.txt\");\n        //2.创建一个FileReader的流的对象\n        FileReader fr = new FileReader(f);\n        //3.读取动作\n        //引入一个“快递员的小车”，这个“小车”一次拉5个快递：\n        char[] ch = new char[5];//缓冲数组\n        int len = fr.read(ch);//一次读取五个:返回值是这个数组中 的有效长度\n        while(len!=-1)&#123;\n            //System.out.println(len);\n            //错误方式：\n            /*for (int i = 0 ;i &lt; ch.length;i++)&#123;\n                System.out.println(ch[i]);\n            &#125;*/\n            //正确方式：\n            /*for (int i = 0 ;i &lt; len;i++)&#123;\n                System.out.println(ch[i]);\n            &#125;*/\n            //正确方式2：将数组转为String：\n            String str = new String(ch,0,len);\n            System.out.print(str);\n            len = fr.read(ch);\n        &#125;\n        //4.关闭流\n        fr.close();\n    &#125;\n&#125;\n# 功能分解 2：程序–》文件：FileWriter\n一个字符一个字符的向外输出：\npublic class Test03 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.有个目标文件：\n        File f = new File(\"d:\\\\demo.txt\");\n        //2.FileWriter管怼到文件上去：\n        FileWriter fw = new FileWriter(f);\n        //3.开始动作：输出动作：\n        //一个字符一个字符的往外输出：\n        String str = \"hello你好\";\n        for (int i = 0 ;i &lt; str.length();i++)&#123;\n            fw.write(str.charAt(i));\n        &#125;\n        //4.关闭流：\n        fw.close();\n    &#125;\n&#125;\n\n发现：\n如果目标文件不存在的话，那么会自动创建此文件。\n如果目标文件存在的话：\nnew FileWriter (f)   相当于对原文件进行覆盖操作。\nnew FileWriter (f,false)  相当于对源文件进行覆盖操作。不是追加。\nnew FileWriter (f,true)   对原来的文件进行追加，而不是覆盖。\n利用缓冲数组：向外输出（利用缓冲数组：）\npublic class Test03 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.有个目标文件：\n        File f = new File(\"d:\\\\demo.txt\");\n        //2.FileWriter管怼到文件上去：\n        FileWriter fw = new FileWriter(f,true);\n        //3.开始动作：输出动作：\n        //一个字符一个字符的往外输出：\n        String str = \"你好中国\";\n        char[] chars = str.toCharArray();\n        fw.write(chars);\n        //4.关闭流：\n        fw.close();\n    &#125;\n&#125;\n# 功能分解 3：利用 FileReader，FileWriter 文件复制\npublic class Test04 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.有一个源文件\n        File f1 = new File(\"d:\\\\Test.txt\");\n        //2.有一个目标文件：\n        File f2 = new File(\"d:\\\\Demo.txt\");\n        //3.搞一个输入的管 怼到源文件上：\n        FileReader fr = new FileReader(f1);\n        //4.搞一个输出的管，怼到目标文件上：\n        FileWriter fw = new FileWriter(f2);\n        //5.开始动作：\n        //方式1：一个字符一个字符的复制：\n        /*int n = fr.read();\n        while(n!=-1)&#123;\n            fw.write(n);\n            n = fr.read();\n        &#125;*/\n        //方式2：利用缓冲字符数组：\n        /*char[] ch = new char[5];\n        int len = fr.read(ch);\n        while(len!=-1)&#123;\n            fw.write(ch,0,len);//将缓冲数组中有效长度写出\n            len = fr.read(ch);\n        &#125;*/\n        //方式3：利用缓冲字符数组，将数组转为String写出。\n        char[] ch = new char[5];\n        int len = fr.read(ch);\n        while(len!=-1)&#123;\n            String s = new String(ch,0,len);\n            fw.write(s);\n            len = fr.read(ch);\n        &#125;\n        //6.关闭流：(关闭流的时候，倒着关闭，后用先关)\n        fw.close();\n        fr.close();\n    &#125;\n&#125;\n# 3 警告：不要用字符流去操作非文本文件\n文本文件：.txt   .java  .c  .cpp  —》建议使用字符流操作\n非文本文件：.jpg,  .mp3  ,   .mp4 , .doc  , .ppt  —》建议使用字节流操作\n# 4 用 try-catch-finally 处理异常方式\npublic class Test04 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args)  &#123;\n        //1.有一个源文件\n        File f1 = new File(\"d:\\\\Test.txt\");\n        //2.有一个目标文件：\n        File f2 = new File(\"d:\\\\Demo.txt\");\n        //3.搞一个输入的管 怼到源文件上：\n        FileReader fr = null;\n        FileWriter fw = null;\n        try &#123;\n            fr = new FileReader(f1);\n            //4.搞一个输出的管，怼到目标文件上：\n            fw = new FileWriter(f2);\n            //5.开始动作：\n            char[] ch = new char[5];\n            int len = fr.read(ch);\n            while(len!=-1)&#123;\n                String s = new String(ch,0,len);\n                fw.write(s);\n                len = fr.read(ch);\n            &#125;\n        &#125; catch (FileNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            //6.关闭流：(关闭流的时候，倒着关闭，后用先关)\n            try &#123;\n                if(fw!=null)&#123;//防止空指针异常\n                    fw.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(fr!=null)&#123;\n                    fr.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n# 5 FileInputStream 读取文件中内容\n【1】读取文本文件：\npublic class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //功能：利用字节流将文件中内容读到程序中来：\n        //1.有一个源文件：\n        File f = new File(\"D:\\\\Test.txt\");\n        //2.将一个字节流这个管 怼  到 源文件上：\n        FileInputStream fis = new FileInputStream(f);\n        //3.开始读取动作\n        /*\n        细节1：\n        文件是utf-8进行存储的，所以英文字符 底层实际占用1个字节\n        但是中文字符，底层实际占用3个字节。\n        细节2：\n        如果文件是文本文件，那么就不要使用字节流读取了，建议使用字符流。\n        细节3：\n        read()读取一个字节，但是你有没有发现返回值是 int类型，而不是byte类型？\n        read方法底层做了处理，让返回的数据都是“正数”\n        就是为了避免如果字节返回的是-1的话，那到底是读入的字节，还是到文件结尾呢。\n         */\n        int n = fis.read();\n        while(n!=-1)&#123;\n            System.out.println(n);\n            n = fis.read();\n        &#125;\n        //4.关闭流：\n        fis.close();\n    &#125;\n&#125;\n【2】利用字节流读取非文本文件：（以图片为案例：）–》一个字节一个字节的读取：\npublic class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //功能：利用字节流将文件中内容读到程序中来：\n        //1.有一个源文件：\n        File f = new File(\"D:\\\\LOL.jpg\");\n        //2.将一个字节流这个管 怼  到 源文件上：\n        FileInputStream fis = new FileInputStream(f);\n        //3.开始读取动作\n        int count = 0;//定义一个计数器，用来计读入的字节的个数\n        int n = fis.read();\n        while(n!=-1)&#123;\n            count++;\n            System.out.println(n);\n            n = fis.read();\n        &#125;\n        System.out.println(\"count=\"+count);\n        //4.关闭流：\n        fis.close();\n    &#125;\n&#125;\n【3】利用字节类型的缓冲数组：\npublic class Test03 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //功能：利用字节流将文件中内容读到程序中来：\n        //1.有一个源文件：\n        File f = new File(\"D:\\\\LOL.jpg\");\n        //2.将一个字节流这个管 怼  到 源文件上：\n        FileInputStream fis = new FileInputStream(f);\n        //3.开始读取动作\n        //利用缓冲数组：（快递员的小车）\n        byte[] b = new byte[1024*6];\n        int len = fis.read(b);//len指的就是读取的数组中的有效长度\n        while(len!=-1)&#123;\n            //System.out.println(len);\n            for(int i = 0;i&lt;len;i++)&#123;\n                System.out.println(b[i]);\n            &#125;\n            len = fis.read(b);\n        &#125;\n        //4.关闭流：\n        fis.close();\n    &#125;\n&#125;\n# 6 FileInputStream,FileOutputStream 完成非文本文件的复制\n【1】读入一个字节，写出一个字节：\npublic class Test04 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //功能：完成图片的复制：\n        //1.有一个源图片\n        File f1 = new File(\"d:\\\\LOL.jpg\");\n        //2.有一个目标图片：\n        File f2 = new File(\"d:\\\\LOL2.jpg\");\n        //3.有一个输入的管道 怼 到 源文件：\n        FileInputStream fis = new FileInputStream(f1);\n        //4.有一个输出的管道 怼到  目标文件上：\n        FileOutputStream fos = new FileOutputStream(f2);\n        //5.开始复制：（边读边写）\n        int n = fis.read();\n        while(n!=-1)&#123;\n            fos.write(n);\n            n = fis.read();\n        &#125;\n        //6.关闭流：(倒着关闭流，先用后关)\n        fos.close();\n        fis.close();\n    &#125;\n&#125;\n【2】利用缓冲字节数组：\npublic class Test05 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //功能：完成图片的复制：\n        //1.有一个源图片\n        File f1 = new File(\"d:\\\\LOL.jpg\");\n        //2.有一个目标图片：\n        File f2 = new File(\"d:\\\\LOL2.jpg\");\n        //3.有一个输入的管道 怼 到 源文件：\n        FileInputStream fis = new FileInputStream(f1);\n        //4.有一个输出的管道 怼到  目标文件上：\n        FileOutputStream fos = new FileOutputStream(f2);\n        //5.开始复制：（边读边写）\n        //利用缓冲数组：\n        byte[] b = new byte[1024*8];\n        int len = fis.read(b);\n        while(len!=-1)&#123;\n            fos.write(b,0,len);\n            len = fis.read(b);\n        &#125;\n        //6.关闭流：(倒着关闭流，先用后关)\n        fos.close();\n        fis.close();\n    &#125;\n&#125;\n# 7 缓冲字节流 (处理流)-BufferedInputStream ,BufferedOutputStream\n【1】读入一个字节，写出一个字节：\n【2】利用缓冲字节数组：\n【3】利用缓冲区：\n想要完成上面的效果，单纯的靠 FileInputStream,FileOutputStream 是不可以完成的，这个时候就需要功能的加强，\n这个加强就需要引入新的流（在 FileInputStream,FileOutputStream 外面再套一层流）：BufferedInputStream ,BufferedOutputStream. -----&gt; 处理流\n代码：\npublic class Test06 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.有一个源图片\n        File f1 = new File(\"d:\\\\LOL.jpg\");\n        //2.有一个目标图片：\n        File f2 = new File(\"d:\\\\LOL2.jpg\");\n        //3.有一个输入的管道 怼 到 源文件：\n        FileInputStream fis = new FileInputStream(f1);\n        //4.有一个输出的管道 怼到  目标文件上：\n        FileOutputStream fos = new FileOutputStream(f2);\n        //5.功能加强，在FileInputStream外面套一个管：BufferedInputStream:\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        //6.功能加强，在FileOutputStream外面套一个管：BufferedOutputStream:\n        BufferedOutputStream bos = new BufferedOutputStream(fos);\n        //7.开始动作 ：\n        byte[] b = new byte[1024*6];\n        int len = bis.read(b);\n        while(len!=-1)&#123;\n            bos.write(b,0,len);\n           /* bos.flush(); 底层已经帮我们做了刷新缓冲区的操作，不用我们手动完成：底层调用flushBuffer()*/\n            len = bis.read(b);\n        &#125;\n        //8.关闭流：\n        //倒着关：\n        //如果处理流包裹着节点流的话，那么其实只要关闭高级流（处理流），那么里面的字节流也会随之被关闭。\n        bos.close();\n        bis.close();\n        /*fos.close();\n        fis.close();*/\n    &#125;\n&#125;\n# 8 比对非文本文件复制的三种方法的效率\n【1】读入一个字节，写出一个字节：\n\n【2】利用缓冲字节数组：\n\n【3】利用缓冲区：\n\n代码：\npublic class Test06 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.有一个源图片\n        File f1 = new File(\"d:\\\\LOL.jpg\");\n        //2.有一个目标图片：\n        File f2 = new File(\"d:\\\\LOL2.jpg\");\n        //3.有一个输入的管道 怼 到 源文件：\n        FileInputStream fis = new FileInputStream(f1);\n        //4.有一个输出的管道 怼到  目标文件上：\n        FileOutputStream fos = new FileOutputStream(f2);\n        //5.功能加强，在FileInputStream外面套一个管：BufferedInputStream:\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        //6.功能加强，在FileOutputStream外面套一个管：BufferedOutputStream:\n        BufferedOutputStream bos = new BufferedOutputStream(fos);\n        //7.开始动作 ：\n        long startTime = System.currentTimeMillis();\n        byte[] b = new byte[1024];\n        int len = bis.read(b);\n        while(len!=-1)&#123;\n            bos.write(b,0,len);\n           /* bos.flush(); 底层已经帮我们做了刷新缓冲区的操作，不用我们手动完成：底层调用flushBuffer()*/\n            len = bis.read(b);\n        &#125;\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"复制完成的时间为：\"+(endTime-startTime));\n        //8.关闭流：\n        //倒着关：\n        //如果处理流包裹着节点流的话，那么其实只要关闭高级流（处理流），那么里面的字节流也会随之被关闭。\n        bos.close();\n        bis.close();\n        /*fos.close();\n        fis.close();*/\n    &#125;\n&#125;\n# 9 缓冲字符流 (处理流)-BufferedReader,BufferedWriter 完成文本文件的复制\npublic class Test07 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.有一个源文件：\n        File f1 = new File(\"d:\\\\Test.txt\");\n        //2.有一个目标文件：\n        File f2 = new File(\"d:\\\\Demo.txt\");\n        //3.需要一个管 怼到 源文件：\n        FileReader fr = new FileReader(f1);\n        //4.需要一根管怼到目标文件：\n        FileWriter fw = new FileWriter(f2);\n        //5.套一根管在输入字符流外面：\n        BufferedReader br = new BufferedReader(fr);\n        //6.套一根管在输出字符流外面：\n        BufferedWriter bw = new BufferedWriter(fw);\n        //7.开始动作：\n        //方式1：读取一个字符，输出一个字符：\n        /*int n = br.read();\n        while(n!=-1)&#123;\n            bw.write(n);\n            n = br.read();\n        &#125;*/\n        //方式2:利用缓冲数组：\n        /*char[] ch = new char[30];\n        int len = br.read(ch);\n        while(len!=-1)&#123;\n            bw.write(ch,0,len);\n            len = br.read(ch);\n        &#125;*/\n        //方式3：读取String：\n        String str = br.readLine();//每次读取文本文件中一行，返回字符串\n        while(str!=null)&#123;\n            bw.write(str);\n            //在文本文件中应该再写出一个换行：\n            bw.newLine();//新起一行\n            str = br.readLine();\n        &#125;\n        //8.关闭流\n        bw.close();\n        br.close();\n    &#125;\n&#125;\n# 10 转换流 - InputStreamReader,OutputStreamWriter\n【1】转换流：作用：将字节流和字符流进行转换。\n【2】转换流  属于 字节流还是字符流？属于字符流\n InputStreamReader  ：字节输入流 —》字符的输入流\n OutputStreamWriter  ： 字符输出流 --》字节的输出流\n【3】图解：\n\n【4】将输入的字节流转换为输入的字符流，然后完成文件–》程序 ：\npublic class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //文件---》程序：\n        //1.有一个源文件：\n        File f = new File(\"d:\\\\Test.txt\");\n        //2.需要一个输入的字节流接触文件：\n        FileInputStream fis = new FileInputStream(f);\n        //3.加入一个转换流，将字节流转换为字符流：（转换流属于一个处理流）\n        //将字节转换为字符的时候，需要指定一个编码，这个编码跟文件本身的编码格式统一\n        //如果编码格式不统一的话，那么在控制台上展示的效果就会出现乱码\n        //InputStreamReader isr = new InputStreamReader(fis,\"utf-8\");\n        //获取程序本身的编码--》utf-8\n        InputStreamReader isr = new InputStreamReader(fis);\n        //4.开始动作，将文件中内容显示在控制台：\n        char[] ch = new char[20];\n        int len = isr.read(ch);\n        while(len!=-1)&#123;\n            //将缓冲数组转为字符串在控制台上打印出来\n            System.out.print(new String(ch,0,len));\n            len = isr.read(ch);\n        &#125;\n        //5.关闭流：\n        isr.close();\n    &#125;\n&#125;\n# 11 转换流 - InputStreamReader,OutputStreamWriter 实现文本文件的复制\npublic class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.有一个源文件\n        File f1 = new File(\"d:\\\\Test.txt\");\n        //2.有一个目标文件：\n        File f2 = new File(\"d:\\\\Demo.txt\");\n        //3.输入方向：\n        FileInputStream fis = new FileInputStream(f1);\n        InputStreamReader isr = new InputStreamReader(fis,\"utf-8\");\n        //4.输出方向：\n        FileOutputStream fos = new FileOutputStream(f2);\n        OutputStreamWriter osw = new OutputStreamWriter(fos,\"gbk\");\n        //5.开始动作：\n        char[] ch = new char[20];\n        int len = isr.read(ch);\n        while(len!=-1)&#123;\n            osw.write(ch,0,len);\n            len = isr.read(ch);\n        &#125;\n        //6.关闭流：\n        osw.close();\n        isr.close();\n    &#125;\n&#125;\n# 12 System 类对 IO 流的支持\n【1】System 的属性：\nSystem.in  : “标准” 输入流。—》默认情况下  从键盘输入\n System.out  :“标准” 输出流。 —》默认情况下，输出到控制台。\n【2】System.in ：“标准” 输入流。—》默认情况下  从键盘输入\npublic class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //得到的是标准的输入流：--》从键盘输入：\n        //InputStream in = System.in;\n        //调用方法：\n        //int n = in.read();//read方法等待键盘的录入，所以这个方法是一个阻塞方法。\n        //System.out.println(n);\n        //以前案例：从键盘录入一个int类型的数据：\n        //从上面的代码证明，键盘录入实际上是：System.in\n        //形象的理解：System.in管，这个管怼到键盘上去了，所以你从键盘录入的话，就从这个管到程序中了\n        //Scanner的作用：扫描器：起扫描作用的，扫键盘的从这根管出来的数据\n        /*Scanner sc = new Scanner(System.in);\n        int i = sc.nextInt();\n        System.out.println(i);*/\n        //既然Scanner是扫描的作用，不一定非得扫 System.in进来的东西，还可以扫描其他管的内容：\n        Scanner sc = new Scanner(new FileInputStream(new File(\"d:\\\\Test.txt\")));\n        while(sc.hasNext())&#123;\n            System.out.println(sc.next());\n        &#125;\n    &#125;\n&#125;\n【3】System.out  : 返回的输出流 、 打印流（PrintStream）\npublic class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //写到控制台：\n        PrintStream out = System.out;\n        //调用方法：\n        out.print(\"你好1\");//直接在控制台写出，但是不换行\n        out.print(\"你好2\");\n        out.print(\"你好3\");\n        out.print(\"你好4\");\n        out.println(\"我是中国人1\");//直接在控制台写出，并且换行操作\n        out.println(\"我是中国人2\");\n        out.println(\"我是中国人3\");\n        out.println(\"我是中国人4\");\n        System.out.println(\"你是\");\n        System.out.print(\"中国人\");\n    &#125;\n&#125;\n# 13 练习：键盘录入内容输出到文件中\n【1】解决思路：\n\n【2】代码：\npublic class Test03 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.先准备输入方向：\n        //键盘录入：\n        InputStream in = System.in;//属于字节流\n        //字节流--》字符流：\n        InputStreamReader isr = new InputStreamReader(in);\n        //在isr外面再套一个缓冲流：\n        BufferedReader br = new BufferedReader(isr);\n        //2.再准备输出方向：\n        //准备目标文件\n        File f = new File(\"d:\\\\Demo1.txt\");\n        FileWriter fw = new FileWriter(f);\n        BufferedWriter bw = new BufferedWriter(fw);\n        //3.开始动作：\n        String s = br.readLine();\n        while(!s.equals(\"exit\"))&#123;\n            bw.write(s);\n            bw.newLine();//文件中换行\n            s = br.readLine();\n        &#125;\n        //4.关闭流：\n        bw.close();\n        br.close();\n    &#125;\n&#125;\n# 14 数据流 - DataInputStream,DataOutputStream\n【1】数据流：用来操作基本数据类型和字符串的\n【2】\nDataInputStream: 将文件中存储的基本数据类型和字符串  写入  内存的变量中\n DataOutputStream:  将内存中的基本数据类型和字符串的变量 写出  文件中\n【3】代码：\n利用 DataOutputStream 向外写出变量：\npublic class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //DataOutputStream:  将内存中的基本数据类型和字符串的变量 写出  文件中\n        /*File f = new File(\"d:\\\\Demo2.txt\");\n        FileOutputStream fos = new FileOutputStream(f);\n        DataOutputStream dos = new DataOutputStream(fos);*/\n        DataOutputStream dos = new DataOutputStream(new FileOutputStream(new File(\"d:\\\\Demo2.txt\")));\n        //向外将变量写到文件中去：\n        dos.writeUTF(\"你好\");\n        dos.writeBoolean(false);\n        dos.writeDouble(6.9);\n        dos.writeInt(82);\n        //关闭流：\n        dos.close();\n    &#125;\n&#125;\n在 Demo2.txt 文件中，我们看到：\n\n发现：这个内容我们看不懂，是给程序看的\n所以下面我们开始读取的程序：\npublic class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //DataInputStream:将文件中存储的基本数据类型和字符串  写入  内存的变量中\n        DataInputStream dis = new DataInputStream(new FileInputStream(new File(\"d:\\\\Demo2.txt\")));\n        //将文件中内容读取到程序中来：\n        System.out.println(dis.readUTF());\n        System.out.println(dis.readBoolean());\n        System.out.println(dis.readDouble());\n        System.out.println(dis.readInt());\n        //关闭流：\n        dis.close();\n    &#125;\n&#125;\n\n\n验证：那个文件，我们看不懂，程序看得懂\n要求：\n写出的类型跟读入的类型 必须 要匹配！\n# 15 对象流 - ObjectInputStream,ObjectOutputStream\n【1】对象流：ObjectInputStream，ObjectInputStream\n 用于存储和读取基本数据类型数据或对象的处理流。\n它的强大之处就是可以把 Java 中的对象写入到数据源中，也能把对象从数据源中还原回来。\n【2】序列化和反序列化：\nObjectOutputStream 类 ： 把内存中的 Java 对象转换成平台无关的二进制数据，从而允许把这种二进制数据持久地保存在磁盘上，或通过网络将这种二进制数据传输到另一个网络节点。----》序列化\n用 ObjectInputStream 类 ： 当其它程序获取了这种二进制数据，就可以恢复成原来的 Java 对象。----》反序列化\n【3】代码：操作字符串对象：\n首先将一个字符串对象写到文件中去：----》序列化\npublic class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(\"d:\\\\Demo3.txt\")));\n        //将内存中的字符串写出到文件中：\n        oos.writeObject(\"你好\");\n        //关闭流：\n        oos.close();\n    &#125;\n&#125;\n查看文件：\n\n我们看不懂文件的内容，但是程序是可以看懂的，所以可以写一个程序读文件中内容：----》反序列化\npublic class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;\n        //将文件中保存的字符串 读入到 内存：\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(\"d:\\\\Demo3.txt\")));\n        //读取：\n        String s = (String)(ois.readObject());\n        System.out.println(s);\n        //关闭流：\n        ois.close();\n    &#125;\n&#125;\n\n【4】代码：操作自定义类的对象：\n自定义的 Person 类：\npublic class Person &#123;\n    private String name;\n    private int age;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public Person() &#123;\n    &#125;\n    public Person(String name, int age) &#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n&#125;\n测试类：\npublic class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //序列化：将内存中对象 ---》 文件：\n        //有一个对象：\n        Person p = new Person(\"lili\",19);\n        //有对象流：\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(\"d:\\\\Demo4.txt\")));\n        //向外写：\n        oos.writeObject(p);\n        //关闭流：\n        oos.close();\n    &#125;\n&#125;\n运行的时候发现出现异常：\n\n出现异常的原因：\n\n起到标识作用，标识什么呢？只要实现这个接口的类的对象才能序列化，否则不可以。\n解决办法：将 Person 实现这个标识接口就可以：\npublic class Person implements Serializable &#123;\n    private String name;\n    private int age;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public Person() &#123;\n    &#125;\n    public Person(String name, int age) &#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n&#125;\n测试：发现序列化成功，Person 具备了序列化的能力。\n\n这个二进制数据我们看不懂，但是程序可以看懂，所以我们可以用程序实现 反序列化操作：\n将这个对象 恢复到内存中来：\npublic class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(\"d:\\\\Demo4.txt\")));\n        //读入内存：\n        Person p = (Person)(ois.readObject());\n        System.out.println(p/*.toString()*/);\n        //关闭流：\n        ois.close();\n    &#125;\n&#125;\n\n结果：\n因为我们没有重写 toString 方法，所以结果为：\n\n证明了反序列化成功：   将二进制数据 --》内存\n【5】serialVersionUID：\n凡是实现 Serializable 接口（标识接口）的类都有一个表示序列化版本标识符的静态常量:\n➢private static final long serialVersionUID;\n➢serialVersionUID 用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序加化时是否兼容。\n➢如果类没有显示定义这个静态变量，它的值是 Java 运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，显式声明。\n➢简单来说，Java 的序列化机制是通过在运行时判断类的 serialVersionUID 来验证版本一致性的。在进行反序列化时，JVM 会把传来的字节流中的 serialVersionUID 与本地相应实体类的 serialVersionUID 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)\n我现在在 Person 类中加入 toString 方法：\npublic class Person implements Serializable &#123;\n    private String name;\n    private int age;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public Person() &#123;\n    &#125;\n    public Person(String name, int age) &#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return \"Person&#123;\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '&#125;';\n    &#125;\n&#125;\n再次运行测试类：\n出现异常：\n\n出现异常的原因：\n解决：给这个类 加入一个 序列号：serialVersionUID\n\n【6】IDEA 中配置序列化版本号：\n\n在 Person 类上：alt+enter:\n\n回车即可生成\n\n【7】序列化细节：\n（1）被序列化的类的内部的所有属性，必须是可序列化的 （基本数据类型都是可序列化的）\n\n（2）static，transient 修饰的属性 不可以被序列化。\npublic class Person implements Serializable &#123;\n    private static final long serialVersionUID = 8027651838638826533L;\n    private transient String name;\n    private static int age;\n    private Famaily f = new Famaily();\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public Person() &#123;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return \"Person&#123;\" +\n                \"name='\" + name + '\\'' +\n                \", f=\" + f + \",age=\" + age +\n                '&#125;';\n    &#125;\n&#125;\n\n","slug":"第12章IO","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,IO","tags_index":"JavaSE","author_index":"雾都"},{"id":"88cf275ceb73b48b0e7d54add12d8a27","title":"第13章多线程","content":"# 简介\n【1】程序，进程，线程\n➢程序 (program)：是为完成特定任务、用某种语言编写的一组指令的集合，是一段静态的代码。 （程序是静态的）\n➢进程 (process)：是程序的一次执行过程。正在运行的一个程序，进程作为资源分配的单位，在内存中会为每个进程分配不同的内存区域。 （进程是动态的）是一个动的过程 ，进程的生命周期：有它自身的产生、存在和消亡的过程\n➢线程 (thread)，进程可进一步细化为线程， 是一个程序内部的一条执行路径。\n若一个进程同一时间并行执行多个线程，就是支持多线程的。\n\n【2】单核 CPU 与多核 CPU 的任务执行：\n\n\n【3】并行和并发：\n并行：多个 CPU 同时执行多个任务\n并发：一个 CPU “同时” 执行多个任务（采用时间片切换）\n# 1 创建线程的三种方式\n# 第一种：继承 Thread 类\n【1】在学习多线程一章之前，以前的代码是单线程的吗？不是，以前也是有三个线程同时执行的。\n\n【2】现在我想自己制造多线程 —》创建线程 ？？\n线程类–》线程对象\n\n/**\n * 线程类叫：TestThread，不是说你名字中带线程单词你就具备多线程能力了（争抢资源能力）\n * 现在想要具备能力，继承一个类：Thread，具备了争抢资源的能力\n */\npublic class TestThread extends Thread&#123;\n    /*\n    一会线程对象就要开始争抢资源了，这个线程要执行的任务到底是啥？这个任务你要放在方法中\n    但是这个方法不能是随便写的一个方法，必须是重写Thread类中的run方法\n    然后线程的任务/逻辑写在run方法中\n     */\n    @Override\n    public void run() &#123;\n        //输出1-10\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(i);\n        &#125;\n    &#125;\n&#125;\npublic class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //主线程中也要输出十个数：\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(\"main1-----\"+i);\n        &#125;\n        //制造其他线程，要跟主线程争抢资源：\n        //具体的线程对象：子线程\n        TestThread tt = new TestThread();\n        //tt.run();//调用run方法，想要执行线程中的任务 -->这个run方法不能直接调用，直接调用就会被当做一个普通方法\n        //想要tt子线程真正起作用比如要启动线程：\n        tt.start();//start()是Thread类中的方法\n        //主线程中也要输出十个数：\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(\"main2-----\"+i);\n        &#125;\n    &#125;\n&#125;\n\n运行结果：\n\n# 设置读取线程名字\n【1】setName,getName 方法来进行设置读取：\n/**\n * 线程类叫：TestThread，不是说你名字中带线程单词你就具备多线程能力了（争抢资源能力）\n * 现在想要具备能力，继承一个类：Thread，具备了争抢资源的能力\n */\npublic class TestThread extends Thread&#123;\n    /*\n    一会线程对象就要开始争抢资源了，这个线程要执行的任务到底是啥？这个任务你要放在方法中\n    但是这个方法不能是随便写的一个方法，必须是重写Thread类中的run方法\n    然后线程的任务/逻辑写在run方法中\n     */\n    @Override\n    public void run() &#123;\n        //输出1-10\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(this.getName()+i);\n        &#125;\n    &#125;\n&#125;\npublic class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //给main方法这个主线程设置名字：\n        //Thread.currentThread()作用获取当前正在执行的线程\n        Thread.currentThread().setName(\"主线程\");\n        //主线程中也要输出十个数：\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(Thread.currentThread().getName()+\"1-------\"+i);\n        &#125;\n        //制造其他线程，要跟主线程争抢资源：\n        //具体的线程对象：子线程\n        TestThread tt = new TestThread();\n        tt.setName(\"子线程\");\n        //tt.run();//调用run方法，想要执行线程中的任务 -->这个run方法不能直接调用，直接调用就会被当做一个普通方法\n        //想要tt子线程真正起作用比如要启动线程：\n        tt.start();//start()是Thread类中的方法\n        //主线程中也要输出十个数：\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(Thread.currentThread().getName()+\"2-------\"+i);\n        &#125;\n    &#125;\n&#125;\n【2】通过构造器设置 名字：\n/**\n * 线程类叫：TestThread，不是说你名字中带线程单词你就具备多线程能力了（争抢资源能力）\n * 现在想要具备能力，继承一个类：Thread，具备了争抢资源的能力\n */\npublic class TestThread extends Thread&#123;\n    public TestThread(String name)&#123;\n        super(name);//调用父类的有参构造器\n    &#125;\n    /*\n    一会线程对象就要开始争抢资源了，这个线程要执行的任务到底是啥？这个任务你要放在方法中\n    但是这个方法不能是随便写的一个方法，必须是重写Thread类中的run方法\n    然后线程的任务/逻辑写在run方法中\n     */\n    @Override\n    public void run() &#123;\n        //输出1-10\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(this.getName()+i);\n        &#125;\n    &#125;\n&#125;\n# 习题：买火车票\n【1】原理：每个窗口都是一个线程对象：\n\n【2】代码：\npublic class BuyTicketThread extends Thread &#123;\n    public BuyTicketThread(String name)&#123;\n        super(name);\n    &#125;\n    //一共10张票：\n    static int ticketNum = 10;//多个对象共享10张票\n    //每个窗口都是一个线程对象：每个对象执行的代码放入run方法中\n    @Override\n    public void run() &#123;\n        //每个窗口后面有100个人在抢票：\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            if(ticketNum > 0)&#123;//对票数进行判断，票数大于零我们才抢票\n                System.out.println(\"我在\"+this.getName()+\"买到了从北京到哈尔滨的第\" + ticketNum-- + \"张车票\");\n            &#125;\n        &#125;\n    &#125;\n&#125;\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        //多个窗口抢票：三个窗口三个线程对象：\n        BuyTicketThread t1 = new BuyTicketThread(\"窗口1\");\n        t1.start();\n        BuyTicketThread t2 = new BuyTicketThread(\"窗口2\");\n        t2.start();\n        BuyTicketThread t3 = new BuyTicketThread(\"窗口3\");\n        t3.start();\n    &#125;\n&#125;\n\n# 第二种：实现 Runnable 接口\n【1】代码：\n/**\n * TestThread实现了这个接口，才会变成一个线程类\n */\npublic class TestThread implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        //输出1-10数字：\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(Thread.currentThread().getName()+\"----\"+i);\n        &#125;\n    &#125;\n&#125;\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        //创建子线程对象：\n        TestThread tt = new TestThread();\n        Thread t = new Thread(tt,\"子线程\");\n        t.start();\n        //主线程里面也是打印1-10数字：\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(Thread.currentThread().getName()+\"---\"+i);\n        &#125;\n    &#125;\n&#125;\n运行结果：\n\n# 习题：买火车票\n【1】代码：\npublic class BuyTicketThread implements Runnable &#123;\n    int ticketNum = 10;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            if(ticketNum > 0)&#123;\n                System.out.println(\"我在\"+Thread.currentThread().getName()+\"买到了北京到哈尔滨的第\" + ticketNum-- + \"张车票\");\n            &#125;\n        &#125;\n    &#125;\n&#125;\npublic class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //定义一个线程对象：\n        BuyTicketThread t = new BuyTicketThread();\n        //窗口1买票：\n        Thread t1 = new Thread(t,\"窗口1\");\n        t1.start();\n        //窗口2买票：\n        Thread t2 = new Thread(t,\"窗口2\");\n        t2.start();\n        //窗口3买票：\n        Thread t3 = new Thread(t,\"窗口3\");\n        t3.start();\n    &#125;\n&#125;\n【2】实际开发中，方式 1 继承 Thread 类   还是  方式 2 实现 Runnable 接口这种方式多呢？–》方式 2\n（1）方式 1 的话有 Java 单继承的局限性，因为继承了 Thread 类，就不能再继承其它的类了\n（2）方式 2 的共享资源的能力也会强一些，不需要非得加个 static 来修饰\n【3】Thread 类 Runnable 接口 有联系吗？\n\n对比第一种和第二种创建线程的方式发现，无论第一种继承 Thread 类的方式还是第二种实现 Runnable 接口的方式，都需要有一个 run 方法，\n但是这个 run 方法有不足：\n\n（1）没有返回值\n（2）不能抛出异常\n基于上面的两个不足，在 JDK1.5 以后出现了第三种创建线程的方式：实现 Callable 接口：\n实现 Callable 接口好处：（1）有返回值  （2）能抛出异常\n缺点：线程创建比较麻烦\npublic class TestRandomNum implements Callable&lt;Integer> &#123;\n    /*\n    1.实现Callable接口，可以不带泛型，如果不带泛型，那么call方式的返回值就是Object类型\n    2.如果带泛型，那么call的返回值就是泛型对应的类型\n    3.从call方法看到：方法有返回值，可以跑出异常\n     */\n    @Override\n    public Integer call() throws Exception &#123;\n        return new Random().nextInt(10);//返回10以内的随机数\n    &#125;\n&#125;\nclass Test&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        //定义一个线程对象：\n        TestRandomNum trn = new TestRandomNum();\n        FutureTask ft = new FutureTask(trn);\n        Thread t = new Thread(ft);\n        t.start();\n        //获取线程得到的返回值：\n        Object obj = ft.get();\n        System.out.println(obj);\n    &#125;\n&#125;\n# 2 线程的生命周期\n【1】线程声明周期：线程开始–》线程消亡\n【2】线程经历哪些阶段：\n\n# 3 线程常见方法\n（1）start () :  启动当前线程，表面上调用 start 方法，实际在调用线程里面的 run 方法\n（2）run () : 线程类 继承 Thread 类 或者 实现 Runnable 接口的时候，都要重新实现这个 run 方法，run 方法里面是线程要执行的内容\n（3）currentThread :Thread 类中一个静态方法：获取当前正在执行的线程\n（4）setName 设置线程名字\n（5）getName 读取线程名字\n# 设置优先级\n【1】同优先级别的线程，采取的策略就是先到先服务，使用时间片策略\n【2】如果优先级别高，被 CPU 调度的概率就高\n【3】级别：1-10   默认的级别为 5\n\n【4】代码：\npublic class TestThread01 extends Thread &#123;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10; i++) &#123;\n            System.out.println(i);\n        &#125;\n    &#125;\n&#125;\nclass TestThread02 extends Thread&#123;\n    @Override\n    public void run() &#123;\n        for (int i = 20; i &lt;= 30 ; i++) &#123;\n            System.out.println(i);\n        &#125;\n    &#125;\n&#125;\nclass Test&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建两个子线程，让这两个子线程争抢资源：\n        TestThread01 t1 = new TestThread01();\n        t1.setPriority(10);//优先级别高\n        t1.start();\n        TestThread02 t2 = new TestThread02();\n        t2.setPriority(1);//优先级别低\n        t2.start();\n    &#125;\n&#125;\n# join\njoin 方法：当一个线程调用了 join 方法，这个线程就会先被执行，它执行结束以后才可以去执行其余的线程。\n\n\n\n\n\n\n\n\n\n注意：必须先 start，再 join 才有效。\npublic class TestThread extends Thread &#123;\n    public TestThread(String name)&#123;\n        super(name);\n    &#125;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(this.getName()+\"----\"+i);\n        &#125;\n    &#125;\n&#125;\nclass Test&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws InterruptedException &#123;\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            System.out.println(\"main-----\"+i);\n            if(i == 6)&#123;\n                //创建子线程：\n                TestThread tt = new TestThread(\"子线程\");\n                tt.start();\n                tt.join();//“半路杀出个程咬金”\n            &#125;\n        &#125;\n    &#125;\n&#125;\n# sleep\nhttps://go.zbj.com/news/20146.html （段子）\n【1】sleep : 人为的制造阻塞事件\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        try &#123;\n            Thread.sleep(3000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(\"00000000000000\");\n    &#125;\n&#125;\n【2】案例：完成秒表功能：\npublic class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //2.定义一个时间格式：\n        DateFormat df = new SimpleDateFormat(\"HH:mm:ss\");\n        while(true)&#123;\n            //1.获取当前时间：\n            Date d = new Date();\n            //3.按照上面定义的格式将Date类型转为指定格式的字符串：\n            System.out.println(df.format(d));\n            try &#123;\n                Thread.sleep(1000);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n# setDaemon\n【1】设置伴随线程\n将子线程设置为主线程的伴随线程，主线程停止的时候，子线程也不要继续执行了\n案例：皇上 --》驾崩 —》妃子陪葬\npublic class TestThread extends Thread &#123;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 1000 ; i++) &#123;\n            System.out.println(\"子线程----\"+i);\n        &#125;\n    &#125;\n&#125;\nclass Test&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建并启动子线程：\n        TestThread tt = new TestThread();\n        tt.setDaemon(true);//设置伴随线程  注意：先设置，再启动\n        tt.start();\n        //主线程中还要输出1-10的数字：\n        for (int i = 1; i &lt;= 10 ; i++) &#123;\n            System.out.println(\"main---\"+i);\n        &#125;\n    &#125;\n&#125;\n结果：\n\n# stop\npublic class Demo &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            if(i == 6)&#123;\n                Thread.currentThread().stop();//过期方法，不建议使用\n            &#125;\n            System.out.println(i);\n        &#125;\n    &#125;\n&#125;\n# 4 线程安全问题\n# 方法 1：同步代码块\n【1】同步代码块演示 1：\npackage com.msb.test04;\n/**\n * @author : msb-zhaoss\n */\npublic class BuyTicketThread implements Runnable &#123;\n    int ticketNum = 10;\n    @Override\n    public void run() &#123;\n        //此处有1000行代码\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            synchronized (this)&#123;//把具有安全隐患的代码锁住即可，如果锁多了就会效率低 --》this就是这个锁\n                if(ticketNum > 0)&#123;\n                    System.out.println(\"我在\"+Thread.currentThread().getName()+\"买到了北京到哈尔滨的第\" + ticketNum-- + \"张车票\");\n                &#125;\n            &#125;\n        &#125;\n        //此处有1000行代码\n    &#125;\n&#125;\n【2】同步代码块演示 2：\npublic class BuyTicketThread extends Thread &#123;\n    public BuyTicketThread(String name)&#123;\n        super(name);\n    &#125;\n    //一共10张票：\n    static int ticketNum = 10;//多个对象共享10张票\n    //每个窗口都是一个线程对象：每个对象执行的代码放入run方法中\n    @Override\n    public void run() &#123;\n        //每个窗口后面有100个人在抢票：\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            synchronized (BuyTicketThread.class)&#123;//锁必须多个线程用的是同一把锁！！！\n                if(ticketNum > 0)&#123;//对票数进行判断，票数大于零我们才抢票\n                    System.out.println(\"我在\"+this.getName()+\"买到了从北京到哈尔滨的第\" + ticketNum-- + \"张车票\");\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n# 方法 2：同步方法\n【1】代码展示：\npublic class BuyTicketThread implements Runnable &#123;\n    int ticketNum = 10;\n    @Override\n    public void run() &#123;\n        //此处有1000行代码\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            buyTicket();\n        &#125;\n        //此处有1000行代码\n    &#125;\n    public synchronized void buyTicket()&#123;//锁住的是this\n        if(ticketNum > 0)&#123;\n            System.out.println(\"我在\"+Thread.currentThread().getName()+\"买到了北京到哈尔滨的第\" + ticketNum-- + \"张车票\");\n        &#125;\n    &#125;\n&#125;\npublic class BuyTicketThread extends Thread &#123;\n    public BuyTicketThread(String name)&#123;\n        super(name);\n    &#125;\n    //一共10张票：\n    static int ticketNum = 10;//多个对象共享10张票\n    //每个窗口都是一个线程对象：每个对象执行的代码放入run方法中\n    @Override\n    public void run() &#123;\n        //每个窗口后面有100个人在抢票：\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            buyTicket();\n        &#125;\n    &#125;\n    public static synchronized void buyTicket()&#123;//锁住的  同步监视器： BuyTicketThread.class\n        if(ticketNum > 0)&#123;//对票数进行判断，票数大于零我们才抢票\n            System.out.println(\"我在\"+Thread.currentThread().getName()+\"买到了从北京到哈尔滨的第\" + ticketNum-- + \"张车票\");\n        &#125;\n    &#125;\n&#125;\n【2】总结：\n总结 1：\n多线程在争抢资源，就要实现线程的同步（就要进行加锁，并且这个锁必须是共享的，必须是唯一的。\n咱们的锁一般都是引用数据类型的。\n目的：解决了线程安全问题。\n总结 2：关于同步方法\n\n不要将 run () 定义为同步方法\n非静态同步方法的同步监视器是 this\n 静态同步方法的同步监视器是 类名.class 字节码信息对象\n同步代码块的效率要高于同步方法\n原因：同步方法是将线程挡在了方法的外部，而同步代码块锁将线程挡在了代码块的外部，但是却是方法的内部\n同步方法的锁是 this，一旦锁住一个方法，就锁住了所有的同步方法；同步代码块只是锁住使用该同步监视器的代码块，而没有锁住使用其他监视器的代码块\n\n# 方法 3：Lock 锁\n【1】Lock 锁引入：\nJDK1.5 后新增新一代的线程同步方式：Lock 锁\n与采用 synchronized 相比，lock 可提供多种锁方案，更灵活\nsynchronized 是 Java 中的关键字，这个关键字的识别是靠 JVM 来识别完成的呀。是虚拟机级别的。\n但是 Lock 锁是 API 级别的，提供了相应的接口和对应的实现类，这个方式更灵活，表现出来的性能优于之前的方式。\n【2】代码演示：\npublic class BuyTicketThread implements Runnable &#123;\n    int ticketNum = 10;\n    //拿来一把锁：\n    Lock lock = new ReentrantLock();//多态  接口=实现类  可以使用不同的实现类\n    @Override\n    public void run() &#123;\n        //此处有1000行代码\n        for (int i = 1; i &lt;= 100 ; i++) &#123;\n            //打开锁：\n            lock.lock();\n            try&#123;\n                if(ticketNum > 0)&#123;\n                    System.out.println(\"我在\"+Thread.currentThread().getName()+\"买到了北京到哈尔滨的第\" + ticketNum-- + \"张车票\");\n                &#125;\n            &#125;catch (Exception ex)&#123;\n                ex.printStackTrace();\n            &#125;finally &#123;\n                //关闭锁：--->即使有异常，这个锁也可以得到释放\n                lock.unlock();\n            &#125;\n        &#125;\n        //此处有1000行代码\n    &#125;\n&#125;\n【3】 Lock 和 synchronized 的区别\n    1.Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁\n    2.Lock只有代码块锁，synchronized有代码块锁和方法锁\n    3.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）\n\n【4】优先使用顺序：\n    Lock----同步代码块（已经进入了方法体，分配了相应资源）----同步方法（在方法体之外）\n\n# 线程同步的优缺点\n【1】对比：\n线程安全，效率低\n线程不安全，效率高\n【2】可能造成死锁：\n死锁\n\n\n\n\n\n\n\n\n\n不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁\n出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续\n【3】代码演示：\npublic class TestDeadLock implements Runnable &#123;\n    public int flag = 1;\n    static Object o1 = new Object(),o2 = new Object();\n        \n        \n    public void run()&#123;\n        System.out.println(\"flag=\" + flag);\n        // 当flag==1锁住o1\n        if (flag == 1) &#123;\n            synchronized (o1) &#123;\n                try &#123;\n                    Thread.sleep(500);\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n                // 只要锁住o2就完成\n                synchronized (o2) &#123;\n                    System.out.println(\"2\");\n                &#125;\n            &#125;\n        &#125;\n        // 如果flag==0锁住o2\n        if (flag == 0) &#123;\n            synchronized (o2) &#123;\n                try &#123;\n                    Thread.sleep(500);\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\n                // 只要锁住o1就完成\n                synchronized (o1) &#123;\n                    System.out.println(\"3\");\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n        \n        \n    public static void main(String[] args) &#123;\n        // 实例2个线程类\n        TestDeadLock td1 = new TestDeadLock();\n        TestDeadLock td2 = new TestDeadLock();\n        td1.flag = 1;\n        td2.flag = 0;\n        // 开启2个线程\n        Thread t1 = new Thread(td1);\n        Thread t2 = new Thread(td2);\n        t1.start();\n        t2.start();\n    &#125;\n&#125;\n【4】解决方法： 减少同步资源的定义，避免嵌套同步\n# 5 线程通信问题\n应用场景：生产者和消费者问题\n假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费\n如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止\n如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止\n\n代码结果展示：\n\n代码：\n1. 商品：属性：品牌 ，名字\n 2. 线程 1：生产者\n 3. 线程 2：消费者\n# 分解 1\n出现问题：\n1. 生产者和消费者没有交替输出\n2. 打印数据错乱\n哈尔滨 - null\n 费列罗啤酒\n哈尔滨巧克力\n ---- 没有加同步\n代码展示：\npublic class Product &#123;//商品类\n    //品牌\n    private String brand;\n    //名字\n    private String name;\n    //setter,getter方法；\n    public String getBrand() &#123;\n        return brand;\n    &#125;\n    public void setBrand(String brand) &#123;\n        this.brand = brand;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n&#125;\n\npublic class ProducerThread extends Thread&#123;//生产者线程\n    //共享商品：\n    private Product p;\n    public ProducerThread(Product p) &#123;\n        this.p = p;\n    &#125;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10 ; i++) &#123;//生产十个商品 i:生产的次数\n            if(i % 2 == 0)&#123;\n                //生产费列罗巧克力\n                p.setBrand(\"费列罗\");\n                try &#123;\n                    Thread.sleep(100);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                p.setName(\"巧克力\");\n            &#125;else&#123;\n                //生产哈尔滨啤酒\n                p.setBrand(\"哈尔滨\");\n                try &#123;\n                    Thread.sleep(100);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                p.setName(\"啤酒\");\n            &#125;\n            //将生产信息做一个打印：\n            System.out.println(\"生产者生产了：\" + p.getBrand() + \"---\" + p.getName());\n        &#125;\n    &#125;\n&#125;\npublic class CustomerThread extends Thread&#123;//消费者线程\n    //共享商品：\n    private Product p;\n    public CustomerThread(Product p) &#123;\n        this.p = p;\n    &#125;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10 ; i++) &#123;//i:消费次数\n            System.out.println(\"消费者消费了：\" + p.getBrand() + \"---\" + p.getName());\n        &#125;\n    &#125;\n&#125;\n# 分解 2\n【1】利用同步代码块解决问题：\npublic class ProducerThread extends Thread&#123;//生产者线程\n    //共享商品：\n    private Product p;\n    public ProducerThread(Product p) &#123;\n        this.p = p;\n    &#125;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10 ; i++) &#123;//生产十个商品 i:生产的次数\n            synchronized (p)&#123;\n                if(i % 2 == 0)&#123;\n                    //生产费列罗巧克力\n                    p.setBrand(\"费列罗\");\n                    try &#123;\n                        Thread.sleep(100);\n                    &#125; catch (InterruptedException e) &#123;\n                        e.printStackTrace();\n                    &#125;\n                    p.setName(\"巧克力\");\n                &#125;else&#123;\n                    //生产哈尔滨啤酒\n                    p.setBrand(\"哈尔滨\");\n                    try &#123;\n                        Thread.sleep(100);\n                    &#125; catch (InterruptedException e) &#123;\n                        e.printStackTrace();\n                    &#125;\n                    p.setName(\"啤酒\");\n                &#125;\n                //将生产信息做一个打印：\n                System.out.println(\"生产者生产了：\" + p.getBrand() + \"---\" + p.getName());\n            &#125;\n        &#125;\n    &#125;\n&#125;\npublic class CustomerThread extends Thread&#123;//消费者线程\n    //共享商品：\n    private Product p;\n    public CustomerThread(Product p) &#123;\n        this.p = p;\n    &#125;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10 ; i++) &#123;//i:消费次数\n            synchronized (p)&#123;\n                System.out.println(\"消费者消费了：\" + p.getBrand() + \"---\" + p.getName());\n            &#125;\n        &#125;\n    &#125;\n&#125;\n【2】利用同步方法解决问题：\npublic class Product &#123;//商品类\n    //品牌\n    private String brand;\n    //名字\n    private String name;\n    //setter,getter方法；\n    public String getBrand() &#123;\n        return brand;\n    &#125;\n    public void setBrand(String brand) &#123;\n        this.brand = brand;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    //生产商品\n    public synchronized void setProduct(String brand,String name)&#123;\n        this.setBrand(brand);\n        try &#123;\n            Thread.sleep(100);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        this.setName(name);\n        //将生产信息做一个打印：\n        System.out.println(\"生产者生产了：\" + this.getBrand() + \"---\" + this.getName());\n    &#125;\n    //消费商品：\n    public synchronized void getProduct()&#123;\n        System.out.println(\"消费者消费了：\" + this.getBrand() + \"---\" + this.getName());\n    &#125;\n&#125;\npublic class CustomerThread extends Thread&#123;//消费者线程\n    //共享商品：\n    private Product p;\n    public CustomerThread(Product p) &#123;\n        this.p = p;\n    &#125;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10 ; i++) &#123;//i:消费次数\n            p.getProduct();;\n        &#125;\n    &#125;\n&#125;\npublic class ProducerThread extends Thread&#123;//生产者线程\n    //共享商品：\n    private Product p;\n    public ProducerThread(Product p) &#123;\n        this.p = p;\n    &#125;\n    @Override\n    public void run() &#123;\n        for (int i = 1; i &lt;= 10 ; i++) &#123;//生产十个商品 i:生产的次数\n            if(i % 2 == 0)&#123;\n                p.setProduct(\"费列罗\",\"巧克力\");\n            &#125;else&#123;\n                p.setProduct(\"哈尔滨\",\"啤酒\");\n            &#125;\n        &#125;\n    &#125;\n&#125;\n（这个 else 中的代码在分解 3 中 演示了错误）\n# 分解 3\n【1】原理：\n\n【2】代码：\npublic class Product &#123;//商品类\n    //品牌\n    private String brand;\n    //名字\n    private String name;\n    //引入一个灯：true:红色  false 绿色\n    boolean flag = false;//默认情况下没有商品 让生产者先生产  然后消费者再消费\n    //setter,getter方法；\n    public String getBrand() &#123;\n        return brand;\n    &#125;\n    public void setBrand(String brand) &#123;\n        this.brand = brand;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    //生产商品\n    public synchronized void setProduct(String brand,String name)&#123;\n        if(flag == true)&#123;//灯是红色，证明有商品，生产者不生产，等着消费者消费\n            try &#123;\n                wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        //灯是绿色的，就生产：\n        this.setBrand(brand);\n        try &#123;\n            Thread.sleep(100);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        this.setName(name);\n        //将生产信息做一个打印：\n        System.out.println(\"生产者生产了：\" + this.getBrand() + \"---\" + this.getName());\n        //生产完以后，灯变色：变成红色：\n        flag = true;\n        //告诉消费者赶紧来消费：\n        notify();\n    &#125;\n    //消费商品：\n    public synchronized void getProduct()&#123;\n        if(!flag)&#123;//flag == false没有商品，等待生产者生产：\n            try &#123;\n                wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n        //有商品，消费：\n        System.out.println(\"消费者消费了：\" + this.getBrand() + \"---\" + this.getName());\n        //消费完：灯变色：\n        flag = false;\n        //通知生产者生产：\n        notify();\n    &#125;\n&#125;\n【3】原理：\n\n注意：wait 方法和 notify 方法  是必须放在同步方法或者同步代码块中才生效的 （因为在同步的基础上进行线程的通信才是有效的）\n注意：sleep 和 wait 的区别：sleep 进入阻塞状态没有释放锁，wait 进入阻塞状态但是同时释放了锁\n【4】线程生命周期完整图：\n\n# Loc 锁情况下的线程通信\nCondition 是在 Java 1.5 中才出现的，它用来替代传统的 Object 的 wait ()、notify () 实现线程间的协作，相比使用 Object 的 wait ()、notify ()，使用 Condition1 的 await ()、signal () 这种方式实现线程间协作更加安全和高效。\n它的更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个 Condition，在不同的情况下使用不同的 Condition\n一个 Condition 包含一个等待队列。一个 Lock 可以产生多个 Condition，所以可以有多个等待队列。\n在 Object 的监视器模型上，一个对象拥有一个同步队列和等待队列，而 Lock（同步器）拥有一个同步队列和多个等待队列。\nObject 中的 wait (),notify (),notifyAll () 方法是和 &quot;同步锁&quot;(synchronized 关键字) 捆绑使用的；而 Condition 是需要与 &quot;互斥锁&quot;/&quot;共享锁&quot; 捆绑使用的。\n调用 Condition 的 await ()、signal ()、signalAll () 方法，都必须在 lock 保护之内，就是说必须在 lock.lock () 和 lock.unlock 之间才可以使用 \n・Conditon 中的 await () 对应 Object 的 wait ()；\n・Condition 中的 signal () 对应 Object 的 notify ()；\n・Condition 中的 signalAll () 对应 Object 的 notifyAll ()。\nvoid await()  throws InterruptedException\n造成当前线程在接到信号或被中断之前一直处于等待状态。\n与此 Condition 相关的锁以原子方式释放，并且出于线程调度的目的，将禁用当前线程，且在发生以下四种情况之一 以前，当前线程将一直处于休眠状态：\n・其他某个线程调用此 Condition 的 signal () 方法，并且碰巧将当前线程选为被唤醒的线程；或者\n・其他某个线程调用此 Condition 的 signalAll () 方法；或者\n・其他某个线程中断当前线程，且支持中断线程的挂起；或者\n・发生 “虚假唤醒”\n在所有情况下，在此方法可以返回当前线程之前，都必须重新获取与此条件有关的锁。在线程返回时，可以保证它保持此锁。\nvoid signal()\n唤醒一个等待线程。\n如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。\nvoid signalAll()\n唤醒所有等待线程。\n如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。\n更改代码：\n\npublic class Product &#123;//商品类\n    //品牌\n    private String brand;\n    //名字\n    private String name;\n    //声明一个Lock锁：\n    Lock lock = new ReentrantLock();\n    //搞一个生产者的等待队列：\n    Condition produceCondition = lock.newCondition();\n    //搞一个消费者的等待队列：\n    Condition consumeCondition = lock.newCondition();\n    //引入一个灯：true:红色  false 绿色\n    boolean flag = false;//默认情况下没有商品 让生产者先生产  然后消费者再消费\n    //setter,getter方法；\n    public String getBrand() &#123;\n        return brand;\n    &#125;\n    public void setBrand(String brand) &#123;\n        this.brand = brand;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    //生产商品\n    public void setProduct(String brand,String name)&#123;\n        lock.lock();\n        try&#123;\n            if(flag == true)&#123;//灯是红色，证明有商品，生产者不生产，等着消费者消费\n                try &#123;\n                    //wait();\n                    //生产者阻塞，生产者进入等待队列中\n                    produceCondition.await();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            //灯是绿色的，就生产：\n            this.setBrand(brand);\n            try &#123;\n                Thread.sleep(100);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            this.setName(name);\n            //将生产信息做一个打印：\n            System.out.println(\"生产者生产了：\" + this.getBrand() + \"---\" + this.getName());\n            //生产完以后，灯变色：变成红色：\n            flag = true;\n            //告诉消费者赶紧来消费：\n            //notify();\n            consumeCondition.signal();\n        &#125;finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n    //消费商品：\n    public void getProduct()&#123;\n        lock.lock();\n        try&#123;\n            if(!flag)&#123;//flag == false没有商品，等待生产者生产：\n                try &#123;\n                   // wait();\n                    //消费者等待，消费者线程进入等待队列：\n                    consumeCondition.await();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            //有商品，消费：\n            System.out.println(\"消费者消费了：\" + this.getBrand() + \"---\" + this.getName());\n            //消费完：灯变色：\n            flag = false;\n            //通知生产者生产：\n            //notify();\n            produceCondition.signal();\n        &#125;finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;\n# 未完成！！！！！！！！！！\n","slug":"第13章多线程","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,多线程","tags_index":"JavaSE","author_index":"雾都"},{"id":"eca75e640f1108d70a0a6ef373851af4","title":"第11章集合","content":"# 11 集合\n\n\n# Colletion 接口\n# 1.1 常用方法\npackage com.msb.test01;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n/**\n * @author : msb-zhaoss\n */\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        /*\n        Collection接口的常用方法：\n        增加：add(E e) addAll(Collection&lt;? extends E> c)\n        删除：clear() remove(Object o)\n        修改：\n        查看：iterator() size()\n        判断：contains(Object o)  equals(Object o) isEmpty()\n         */\n        //创建对象：接口不能创建对象，利用实现类创建对象：\n        Collection col = new ArrayList();\n        //调用方法：\n        //集合有一个特点：只能存放引用数据类型的数据，不能是基本数据类型\n        //基本数据类型自动装箱，对应包装类。int--->Integer\n        col.add(18);\n        col.add(12);\n        col.add(11);\n        col.add(17);\n        System.out.println(col/*.toString()*/);\n        List list = Arrays.asList(new Integer[]&#123;11, 15, 3, 7, 1&#125;);\n        col.addAll(list);//将另一个集合添加入col中\n        System.out.println(col);\n        //col.clear();清空集合\n        System.out.println(col);\n        System.out.println(\"集合中元素的数量为：\"+col.size());\n        System.out.println(\"集合是否为空：\"+col.isEmpty());\n        boolean isRemove = col.remove(15);\n        System.out.println(col);\n        System.out.println(\"集合中数据是否被删除：\"+isRemove);\n        Collection col2 = new ArrayList();\n        col2.add(18);\n        col2.add(12);\n        col2.add(11);\n        col2.add(17);\n        Collection col3 = new ArrayList();\n        col3.add(18);\n        col3.add(12);\n        col3.add(11);\n        col3.add(17);\n        System.out.println(col2.equals(col3));\n        System.out.println(col2==col3);//地址一定不相等  false\n        System.out.println(\"是否包含元素：\"+col3.contains(117));\n    &#125;\n&#125;\n\n# 1.2 Collection 集合的遍历\n迭代器简要原理图：\n\n\n\npackage com.msb.test01;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n/**\n * @author : msb-zhaoss\n */\npublic class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        Collection col = new ArrayList();\n        col.add(18);\n        col.add(12);\n        col.add(11);\n        col.add(17);\n        col.add(\"abc\");\n        col.add(9.8);\n        //对集合遍历（对集合中元素进行查看）\n        //方式1：普通for循环\n        /*for(int i= 0;i&lt;col.size();i++)&#123;\n            col.\n        &#125;*/\n        //方式2：增强for循环\n        for(Object o:col)&#123;\n            System.out.println(o);\n        &#125;\n        System.out.println(\"------------------------\");\n        //方式3：iterator()\n        Iterator it = col.iterator();\n        while(it.hasNext())&#123;\n            System.out.println(it.next());\n        &#125;\n    &#125;\n&#125;\n\n# 2 List 接口\n# 2.1 常用方法和遍历方式\npackage com.msb.test01;\nimport com.sun.org.apache.xerces.internal.dom.PSVIAttrNSImpl;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n/**\n * @author : msb-zhaoss\n */\npublic class Test03 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        /*\n        List接口中常用方法：\n        增加：add(int index, E element)\n        删除：remove(int index)  remove(Object o)\n        修改：set(int index, E element)\n        查看：get(int index)\n        判断：\n         */\n        List list = new ArrayList();\n        list.add(13);\n        list.add(17);\n        list.add(6);\n        list.add(-1);\n        list.add(2);\n        list.add(\"abc\");\n        System.out.println(list);\n        list.add(3,66);\n        System.out.println(list);\n        list.set(3,77);\n        System.out.println(list);\n        list.remove(2);//在集合中存入的是Integer类型数据的时候，调用remove方法调用的是：remove(int index)\n        System.out.println(list);\n        list.remove(\"abc\");\n        System.out.println(list);\n        Object o = list.get(0);\n        System.out.println(o);\n        //List集合 遍历：\n        //方式1：普通for循环：\n        System.out.println(\"---------------------\");\n        for(int i = 0;i&lt;list.size();i++)&#123;\n            System.out.println(list.get(i));\n        &#125;\n        //方式2：增强for循环：\n        System.out.println(\"---------------------\");\n        for(Object obj:list)&#123;\n            System.out.println(obj);\n        &#125;\n        //方式3：迭代器：\n        System.out.println(\"---------------------\");\n        Iterator it = list.iterator();\n        while(it.hasNext())&#123;\n            System.out.println(it.next());\n        &#125;\n    &#125;\n&#125;\n# 2.2 ArrayList 实现类（JDK1.7）\n底层重要属性：\n\n在 JDK1.7 中：在调用构造器的时候给底层数组 elementData 初始化，数组初始化长度为 10：\n\n对应内存：\n\n调用 add 方法：\nArrayList al = new ArrayList();\n  System.out.println(al.add(\"abc\"));\n  System.out.println(al.add(\"def\"));\n\n当数组中的 10 个位置都满了的时候就开始进行数组的扩容，扩容长度为 原数组的 1.5 倍：\n\n\n\n# 2.3 ArrayList 实现类（JDK1.8）\n【1】JDK1.8 底层依旧是 Object 类型的数组，size: 数组中有效长度：\n\n【2】ArrayList al = new ArrayList (); 调用空构造器：\n\n【3】add 方法：\n\n\n\n\n# 2.4 Vector 实现类\n【1】底层 Object 数组，int 类型属性表示数组中有效长度：\n\n【2】Vector v=new Vector (); 调用构造器：\n【3】add 方法：\n\n# 2.5 泛型\n【1】什么是泛型（Generic）：\n泛型就相当于标签\n形式：&lt;&gt;\n 集合容器类在设计阶段 / 声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在 JDK1.5 之前只能把元素类型设计为 Object，\nJDK1.5 之 后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。\nCollection, List， ArrayList 这个就是类型参数，即泛型。\n【2】没有泛型的时候使用集合：\npackage com.msb.test01;\nimport java.util.ArrayList;\n/**\n * @author : msb-zhaoss\n */\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个ArrayList集合，向这个集合中存入学生的成绩：\n        ArrayList al = new ArrayList();\n        al.add(98);\n        al.add(18);\n        al.add(39);\n        al.add(60);\n        al.add(83);\n        al.add(\"丽丽\");\n        //对集合遍历查看：\n        for(Object obj:al)&#123;\n            System.out.println(obj);\n        &#125;\n    &#125;\n&#125;\n如果不使用泛型的话，有缺点：\n一般我们在使用的时候基本上往集合中存入的都是相同类型的数据–》便于管理，所以现在什么引用数据类型都可以存入集合，不方便！\n【3】JDK1.5 以后开始使用泛型，集合中使用泛型：\npackage com.msb.test01;\nimport java.util.ArrayList;\n/**\n * @author : msb-zhaoss\n */\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个ArrayList集合，向这个集合中存入学生的成绩：\n        //加入泛型的优点：在编译时期就会对类型进行检查，不是泛型对应的类型就不可以添加入这个集合。\n        ArrayList&lt;Integer> al = new ArrayList&lt;Integer>();\n        al.add(98);\n        al.add(18);\n        al.add(39);\n        al.add(60);\n        al.add(83);\n        /*al.add(\"丽丽\");\n        al.add(9.8);*/\n        //对集合遍历查看：\n        /*for(Object obj:al)&#123;\n            System.out.println(obj);\n        &#125;*/\n        for(Integer i:al)&#123;\n            System.out.println(i);\n        &#125;\n    &#125;\n&#125;\n【4】泛型总结：\n（1）JDK1.5 以后\n（2）泛型实际就是 一个 &lt;&gt; 引起来的 参数类型，这个参数类型  具体在使用的时候才会确定具体的类型。\n\n（3）使用了泛型以后，可以确定集合中存放数据的类型，在编译时期就可以检查出来。\n（4）使用泛型你可能觉得麻烦，实际使用了泛型才会简单，后续的遍历等操作简单。\n（5）泛型的类型：都是引用数据类型，不能是基本数据类型。\n（6）ArrayList al = new ArrayList(); 在 JDK1.7 以后可以写为：\nArrayList al = new ArrayList&lt;&gt;();  --&lt;&gt;  — 钻石运算符\n# 2.5.1 自定义泛型结构\n泛型类，泛型接口\n【1】泛型类的定义和实例化：\npackage com.msb.test02;\n/**\n * @author : msb-zhaoss\n * GenericTes就是一个普通的类\n * GenericTest&lt;E> 就是一个泛型类\n * &lt;>里面就是一个参数类型，但是这个类型是什么呢？这个类型现在是不确定的，相当于一个占位\n * 但是现在确定的是这个类型一定是一个引用数据类型，而不是基本数据类型\n */\npublic class GenericTest&lt;E> &#123;\n    int age;\n    String name;\n    E sex;\n    public void a(E n)&#123;\n    &#125;\n    public void b(E[] m)&#123;\n    &#125;\n&#125;\nclass Test&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //GenericTest进行实例化：\n        //(1)实例化的时候不指定泛型：如果实例化的时候不明确的指定类的泛型，那么认为此泛型为Object类型\n        GenericTest gt1 = new GenericTest();\n        gt1.a(\"abc\");\n        gt1.a(17);\n        gt1.a(9.8);\n        gt1.b(new String[]&#123;\"a\",\"b\",\"c\"&#125;);\n        //（2）实例化的时候指定泛型：---》推荐方式\n        GenericTest&lt;String> gt2 = new GenericTest&lt;>();\n        gt2.sex = \"男\";\n        gt2.a(\"abc\");\n        gt2.b(new String[]&#123;\"a\",\"b\",\"c\"&#125;);\n        \n    &#125;\n&#125;\n【2】继承情况：\n（1）父类指定泛型：\nclass SubGenericTest extends GenericTest&lt;Integer>&#123;\n&#125;\nclass Demo&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //指定父类泛型，那么子类就不需要再指定泛型了，可以直接使用\n        SubGenericTest sgt = new SubGenericTest();\n        sgt.a(19);\n    &#125;\n&#125;\n（2）父类不指定泛型：\n如果父类不指定泛型，那么子类也会变成一个泛型类，那这个 E 的类型可以在创建子类对象的时候确定：\nclass SubGenericTest2&lt;E> extends GenericTest&lt;E>&#123;\n&#125;\n\nclass Demo2&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        SubGenericTest2&lt;String> s = new  SubGenericTest2&lt;>();\n        s.a(\"abc\");\n        s.sex = \"女\";\n    &#125;\n&#125;\n【3】应用场合：\n\n【4】细节：\n（1）泛型类可以定义多个参数类型\n\n（2）泛型类的构造器的写法：\n\n（3）不同的泛型的引用类型不可以相互赋值：\n\n（4）泛型如果不指定，那么就会被擦除，反应对应的类型为 Object 类型：\n\n（5）反省类中的静态方法不能使用类的泛型：\n\n（6）不能直接使用 E [] 的创建：\n\n# 2.5.2 泛型方法\npackage com.msb.test04;\n/**\n * @author : msb-zhaoss\n * 1.什么是泛型方法：\n * 不是带泛型的方法就是泛型方法\n * 泛型方法有要求：这个方法的泛型的参数类型要和当前的类的泛型无关\n * 换个角度：\n * 泛型方法对应的那个泛型参数类型 和  当前所在的这个类 是否是泛型类，泛型是啥  无关\n * 2.泛型方法定义的时候，前面要加上&lt;T>\n *     原因：如果不加的话，会把T当做一种数据类型，然而代码中没有T类型那么就会报错\n * 3.T的类型是在调用方法的时候确定的\n * 4.泛型方法可否是静态方法？可以是静态方法\n */\npublic class TestGeneric&lt;E> &#123;\n    //不是泛型方法 （不能是静态方法）\n    public static void a(E e)&#123;\n    &#125;\n    //是泛型方法\n    public static &lt;T>  void b(T t)&#123;\n    &#125;\n&#125;\nclass Demo&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        TestGeneric&lt;String> tg = new TestGeneric&lt;>();\n        tg.a(\"abc\");\n        tg.b(\"abc\");\n        tg.b(19);\n        tg.b(true);\n    &#125;\n&#125;\n# 2.5.3 泛型参数存在继承关系的情况\n\n# 2.5.4 通配符\n【1】在没有通配符的时候：\n下面的 a 方法，相当于方法的重复定义，报错\npublic class Test &#123;\n    /*public void a(List&lt;Object> list)&#123;\n    &#125;\n    public void a(List&lt;String> list)&#123;\n    &#125;\n    public void a(List&lt;Integer> list)&#123;\n    &#125;*/\n&#125;\n【2】引入通配符：\npublic class Demo &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        List&lt;Object> list1 = new ArrayList&lt;>();\n        List&lt;String> list2 = new ArrayList&lt;>();\n        List&lt;Integer> list3 = new ArrayList&lt;>();\n        List&lt;?> list = null;\n        list = list1;\n        list = list2;\n        list = list3;\n    &#125;\n&#125;\n发现： A 和 B 是子类父类的关系，G和 G不存在子类父类关系，是并列的\n加入通配符？后，G&lt;?&gt; 就变成了 G和 G的父类\n【3】使用通配符：\npackage com.msb.test06;\nimport java.util.ArrayList;\nimport java.util.List;\n/**\n * @author : msb-zhaoss\n */\npublic class Test &#123;\n    /*public void a(List&lt;Object> list)&#123;\n    &#125;\n    public void a(List&lt;String> list)&#123;\n    &#125;\n    public void a(List&lt;Integer> list)&#123;\n    &#125;*/\n    public void a(List&lt;?> list)&#123;\n        //内部遍历的时候用Object即可，不用？\n        for(Object a:list)&#123;\n            System.out.println(a);\n        &#125;\n    &#125;\n&#125;\nclass T&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        Test t = new Test();\n        t.a(new ArrayList&lt;Integer>());\n        t.a(new ArrayList&lt;String>());\n        t.a(new ArrayList&lt;Object>());\n    &#125;\n&#125;\n【4】查看 API 中应用位置：\n\n# 2.5.5 使用通配符后的细节\npublic class Test &#123;\n    public void a(List&lt;?> list)&#123;\n        //1.遍历：\n        for(Object a:list)&#123;\n            System.out.println(a);\n        &#125;\n        //2.数据的写入操作 ：\n        //list.add(\"abc\");-->出错，不能随意的添加数据\n        list.add(null);\n        //3.数据的读取操作：\n        Object s = list.get(0);\n    &#125;\n&#125;\nclass T&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        Test t = new Test();\n        t.a(new ArrayList&lt;Integer>());\n        t.a(new ArrayList&lt;String>());\n        t.a(new ArrayList&lt;Object>());\n    &#125;\n&#125;\n# 2.5.6 泛型受限\npackage com.msb.test07;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //a,b,c三个集合是并列的关系：\n        List&lt;Object> a = new ArrayList&lt;>();\n        List&lt;Person> b = new ArrayList&lt;>();\n        List&lt;Student> c = new ArrayList&lt;>();\n        /*开始使用泛型受限：泛型的上限\n        List&lt;? extends Person>:\n        就相当于：\n        List&lt;? extends Person>是List&lt;Person>的父类，是List&lt;Person的子类>的父类\n         */\n        List&lt;? extends Person> list1 = null;\n        /*list1 = a;\n        list1 = b;\n        list1 = c;*/\n        /*开始使用泛型受限：泛型的下限\n        List&lt;? super Person>\n        就相当于：\n        List&lt;? super Person>是List&lt;Person>的父类，是List&lt;Person的父类>的父类\n         */\n        List&lt;? super Person> list2 = null;\n        list2 = a;\n        list2 = b;\n        list3 = c;\n    &#125;\n&#125;\n# 2.6 LinkedList 实现类\n# 2.6.1 基本方法使用\npackage com.msb.test04;\nimport java.util.Iterator;\nimport java.util.LinkedList;\n/**\n * @author : msb-zhaoss\n */\npublic class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        /*\n        LinkedList常用方法：\n        增加 addFirst(E e) addLast(E e)\n             offer(E e) offerFirst(E e) offerLast(E e)\n        删除 poll()\n            pollFirst() pollLast()  ---》JDK1.6以后新出的方法，提高了代码的健壮性\n            removeFirst() removeLast()\n        修改\n        查看 element()\n             getFirst()  getLast()\n             indexOf(Object o)   lastIndexOf(Object o)\n             peek()\n             peekFirst() peekLast()\n        判断\n         */\n        //创建一个LinkedList集合对象：\n        LinkedList&lt;String> list = new LinkedList&lt;>();\n        list.add(\"aaaaa\");\n        list.add(\"bbbbb\");\n        list.add(\"ccccc\");\n        list.add(\"ddddd\");\n        list.add(\"eeeee\");\n        list.add(\"bbbbb\");\n        list.add(\"fffff\");\n        list.addFirst(\"jj\");\n        list.addLast(\"hh\");\n        list.offer(\"kk\");//添加元素在尾端\n        list.offerFirst(\"pp\");\n        list.offerLast(\"rr\");\n        System.out.println(list);//LinkedList可以添加重复数据\n        System.out.println(list.poll());//删除头上的元素并且将元素输出\n        System.out.println(list.pollFirst());\n        System.out.println(list.pollLast());\n        System.out.println(list.removeFirst());\n        System.out.println(list.removeLast());\n        System.out.println(list);//LinkedList可以添加重复数据\n        /*list.clear();//清空集合\n        System.out.println(list);*/\n        /*System.out.println(list.pollFirst());*/\n        /*System.out.println(list.removeFirst());报错：Exception in thread \"main\" java.util.NoSuchElementException*/\n        //集合的遍历：\n        System.out.println(\"---------------------\");\n        //普通for循环：\n        for(int i = 0;i&lt;list.size();i++)&#123;\n            System.out.println(list.get(i));\n        &#125;\n        System.out.println(\"---------------------\");\n        //增强for：\n        for(String s:list)&#123;\n            System.out.println(s);\n        &#125;\n        System.out.println(\"---------------------\");\n        //迭代器：\n        /*Iterator&lt;String> it = list.iterator();\n        while(it.hasNext())&#123;\n            System.out.println(it.next());\n        &#125;*/\n        //下面这种方式好，节省内存\n        for(Iterator&lt;String> it = list.iterator();it.hasNext();)&#123;\n            System.out.println(it.next());\n        &#125;\n    &#125;\n&#125;\n# 2.6.2 简要底层原理图\n\n# 2.6.3 模拟 LinkedList 源码\npackage com.msb.test05;\n/**\n * @author : msb-zhaoss\n */\npublic class MyLinkedList &#123;\n    //链中一定有一个首节点：\n    Node first;\n    //链中一定有一个尾节点：\n    Node last;\n    //计数器：\n    int count = 0;\n    //提供一个构造器：\n    public MyLinkedList()&#123;\n    &#125;\n    //添加元素方法：\n    public void add(Object o)&#123;\n        if(first == null)&#123;//证明你添加的元素是第一个节点：\n            //将添加的元素封装为一个Node对象：\n            Node n = new Node();\n            n.setPre(null);\n            n.setObj(o);\n            n.setNext(null);\n            //当前链中第一个节点变为n\n            first = n;\n            //当前链中最后一个节点变为n\n            last = n;\n        &#125;else&#123;//证明已经不是链中第一个节点了\n            //将添加的元素封装为一个Node对象：\n            Node n = new Node();\n            n.setPre(last);//n的上一个节点一定是当前链中的最后一个节点last\n            n.setObj(o);\n            n.setNext(null);\n            //当前链中的最后一个节点的下一个元素 要指向n\n            last.setNext(n);\n            //将最后一个节点变为n\n            last = n;\n        &#125;\n        //链中元素数量加1\n        count++;\n    &#125;\n    //得到集合中元素的数量：\n    public int getSize()&#123;\n        return count;\n    &#125;\n    //通过下标得到元素：\n    public Object get(int index)&#123;\n        //获取链表的头元素：\n        Node n = first;\n        //一路next得到想要的元素\n        for(int i=0;i&lt;index;i++)&#123;\n            n = n.getNext();\n        &#125;\n        return n.getObj();\n    &#125;\n&#125;\nclass Test&#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个MyLinkedList集合对象：\n        MyLinkedList ml = new MyLinkedList();\n        ml.add(\"aa\");\n        ml.add(\"bb\");\n        ml.add(\"cc\");\n        System.out.println(ml.getSize());\n        System.out.println(ml.get(0));\n    &#125;\n&#125;\n# 2.6.4 LinkedList 源码解析\n【1】JDK1.7 和 JDK1.8 的 LinkedList 的源码是一致的\n【2】源码：\npublic class LinkedList&lt;E>&#123;//E是一个泛型，具体的类型要在实例化的时候才会最终确定\n        transient int size = 0;//集合中元素的数量\n        //Node的内部类\n        private static class Node&lt;E> &#123;\n        E item;//当前元素\n        Node&lt;E> next;//指向下一个元素地址\n        Node&lt;E> prev;//上一个元素地址\n        Node(Node&lt;E> prev, E element, Node&lt;E> next) &#123;\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        &#125;\n    &#125;\n        transient Node&lt;E> first;//链表的首节点\n        transient Node&lt;E> last;//链表的尾节点\n        //空构造器：\n        public LinkedList() &#123;\n    &#125;\n        //添加元素操作：\n        public boolean add(E e) &#123;\n        linkLast(e);\n        return true;\n    &#125;\n        void linkLast(E e) &#123;//添加的元素e\n        final Node&lt;E> l = last;//将链表中的last节点给l 如果是第一个元素的话 l为null\n                //将元素封装为一个Node具体的对象：\n        final Node&lt;E> newNode = new Node&lt;>(l, e, null);\n                //将链表的last节点指向新的创建的对象：\n        last = newNode;\n                \n        if (l == null)//如果添加的是第一个节点\n            first = newNode;//将链表的first节点指向为新节点\n        else//如果添加的不是第一个节点 \n            l.next = newNode;//将l的下一个指向为新的节点\n        size++;//集合中元素数量加1操作\n        modCount++;\n    &#125;\n        //获取集合中元素数量\n        public int size() &#123;\n        return size;\n    &#125;\n        //通过索引得到元素：\n        public E get(int index) &#123;\n        checkElementIndex(index);//健壮性考虑\n        return node(index).item;\n    &#125;\n        \n    Node&lt;E> node(int index) &#123;\n        //如果index在链表的前半段，那么从前往后找\n        if (index &lt; (size >> 1)) &#123;\n            Node&lt;E> x = first;\n            for (int i = 0; i &lt; index; i++)\n                x = x.next;\n            return x;\n        &#125; else &#123;//如果index在链表的后半段，那么从后往前找\n            Node&lt;E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        &#125;\n    &#125;\n&#125;\n# 面试题：\n\n\n\n\n\n\n\n\n\niterator (),Iterator,Iterable 关系\n【1】面试题：对应的关系：\n\n【2】hasNext (),next () 的具体实现：\n\nListIterator 迭代器\n【1】加入字符串：\npackage com.msb.test06;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n/**\n * @author : msb-zhaoss\n */\npublic class Test2 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        ArrayList&lt;String> list = new ArrayList&lt;>();\n        list.add(\"aa\");\n        list.add(\"bb\");\n        list.add(\"cc\");\n        list.add(\"dd\");\n        list.add(\"ee\");\n        //在\"cc\"之后添加一个字符串\"kk\"\n        Iterator&lt;String> it = list.iterator();\n        while(it.hasNext())&#123;\n            if(\"cc\".equals(it.next()))&#123;\n                list.add(\"kk\");\n            &#125;\n        &#125;\n    &#125;\n&#125;\n发现报错：\n\n出错原因：就是迭代器和 list 同时对集合进行操作：\n\n解决办法：事情让一个 “人” 做 --》引入新的迭代器：ListIterator\n 迭代和添加操作都是靠 ListIterator 来完成的：\npackage com.msb.test06;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\n/**\n * @author : msb-zhaoss\n */\npublic class Test2 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        ArrayList&lt;String> list = new ArrayList&lt;>();\n        list.add(\"aa\");\n        list.add(\"bb\");\n        list.add(\"cc\");\n        list.add(\"dd\");\n        list.add(\"ee\");\n        //在\"cc\"之后添加一个字符串\"kk\"\n        ListIterator&lt;String> it = list.listIterator();\n        while(it.hasNext())&#123;\n            if(\"cc\".equals(it.next()))&#123;\n                it.add(\"kk\");\n            &#125;\n        &#125;\n        System.out.println(it.hasNext());\n        System.out.println(it.hasPrevious());\n        //逆向遍历：\n        while(it.hasPrevious())&#123;\n            System.out.println(it.previous());\n        &#125;\n        System.out.println(it.hasNext());\n        System.out.println(it.hasPrevious());\n        System.out.println(list);\n    &#125;\n&#125;\n# 3 Set 接口\n# 3.1 HashSet 实现类的使用\n【1】放入 Integer 类型数据：\npackage com.msb.test07;\nimport java.util.HashSet;\n/**\n * @author : msb-zhaoss\n */\npublic class TestInteger &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个HashSet集合：\n        HashSet&lt;Integer> hs = new HashSet&lt;>();\n        System.out.println(hs.add(19));//true\n        hs.add(5);\n        hs.add(20);\n        System.out.println(hs.add(19));//false 这个19没有放入到集合中\n        hs.add(41);\n        hs.add(0);\n        System.out.println(hs.size());//唯一，无序\n        System.out.println(hs);\n    &#125;\n&#125;\n\n【2】放入 String 类型数据：\npackage com.msb.test07;\nimport java.util.HashSet;\n/**\n * @author : msb-zhaoss\n */\npublic class TestString &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个HashSet集合：\n        HashSet&lt;String> hs = new HashSet&lt;>();\n        hs.add(\"hello\");\n        hs.add(\"apple\");\n        hs.add(\"banana\");\n        hs.add(\"html\");\n        hs.add(\"apple\");\n        hs.add(\"css\");\n        System.out.println(hs.size());\n        System.out.println(hs);\n    &#125;\n&#125;\n【3】放入自定义的引用数据类型的数据：\npackage com.msb.test07;\nimport java.util.HashSet;\n/**\n * @author : msb-zhaoss\n */\npublic class TestStudent &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个HashSet集合：\n        HashSet&lt;Student> hs = new HashSet&lt;>();\n        hs.add(new Student(19,\"lili\"));\n        hs.add(new Student(20,\"lulu\"));\n        hs.add(new Student(18,\"feifei\"));\n        hs.add(new Student(19,\"lili\"));\n        hs.add(new Student(10,\"nana\"));\n        System.out.println(hs.size());\n        System.out.println(hs);\n    &#125;\n&#125;\n\n上面自定义的类型不满足 唯一，无序的特点。为什么呢？\n【4】HashSet 原理图：（简要原理图）\n\n【5】疑问：\n1. 数组的长度是多少。\n2. 数组的类型是什么？\n3.hashCode，equals 方法真的调用了吗？验证\n 4. 底层表达式是什么？\n5. 同一个位置的数据 向前放  还是 向后放？\n6. 放入数组中的数据，是直接放的吗？是否封装为对象了？\n# 3.2LinkedHashSet 使用\n其实就是在 HashSet 的基础上，多了一个总的链表，这个总链表将放入的元素串在一起，方便有序的遍历：\n（可以看到 LinkedHashMap.Entry 继承自 HashMap.Node 除了 Node 本身有的几个属性外，额外增加了 before after 用于指向前一个 Entry 后一个 Entry。也就是说，元素之间维持着一条总的链表数据结构。）\n\npackage com.msb.test07;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\n/**\n * @author : msb-zhaoss\n */\npublic class TestInteger &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个HashSet集合：\n        LinkedHashSet&lt;Integer> hs = new LinkedHashSet&lt;>();\n        System.out.println(hs.add(19));//true\n        hs.add(5);\n        hs.add(20);\n        System.out.println(hs.add(19));//false 这个19没有放入到集合中\n        hs.add(41);\n        hs.add(0);\n        System.out.println(hs.size());//唯一，无序\n        System.out.println(hs);\n    &#125;\n&#125;\n# 3.3 比较器的使用\n【1】以 int 类型为案例：\n比较的思路：将比较的数据做差，然后返回一个 int 类型的数据，将这个 int 类型的数值  按照 =0  &gt;0  &lt;0\nint a = 10;\n    int b = 20;\n    System.out.println(a-b); // =0  >0  &lt;0\n【2】比较 String 类型数据：\nString 类实现了 Comparable 接口，这个接口中有一个抽象方法 compareTo，String 类中重写这个方法即可\nString a = \"A\";\n    String b = \"B\";\n    System.out.println(a.compareTo(b));\n【3】比较 double 类型数据：\ndouble a = 9.6;\n     double b = 9.3;\n    /* System.out.println((int)(a-b));*/\n     System.out.println(((Double) a).compareTo((Double) b));\n【4】比较自定义的数据类型：\n（1）内部比较器：\npublic class Student implements Comparable&lt;Student>&#123;\n    private int age;\n    private double height;\n    private String name;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public double getHeight() &#123;\n        return height;\n    &#125;\n    public void setHeight(double height) &#123;\n        this.height = height;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public Student(int age, double height, String name) &#123;\n        this.age = age;\n        this.height = height;\n        this.name = name;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return \"Student&#123;\" +\n                \"age=\" + age +\n                \", height=\" + height +\n                \", name='\" + name + '\\'' +\n                '&#125;';\n    &#125;\n    @Override\n    public int compareTo(Student o) &#123;\n        //按照年龄进行比较：\n        /*return this.getAge() - o.getAge();*/\n        //按照身高比较\n        /*return ((Double)(this.getHeight())).compareTo((Double)(o.getHeight()));*/\n        //按照名字比较：\n        return this.getName().compareTo(o.getName());\n    &#125;\n&#125;\npublic class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //比较两个学生：\n        Student s1 = new Student(14,160.5,\"alili\");\n        Student s2 = new Student(14,170.5,\"bnana\");\n        System.out.println(s1.compareTo(s2));\n    &#125;\n&#125;\n（2）外部比较器：\npublic class Student&#123;\n    private int age;\n    private double height;\n    private String name;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public double getHeight() &#123;\n        return height;\n    &#125;\n    public void setHeight(double height) &#123;\n        this.height = height;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public Student(int age, double height, String name) &#123;\n        this.age = age;\n        this.height = height;\n        this.name = name;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return \"Student&#123;\" +\n                \"age=\" + age +\n                \", height=\" + height +\n                \", name='\" + name + '\\'' +\n                '&#125;';\n    &#125;\n&#125;\nclass BiJiao01 implements Comparator&lt;Student> &#123;\n    @Override\n    public int compare(Student o1, Student o2) &#123;\n        //比较年龄：\n        return o1.getAge()-o2.getAge();\n    &#125;\n&#125;\nclass BiJiao02 implements Comparator&lt;Student> &#123;\n    @Override\n    public int compare(Student o1, Student o2) &#123;\n        //比较姓名：\n        return o1.getName().compareTo(o2.getName());\n    &#125;\n&#125;\nclass BiJiao03 implements Comparator&lt;Student> &#123;\n    @Override\n    public int compare(Student o1, Student o2) &#123;\n        //在年龄相同的情况下 比较身高  年龄不同比较年龄\n        if((o1.getAge()-o2.getAge())==0)&#123;\n            return ((Double)(o1.getHeight())).compareTo((Double)(o2.getHeight()));\n        &#125;else&#123;//年龄不一样\n            return o1.getAge()-o2.getAge();\n        &#125;\n    &#125;\n&#125;\npublic class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //比较两个学生：\n        Student s1 = new Student(9,160.5,\"alili\");\n        Student s2 = new Student(14,170.5,\"bnana\");\n        //获取外部比较器：\n        Comparator bj1 = new BiJiao03();\n        System.out.println(bj1.compare(s1, s2));\n    &#125;\n&#125;\n\n【5】外部比较器和内部比较器 谁好呀？\n答案：外部比较器，多态，扩展性好\n# 3.4 TreeSet 实现类的使用\n【1】存入 Integer 类型数据：（底层利用的是内部比较器）\npackage com.msb.test10;\nimport java.util.TreeSet;\n/**\n * @author : msb-zhaoss\n */\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个TreeSet:\n        TreeSet&lt;Integer> ts = new TreeSet&lt;>();\n        ts.add(12);\n        ts.add(3);\n        ts.add(7);\n        ts.add(9);\n        ts.add(3);\n        ts.add(16);\n        System.out.println(ts.size());\n        System.out.println(ts);\n    &#125;\n&#125;\n\n特点：唯一，无序（没有按照输入顺序进行输出）， 有序（按照升序进行遍历）\n【2】原理：底层：二叉树（数据结构中的一个逻辑结构）\n\n【3】放入 String 类型数据：（底层实现类内部比较器）\npublic class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个TreeSet:\n        TreeSet&lt;String> ts = new TreeSet&lt;>();\n        ts.add(\"elili\");\n        ts.add(\"blili\");\n        ts.add(\"alili\");\n        ts.add(\"elili\");\n        ts.add(\"clili\");\n        ts.add(\"flili\");\n        ts.add(\"glili\");\n        System.out.println(ts.size());\n        System.out.println(ts);\n    &#125;\n&#125;\n【4】想放入自定义的 Student 类型的数据：\n（1）利用内部比较器：\npublic class Student implements Comparable&lt;Student> &#123;\n    private int age;\n    private String name;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public Student(int age, String name) &#123;\n        this.age = age;\n        this.name = name;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return \"Student&#123;\" +\n                \"age=\" + age +\n                \", name='\" + name + '\\'' +\n                '&#125;';\n    &#125;\n    @Override\n    public int compareTo(Student o) &#123;\n        return this.getAge()-o.getAge();\n    &#125;\n&#125;\npublic class Test03 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个TreeSet:\n        TreeSet&lt;Student> ts = new TreeSet&lt;>();\n        ts.add(new Student(10,\"elili\"));\n        ts.add(new Student(8,\"blili\"));\n        ts.add(new Student(4,\"alili\"));\n        ts.add(new Student(9,\"elili\"));\n        ts.add(new Student(10,\"flili\"));\n        ts.add(new Student(1,\"dlili\"));\n        System.out.println(ts.size());\n        System.out.println(ts);\n    &#125;\n&#125;\n（2）通过外部比较器：\npublic class Student  &#123;\n    private int age;\n    private String name;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public Student(int age, String name) &#123;\n        this.age = age;\n        this.name = name;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return \"Student&#123;\" +\n                \"age=\" + age +\n                \", name='\" + name + '\\'' +\n                '&#125;';\n    &#125;\n&#125;\nclass BiJiao implements Comparator&lt;Student>&#123;\n    @Override\n    public int compare(Student o1, Student o2) &#123;\n        return o1.getName().compareTo(o2.getName());\n    &#125;\n&#125;\npublic class Test03 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个TreeSet:\n        //利用外部比较器，必须自己制定：\n        Comparator&lt;Student> com = new BiJiao();\n        TreeSet&lt;Student> ts = new TreeSet&lt;>(com);//一旦指定外部比较器，那么就会按照外部比较器来比较\n        ts.add(new Student(10,\"elili\"));\n        ts.add(new Student(8,\"blili\"));\n        ts.add(new Student(4,\"alili\"));\n        ts.add(new Student(9,\"elili\"));\n        ts.add(new Student(10,\"flili\"));\n        ts.add(new Student(1,\"dlili\"));\n        System.out.println(ts.size());\n        System.out.println(ts);\n    &#125;\n&#125;\n实际开发中利用外部比较器多，因为扩展性好（多态）\n换一种写法：\npublic class Test03 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个TreeSet:\n        //利用外部比较器，必须自己制定：\n        /*Comparator&lt;Student> com = new Comparator&lt;Student>() &#123;\n            @Override\n            public int compare(Student o1, Student o2) &#123;\n                return o1.getName().compareTo(o2.getName());\n            &#125;\n        &#125;;*/\n        TreeSet&lt;Student> ts = new TreeSet&lt;>(new Comparator&lt;Student>() &#123;\n            @Override\n            public int compare(Student o1, Student o2) &#123;\n                return o1.getName().compareTo(o2.getName());\n            &#125;\n        &#125;);//一旦指定外部比较器，那么就会按照外部比较器来比较\n        ts.add(new Student(10,\"elili\"));\n        ts.add(new Student(8,\"blili\"));\n        ts.add(new Student(4,\"alili\"));\n        ts.add(new Student(9,\"elili\"));\n        ts.add(new Student(10,\"flili\"));\n        ts.add(new Student(1,\"dlili\"));\n        System.out.println(ts.size());\n        System.out.println(ts);\n    &#125;\n&#125;\n【5】TreeSet 底层的二叉树的遍历是按照升序的结果出现的，这个升序是靠中序遍历得到的：\n\n# 3.5 Collection 部分整体结构图\n\n# Map 接口\n# 1 常用方法\npackage com.msb.test11;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n/**\n * @author : msb-zhaoss\n */\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        /*\n        增加：put(K key, V value)\n        删除：clear() remove(Object key)\n        修改：\n        查看：entrySet() get(Object key) keySet() size() values()\n        判断：containsKey(Object key) containsValue(Object value)\n            equals(Object o) isEmpty()\n         */\n        //创建一个Map集合：无序，唯一\n        Map&lt;String,Integer> map = new HashMap&lt;>();\n        System.out.println(map.put(\"lili\", 10101010));\n        map.put(\"nana\",12345234);\n        map.put(\"feifei\",34563465);\n        System.out.println(map.put(\"lili\", 34565677));\n        map.put(\"mingming\",12323);\n        /*map.clear();清空*/\n        /*map.remove(\"feifei\");移除*/\n        System.out.println(map.size());\n        System.out.println(map);\n        System.out.println(map.containsKey(\"lili\"));\n        System.out.println(map.containsValue(12323));\n        Map&lt;String,Integer> map2 = new HashMap&lt;>();\n        System.out.println(map2.put(\"lili\", 10101010));\n        map2.put(\"nana\",12345234);\n        map2.put(\"feifei\",34563465);\n        System.out.println(map2.put(\"lili\", 34565677));\n        map2.put(\"mingming2\",12323);\n        System.out.println(map==map2);\n        System.out.println(map.equals(map2));//equals进行了重写，比较的是集合中的值是否一致\n        System.out.println(\"判断是否为空：\"+map.isEmpty());\n        System.out.println(map.get(\"nana\"));\n        System.out.println(\"-----------------------------------\");\n        //keySet()对集合中的key进行遍历查看：\n        Set&lt;String> set = map.keySet();\n        for(String s:set)&#123;\n            System.out.println(s);\n        &#125;\n        System.out.println(\"-----------------------------------\");\n        //values()对集合中的value进行遍历查看：\n        Collection&lt;Integer> values = map.values();\n        for(Integer i:values)&#123;\n            System.out.println(i);\n        &#125;\n        System.out.println(\"-----------------------------------\");\n        //get(Object key) keySet()\n        Set&lt;String> set2 = map.keySet();\n        for(String s:set2)&#123;\n            System.out.println(map.get(s));\n        &#125;\n        System.out.println(\"-----------------------------------\");\n        //entrySet()\n        Set&lt;Map.Entry&lt;String, Integer>> entries = map.entrySet();\n        for(Map.Entry&lt;String, Integer> e:entries)&#123;\n            System.out.println(e.getKey()+\"----\"+e.getValue());\n        &#125;\n    &#125;\n&#125;\n# 2 TreeMap\n【1】key 的类型为 String 类型：\npublic class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        Map&lt;String,Integer> map = new TreeMap&lt;>();\n        map.put(\"blili\",1234);\n        map.put(\"alili\",2345);\n        map.put(\"blili\",5467);\n        map.put(\"clili\",5678);\n        map.put(\"dlili\",2345);\n        System.out.println(map.size());\n        System.out.println(map);\n    &#125;\n&#125;\n【2】key 的类型是一个自定义的引用数据类型：\n（1）内部比较器：\npublic class Test03 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        Map&lt;Student,Integer> map = new TreeMap&lt;>();\n        map.put(new Student(19,\"blili\",170.5),1001);\n        map.put(new Student(18,\"blili\",150.5),1003);\n        map.put(new Student(19,\"alili\",180.5),1023);\n        map.put(new Student(17,\"clili\",140.5),1671);\n        map.put(new Student(10,\"dlili\",160.5),1891);\n        System.out.println(map);\n        System.out.println(map.size());\n    &#125;\n&#125;\npublic class Student implements Comparable&lt;Student>&#123;\n    private int age;\n    private String name;\n    private double height;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public double getHeight() &#123;\n        return height;\n    &#125;\n    public void setHeight(double height) &#123;\n        this.height = height;\n    &#125;\n    public Student(int age, String name, double height) &#123;\n        this.age = age;\n        this.name = name;\n        this.height = height;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return \"Student&#123;\" +\n                \"age=\" + age +\n                \", name='\" + name + '\\'' +\n                \", height=\" + height +\n                '&#125;';\n    &#125;\n    @Override\n    public int compareTo(Student o) &#123;\n       /* return this.getAge()-o.getAge();*/\n        return this.getName().compareTo(o.getName());\n    &#125;\n&#125;\n\n（2）外部比较器：\npublic class Test03 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        Map&lt;Student,Integer> map = new TreeMap&lt;>(new Comparator&lt;Student>() &#123;\n            @Override\n            public int compare(Student o1, Student o2) &#123;\n                return ((Double)(o1.getHeight())).compareTo((Double)(o2.getHeight()));\n            &#125;\n        &#125;);\n        map.put(new Student(19,\"blili\",170.5),1001);\n        map.put(new Student(18,\"blili\",150.5),1003);\n        map.put(new Student(19,\"alili\",180.5),1023);\n        map.put(new Student(17,\"clili\",140.5),1671);\n        map.put(new Student(10,\"dlili\",160.5),1891);\n        System.out.println(map);\n        System.out.println(map.size());\n    &#125;\n&#125;\n# 3 Map 部分整体结构图\n\n# 4 源码部分\n# 4.1 HashMap\n# 4.1.1 代码展示特性\npublic class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //JDK1.7以后支持后面的&lt;>中内容可以不写\n        HashMap&lt;Integer,String> hm = new HashMap&lt;>();\n        System.out.println(hm.put(12,\"丽丽\"));\n        System.out.println(hm.put(7,\"菲菲\"));\n        System.out.println(hm.put(19,\"露露\"));\n        System.out.println(hm.put(12,\"明明\"));\n        System.out.println(hm.put(6,\"莹莹\"));\n        System.out.println(\"集合的长度：\"+hm.size());\n        System.out.println(\"集合中内容查看：\"+hm);\n    &#125;\n&#125;\n结果展示：\n\n# 4.1.2 先演示原理\n先演示原理图，再看源码，直接看的话，有的人接不上就蒙了：\n相当于先看原理，然后从源码中验证这个原理是否正确：把图搞懂了，就是事倍功半的效果\n原理如下：(JDK1.7)\n\n# 4.1.3 源码（JDK1.7 版本）\npublic class HashMap&lt;K,V>\n    extends AbstractMap&lt;K,V> //【1】继承的AbstractMap中，已经实现了Map接口\n        //【2】又实现了这个接口，多余，但是设计者觉得没有必要删除，就这么地了\n    implements Map&lt;K,V>, Cloneable, Serializable&#123;\n                \n                \n        //【3】后续会用到的重要属性：先粘贴过来：\n    static final int DEFAULT_INITIAL_CAPACITY = 16;//哈希表主数组的默认长度\n        //定义了一个float类型的变量，以后作为：默认的装填因子，加载因子是表示Hsah表中元素的填满的程度\n        //太大容易引起哈西冲突，太小容易浪费  0.75是经过大量运算后得到的最好值\n        //这个值其实可以自己改，但是不建议改，因为这个0.75是大量运算得到的\n        static final float DEFAULT_LOAD_FACTOR = 0.75f;\n        transient Entry&lt;K,V>[] table;//主数组,每个元素为Entry类型\n        transient int size;\n        int threshold;//数组扩容的界限值,门槛值   16*0.75=12 \n        final float loadFactor;//用来接收装填因子的变量\n        \n        //【4】查看构造器：内部相当于：this(16,0.75f);调用了当前类中的带参构造器\n        public HashMap() &#123;\n        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n    &#125;\n        //【5】本类中带参数构造器：--》作用给一些数值进行初始化的！\n        public HashMap(int initialCapacity, float loadFactor) &#123;\n        //【6】给capacity赋值，capacity的值一定是 大于你传进来的initialCapacity 的 最小的 2的倍数\n        int capacity = 1;\n        while (capacity &lt; initialCapacity)\n            capacity &lt;&lt;= 1;\n                //【7】给loadFactor赋值，将装填因子0.75赋值给loadFactor\n        this.loadFactor = loadFactor;\n                //【8】数组扩容的界限值,门槛值\n        threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n                \n                //【9】给table数组赋值，初始化数组长度为16\n        table = new Entry[capacity];\n                   \n    &#125;\n        //【10】调用put方法：\n        public V put(K key, V value) &#123;\n                //【11】对空值的判断\n        if (key == null)\n            return putForNullKey(value);\n                //【12】调用hash方法，获取哈希码\n        int hash = hash(key);\n                //【14】得到key对应在数组中的位置\n        int i = indexFor(hash, table.length);\n                //【16】如果你放入的元素，在主数组那个位置上没有值，e==null  那么下面这个循环不走\n                //当在同一个位置上放入元素的时候\n        for (Entry&lt;K,V> e = table[i]; e != null; e = e.next) &#123;\n            Object k;\n                        //哈希值一样  并且  equals相比一样   \n                        //(k = e.key) == key  如果是一个对象就不用比较equals了\n            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            &#125;\n        &#125;\n        modCount++;\n                //【17】走addEntry添加这个节点的方法：\n        addEntry(hash, key, value, i);\n        return null;\n    &#125;\n        \n        //【13】hash方法返回这个key对应的哈希值，内部进行二次散列，为了尽量保证不同的key得到不同的哈希码！\n        final int hash(Object k) &#123;\n        int h = 0;\n        if (useAltHashing) &#123;\n            if (k instanceof String) &#123;\n                return sun.misc.Hashing.stringHash32((String) k);\n            &#125;\n            h = hashSeed;\n        &#125;\n                //k.hashCode()函数调用的是key键值类型自带的哈希函数，\n                //由于不同的对象其hashCode()有可能相同，所以需对hashCode()再次哈希，以降低相同率。\n        h ^= k.hashCode();\n        // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n        // number of collisions (approximately 8 at default load factor).\n                /*\n                接下来的一串与运算和异或运算，称之为“扰动函数”，\n                扰动的核心思想在于使计算出来的值在保留原有相关特性的基础上，\n                增加其值的不确定性，从而降低冲突的概率。\n                不同的版本实现的方式不一样，但其根本思想是一致的。\n                往右移动的目的，就是为了将h的高位利用起来，减少哈西冲突\n                */\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n    &#125;\n        //【15】返回int类型数组的坐标\n        static int indexFor(int h, int length) &#123;\n                //其实这个算法就是取模运算：h%length，取模效率不如位运算\n        return h &amp; (length-1);\n    &#125;\n        //【18】调用addEntry\n        void addEntry(int hash, K key, V value, int bucketIndex) &#123;\n                //【25】size的大小  大于 16*0.75=12的时候，比如你放入的是第13个，这第13个你打算放在没有元素的位置上的时候\n        if ((size >= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;\n                        //【26】主数组扩容为2倍\n            resize(2 * table.length);\n                        //【30】重新调整当前元素的hash码\n            hash = (null != key) ? hash(key) : 0;\n                        //【31】重新计算元素位置\n            bucketIndex = indexFor(hash, table.length);\n        &#125;\n                //【19】将hash,key,value,bucketIndex位置  封装为一个Entry对象：\n        createEntry(hash, key, value, bucketIndex);\n    &#125;\n        //【20】\n        void createEntry(int hash, K key, V value, int bucketIndex) &#123;\n                //【21】获取bucketIndex位置上的元素给e\n        Entry&lt;K,V> e = table[bucketIndex];\n                //【22】然后将hash, key, value封装为一个对象，然后将下一个元素的指向为e （链表的头插法）\n                //【23】将新的Entry放在table[bucketIndex]的位置上\n        table[bucketIndex] = new Entry&lt;>(hash, key, value, e);\n                //【24】集合中加入一个元素 size+1\n        size++;\n    &#125;\n    //【27】\n        void resize(int newCapacity) &#123;\n        Entry[] oldTable = table;\n        int oldCapacity = oldTable.length;\n        if (oldCapacity == MAXIMUM_CAPACITY) &#123;\n            threshold = Integer.MAX_VALUE;\n            return;\n        &#125;\n                //【28】创建长度为newCapacity的数组\n        Entry[] newTable = new Entry[newCapacity];\n        boolean oldAltHashing = useAltHashing;\n        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;\n                (newCapacity >= Holder.ALTERNATIVE_HASHING_THRESHOLD);\n        boolean rehash = oldAltHashing ^ useAltHashing;\n                //【28.5】转让方法：将老数组中的东西都重新放入新数组中\n        transfer(newTable, rehash);\n                //【29】老数组替换为新数组\n        table = newTable;\n                //【29.5】重新计算\n        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    &#125;\n        //【28.6】\n        void transfer(Entry[] newTable, boolean rehash) &#123;\n        int newCapacity = newTable.length;\n        for (Entry&lt;K,V> e : table) &#123;\n            while(null != e) &#123;\n                Entry&lt;K,V> next = e.next;\n                if (rehash) &#123;\n                    e.hash = null == e.key ? 0 : hash(e.key);\n                &#125;\n                                //【28.7】将哈希值，和新的数组容量传进去，重新计算key在新数组中的位置\n                int i = indexFor(e.hash, newCapacity);\n                                //【28.8】头插法\n                e.next = newTable[i];//获取链表上元素给e.next\n                newTable[i] = e;//然后将e放在i位置 \n                e = next;//e再指向下一个节点继续遍历\n            &#125;\n        &#125;\n    &#125;\n&#125;\n# 4.1.4  细节讲解：主数组的长度为 2 的倍数\n【1】主数组的长度为 2 的倍数，\n\n因为这个 length 的长度，会影响 key 的位置：\nkey 的位置的计算：\n\n实际上这个算法就是：  h% length   , 但是取模的话  效率太低，所以用位运算效率会很高。\n原因 1：\n 和 等效的前提就是  length 必须是 2 的整数倍\n原因 2：\n如果不是 2 的整数倍，那么 哈西碰撞 哈西冲突的概率就高了很多\n位运算 就  涉及  到  length 是不是 2 的整数倍：\n比如是 2 的整数倍：\n\n\n并且这个得到的索引值，一定在 0-15 之间（数组是 16 的时候）：\n\n当然如果你扩容后数组长度为 32，那么这个索引就在 0-31 之间\n比如如果不是 2 的整数倍：\n\n发现：如果不是 2 的整数倍，那么 哈西碰撞 哈西冲突的概率就高了很多\n# 4.1.5 细节讲解：装填因子 0.75 的原因\n如果装填因子是 1， 那么数组满了再扩容，可以做到  最大的空间利用率\n但是这是一个理想状态，元素不可能完全的均匀分布，很可能就哈西碰撞产生链表了。产生链表的话 查询时间就长了。\n—》空间好，时间不好\n那么有人说 ，把装填因子搞小一点，0.5，  如果是 0.5 的话，就浪费空间，但是可以做到 到 0.5 就扩容 ，然后哈西碰撞就少，\n不产生链表的话，那么查询效率很高\n —》时间好，空间不好\n所以在空间和时间中，\n取中间值，平衡这个因素 就取值为 0.75\n\n1.8 版本\n# 1.8 底层遵照 哈希表结构 + 红黑树\n// HashMap&lt;String,Integer> map = new HashMap&lt;>(); -->JDK 1.7开始类型推断，后面用钻石运算符即可。\npublic class HashMap&lt;K,V> extends AbstractMap&lt;K,V> \t\t//【1】继承的AbstractMap中，已经实现了Map接口\n    implements Map&lt;K,V>, Cloneable, Serializable &#123; //【2】又实现了这个接口，多余，但是集合的设计者觉得没有必要删除，就这么地了\n\n\t//------------------属性部分：\n\tfinal float loadFactor;//【3-2】用来接收装填因子的变量\n\t/*\n\t\t【3-3】\n\t\t定义了一个float类型的变量，以后作为：默认的装填因子，加载因子是表示Hsah表中元素的填满的程度\n        太大容易引起哈西冲突，太小容易浪费  0.75是经过大量运算后得到的最好值\n        这个值其实可以自己改，但是不建议改，因为这个0.75是大量运算得到的\n\t*/\n\tstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\tint threshold;//【6-3】数组扩容的界限值,门槛值\n\ttransient Node&lt;K,V>[] table;//【7-5】底层主数组\n\t//------------------构造器：\n\t//【3】调用空构造器\n\tpublic HashMap() &#123;\n\t\t//【3-1】给装填因子loadFactor赋值\n        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n    &#125;\n\t\n\t//【4】调用有参构造器：\n\tpublic HashMap(int initialCapacity) &#123;\n\t\t//【5】调用两个参数构造器\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    &#125;\n\t//【6】\n\tpublic HashMap(int initialCapacity, float loadFactor) &#123;\n\t\t//【6-1】健壮性考虑，传入的数据过小不行，过大不行\n        if (initialCapacity &lt; 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n\t\t//【6-2】给装填因子loadFactor赋值，赋值为0.75，这个值可以单独传入改变，但是不建议改变，一般都用默认的0.75\n        this.loadFactor = loadFactor;\n\t\t//【6-3】给threshold赋值 \n        this.threshold = tableSizeFor(initialCapacity);\n    &#125;\n\t//【6-4】返回的是大于initialCapacity的最接近的2的整数倍  ，比如initialCapacity传入10，这个方法返回16\n\tstatic final int tableSizeFor(int cap) &#123;//（内部内容讲源码时候不用管，面试题中详讲）\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n &lt; 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    &#125;\n\t\n\t//------------------方法：\n\t//【7】调用put方法\n\tpublic V put(K key, V value) &#123;\n\t\t//【7-1】首先调用hash方法计算哈希值：\n\t\t//【7-3】调用putVal方法传入五个参数：\n        return putVal(hash(key), key, value, false, true);\n    &#125;\n\t//【7-2】计算hash值\n\tstatic final int hash(Object key) &#123;\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    &#125;\n\t//【7-4】调用\n\tfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) &#123;\n        Node&lt;K,V>[] tab;\n\t\tNode&lt;K,V> p; \n\t\tint n, i;\n\t\t//【7-6】将底层主数组table给tab，判断是否为null，第一次放数据一定是null\n        if ((tab = table) == null || (n = tab.length) == 0)\n\t\t\t//【7-7】走入if分支：table是null，就对table进行扩容，走进resize方法\n            n = (tab = resize()).length;//【7-21】table的length为16 ，n为16\n\t\t/*\n\t\t【7-22】\n\t\ti = (n - 1) &amp; hash 根据哈希值和n计算放入数组的位置\n\t\t取出这个位置上的元素，看是否为空，如果是第一个元素，一定是null\n\t\t*/\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n\t\t\t//【7-23】在这个位置上将元素封装为Node对象，放入对应位置\n            tab[i] = newNode(hash, key, value, null);//封装Node节点new Node&lt;>(hash, key, value, null);\n        else &#123;\n            Node&lt;K,V> e; K k;\n            if (p.hash == hash &amp;&amp;\n                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)\n                e = ((TreeNode&lt;K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else &#123;\n                for (int binCount = 0; ; ++binCount) &#123;\n                    if ((e = p.next) == null) &#123;\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1)  \n                            treeifyBin(tab, hash);\n                        break;\n                    &#125;\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    p = e;\n                &#125;\n            &#125;\n            if (e != null) &#123;  \n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            &#125;\n        &#125;\n        ++modCount;\n\t\t//【7-25】size指的是放入集合的键值总数，size++操作，不大于threshold，resize方法不走\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    &#125;\n\t//【7-8】resize方法：---》假设最开始走的是HashMap的空构造器：\n\tfinal Node&lt;K,V>[] resize() &#123;\n        Node&lt;K,V>[] oldTab = table;//【7-9】table 是null\n        int oldCap = (oldTab == null) ? 0 : oldTab.length; //【7-10】oldCap:0\n        int oldThr = threshold;//【7-11】threshold为16，oldThr：16\n        int newCap, newThr = 0;\n        if (oldCap > 0) &#123;//【7-12】不走\n            if (oldCap >= MAXIMUM_CAPACITY) &#123;\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            &#125;\n            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr &lt;&lt; 1;\n        &#125;\n        else if (oldThr > 0)  //【7-13】走\n            newCap = oldThr;//newCap=16\n        else &#123;               //【7-14】不走\n\t\t\t \n            newCap = DEFAULT_INITIAL_CAPACITY;\n\t\t\t \n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        &#125;\n        if (newThr == 0) &#123;//【7-15】走\n            float ft = (float)newCap * loadFactor;//【7-16】ft: 16*0.75=12\n            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE); //【7-17】newThr = 12\n        &#125;\n\t\t//【7-18】threshold赋值为newThr为12， ---》所以走空构造器这里threshold赋值为12，走有参构造器里面threshold赋值为12？？？？\n        threshold = newThr;\n        @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;)\n\t\t//【7-19】创建Node数组，长度为newCap16\n            Node&lt;K,V>[] newTab = (Node&lt;K,V>[])new Node[newCap];\n\t\t//【7-20】table赋值为newTab\n        table = newTab;\n        if (oldTab != null) &#123;\n            for (int j = 0; j &lt; oldCap; ++j) &#123;\n                Node&lt;K,V> e;\n                if ((e = oldTab[j]) != null) &#123;\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash &amp; (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode&lt;K,V>)e).split(this, newTab, j, oldCap);\n                    else &#123; \n                        Node&lt;K,V> loHead = null, loTail = null;\n                        Node&lt;K,V> hiHead = null, hiTail = null;\n                        Node&lt;K,V> next;\n                        do &#123;\n                            next = e.next;\n                            if ((e.hash &amp; oldCap) == 0) &#123;\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            &#125;\n                            else &#123;\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            &#125;\n                        &#125; while ((e = next) != null);\n                        if (loTail != null) &#123;\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        &#125;\n                        if (hiTail != null) &#123;\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return newTab;\n    &#125;\n&#125;\npublic class HashMap&lt;K,V> extends AbstractMap&lt;K,V> \n    implements Map&lt;K,V>, Cloneable, Serializable &#123; \n\tfinal float loadFactor;\n\tstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\tint threshold;\n\ttransient Node&lt;K,V>[] table;\n\tpublic HashMap() &#123;\n        this.loadFactor = DEFAULT_LOAD_FACTOR; \n    &#125;\n\t\n\tpublic HashMap(int initialCapacity) &#123;\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    &#125;\n\tpublic HashMap(int initialCapacity, float loadFactor) &#123;\n        if (initialCapacity &lt; 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    &#125;\n\tstatic final int tableSizeFor(int cap) &#123;\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n &lt; 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    &#125;\n\t\n\t//【8-1】put方法\n\tpublic V put(K key, V value) &#123;\n\t\t//计算hash值\n        return putVal(hash(key), key, value, false, true);\n    &#125;\n\n\tstatic final int hash(Object key) &#123;\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    &#125;\n\t//【8-2】调用putVal方法\n\tfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) &#123;\n        Node&lt;K,V>[] tab;\n\t\tNode&lt;K,V> p; \n\t\tint n, i;\n\t\t\n\t\t//【8-3】table不空了，不走if\t\t\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n\t\t//【8-4】tab[i]不null，不走if\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else &#123;\n            Node&lt;K,V> e; K k;\n\t\t\t/*\n\t\t\t\t【8-5】\n\t\t\t\t判断p.hash == hash哈希值是否相等，即使hash相等也要做&amp;&amp;后续的判断，因为两个对象哈希值相等是有可能的\n\t\t\t\t(k = p.key) == key   == 比较地址值，String的话一样，不是字符串地址也不一样，\n\t\t\t\tAnimal a1 = new Animal(19);\t\t和 \tAnimal a2 = new Animal(19);\t地址一定不同，就需要用后面的equals进行比较\n\t\t\t*/\n            if (p.hash == hash &amp;&amp;\n                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))   //----》哈希值相等，出现哈西碰撞\n\t\t\t\t//【8-6】将该数组位置的数据给e\n                e = p;\n            else if (p instanceof TreeNode)\n                e = ((TreeNode&lt;K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else &#123;\n                for (int binCount = 0; ; ++binCount) &#123;\n                    if ((e = p.next) == null) &#123;\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1)  \n                            treeifyBin(tab, hash);\n                        break;\n                    &#125;\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    p = e;\n                &#125;\n            &#125;\n            if (e != null) &#123;  \n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;//【8-7】新value替换老value\n                afterNodeAccess(e);\n                return oldValue;//【8-8】返回老value\n            &#125;\n        &#125;\n        ++modCount;\n\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    &#125;\n\n\tfinal Node&lt;K,V>[] resize() &#123;\n        Node&lt;K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length; \n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) &#123;\n            if (oldCap >= MAXIMUM_CAPACITY) &#123;\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            &#125;\n            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr &lt;&lt; 1;\n        &#125;\n        else if (oldThr > 0) \n            newCap = oldThr;\n        else &#123;    \n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        &#125;\n        if (newThr == 0) &#123;\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        &#125;\n        threshold = newThr;\n        @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;)\n            Node&lt;K,V>[] newTab = (Node&lt;K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) &#123;\n            for (int j = 0; j &lt; oldCap; ++j) &#123;\n                Node&lt;K,V> e;\n                if ((e = oldTab[j]) != null) &#123;\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash &amp; (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode&lt;K,V>)e).split(this, newTab, j, oldCap);\n                    else &#123; \n                        Node&lt;K,V> loHead = null, loTail = null;\n                        Node&lt;K,V> hiHead = null, hiTail = null;\n                        Node&lt;K,V> next;\n                        do &#123;\n                            next = e.next;\n                            if ((e.hash &amp; oldCap) == 0) &#123;\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            &#125;\n                            else &#123;\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            &#125;\n                        &#125; while ((e = next) != null);\n                        if (loTail != null) &#123;\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        &#125;\n                        if (hiTail != null) &#123;\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return newTab;\n    &#125;\n&#125;\npublic class HashMap&lt;K,V> extends AbstractMap&lt;K,V> \n    implements Map&lt;K,V>, Cloneable, Serializable &#123; \n\tfinal float loadFactor;\n\tstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\tint threshold;\n\ttransient Node&lt;K,V>[] table;\n\tpublic HashMap() &#123;\n        this.loadFactor = DEFAULT_LOAD_FACTOR; \n    &#125;\n\t\n\tpublic HashMap(int initialCapacity) &#123;\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    &#125;\n\tpublic HashMap(int initialCapacity, float loadFactor) &#123;\n        if (initialCapacity &lt; 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    &#125;\n\tstatic final int tableSizeFor(int cap) &#123;\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n &lt; 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    &#125;\n\t\n\t//【9-1】put方法\n\tpublic V put(K key, V value) &#123;\n\t\t//计算hash值\n        return putVal(hash(key), key, value, false, true);\n    &#125;\n\n\tstatic final int hash(Object key) &#123;\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    &#125;\n\t//【9-2】调用putVal方法\n\tfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) &#123;\n        Node&lt;K,V>[] tab;\n\t\tNode&lt;K,V> p; \n\t\tint n, i;\n\t\t\n\t\t//【9-3】table不空了，不走if\t\t\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n\t\t//【9-4】tab[i]不null，不走if\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else &#123;\n            Node&lt;K,V> e; K k;\n\t\t\t/*\n\t\t\t\t【9-5】\n\t\t\t\t判断p.hash == hash哈希值是否相等，即使hash相等也要做&amp;&amp;后续的判断，因为两个对象哈希值相等是有可能的\n\t\t\t\t此时“通话”和“重地”的哈希值一致，但是key不一致，if不走\n\t\t\t*/\n            if (p.hash == hash &amp;&amp;\n                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)//【9-6】p也不是红黑树，不走if\n                e = ((TreeNode&lt;K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else &#123;\n\t\t\t\t//【9-7】走到这里，证明数组的这个位置是个链表了\n                for (int binCount = 0; ; ++binCount) &#123;//【9-8】无条件的死循环   binCount 链表上节点的个数\n\t\t\t\t\t//随着循环  p.next就是一路找链上元素\n\t\t\t\t\t//p.next要是没有元素，就要开始追加了呗\n                    if ((e = p.next) == null) &#123;//【9-10】一路next比较都没有key相同的数据\n\t\t\t\t\t\n                        p.next = newNode(hash, key, value, null);//【9-11】追加在链表尾部 ---》 前七后八\n\t\t\t\t\t\t//【9-12】如果节点个数大于8，进行树化：要从链表转为红黑树\n                        if (binCount >= TREEIFY_THRESHOLD - 1)  \n                            treeifyBin(tab, hash);//【9-13】这里还涉及 剪枝 问题，树节点在6个以下，就又变成链表了\n                        break;\n                    &#125;\n\t\t\t\t\t//【9-9】比较过程中：如果比较链表某个key相同，就break结束了，不用继续走了\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    p = e;\n                &#125;\n            &#125;\n            if (e != null) &#123;  \n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;//【8-7】新value替换老value\n                afterNodeAccess(e);\n                return oldValue;//【8-8】返回老value\n            &#125;\n        &#125;\n        ++modCount;\n\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    &#125;\n\n\tfinal Node&lt;K,V>[] resize() &#123;\n        Node&lt;K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length; \n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) &#123;\n            if (oldCap >= MAXIMUM_CAPACITY) &#123;\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            &#125;\n            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr &lt;&lt; 1;\n        &#125;\n        else if (oldThr > 0) \n            newCap = oldThr;\n        else &#123;    \n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        &#125;\n        if (newThr == 0) &#123;\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        &#125;\n        threshold = newThr;\n        @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;)\n            Node&lt;K,V>[] newTab = (Node&lt;K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) &#123;\n            for (int j = 0; j &lt; oldCap; ++j) &#123;\n                Node&lt;K,V> e;\n                if ((e = oldTab[j]) != null) &#123;\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash &amp; (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode&lt;K,V>)e).split(this, newTab, j, oldCap);\n                    else &#123; \n                        Node&lt;K,V> loHead = null, loTail = null;\n                        Node&lt;K,V> hiHead = null, hiTail = null;\n                        Node&lt;K,V> next;\n                        do &#123;\n                            next = e.next;\n                            if ((e.hash &amp; oldCap) == 0) &#123;\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            &#125;\n                            else &#123;\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            &#125;\n                        &#125; while ((e = next) != null);\n                        if (loTail != null) &#123;\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        &#125;\n                        if (hiTail != null) &#123;\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return newTab;\n    &#125;\n&#125;\n总结：\n默认数组长度为 16，最大程度230{2^{30}}230, 负载因子为 0.75，扩容时扩大 2 倍，\n1.8 比 1.7 改变了底层数据结构而已\n# 4.1.6 HashSet 底层原理\npublic class HashSet&lt;E>&#123;\n    //重要属性：\n    private transient HashMap&lt;E,Object> map;\n    private static final Object PRESENT = new Object();\n    //构造器：\n    public HashSet() &#123;\n        map = new HashMap&lt;>();//HashSet底层就是利用HashMap来完成的\n    &#125;\n        \n    public boolean add(E e) &#123;\n        return map.put(e, PRESENT)==null;\n    &#125;      \n&#125;\n# 4.2TreeMap\n【1】原理大致介绍：\n\n【2】源码：\npublic class TreeMap&lt;K,V>&#123;\n        //重要属性：\n        //外部比较器：\n        private final Comparator&lt;? super K> comparator;\n        //树的根节点：\n        private transient Entry&lt;K,V> root = null;\n        //集合中元素的数量：\n        private transient int size = 0;\n        //空构造器:\n        public TreeMap() &#123;\n        comparator = null;//如果使用空构造器，那么底层就不使用外部比较器\n    &#125;\n        //有参构造器：\n        public TreeMap(Comparator&lt;? super K> comparator) &#123;\n        this.comparator = comparator;//如果使用有参构造器，那么就相当于指定了外部比较器\n    &#125;\n        \n        public V put(K key, V value) &#123;//k,V的类型在创建对象的时候确定了\n        //如果放入的是第一对元素，那么t的值为null\n        Entry&lt;K,V> t = root;//在放入第二个节点的时候，root已经是根节点了\n                //如果放入的是第一个元素的话，走入这个if中：\n        if (t == null) &#123;\n                        //自己跟自己比\n            compare(key, key); // type (and possibly null) check\n                        //根节点确定为root\n            root = new Entry&lt;>(key, value, null);\n                        //size值变为1\n            size = 1;\n            modCount++;\n            return null;\n        &#125;\n                \n        int cmp;\n        Entry&lt;K,V> parent;\n        // split comparator and comparable paths\n                //将外部比较器赋给cpr:\n        Comparator&lt;? super K> cpr = comparator;\n                //cpr不等于null，意味着你刚才创建对象的时候调用了有参构造器，指定了外部比较器\n        if (cpr != null) &#123;\n            do &#123;\n                parent = t;\n                cmp = cpr.compare(key, t.key);//将元素的key值做比较\n                                //cmp返回的值就是int类型的数据：\n                                //要是这个值《0 =0  》0\n                if (cmp &lt; 0)\n                    t = t.left;\n                else if (cmp > 0)\n                    t = t.right;\n                else//cpm==0\n                                //如果key的值一样，那么新的value替换老的value  但是key不变 因为key是唯一的\n                    return t.setValue(value);\n            &#125; while (t != null);\n        &#125;\n                //cpr等于null，意味着你刚才创建对象的时候调用了空构造器，没有指定外部比较器，使用内部比较器\n        else &#123;\n            if (key == null)\n                throw new NullPointerException();\n            Comparable&lt;? super K> k = (Comparable&lt;? super K>) key;\n            do &#123;\n                parent = t;\n                cmp = k.compareTo(t.key);//将元素的key值做比较\n                if (cmp &lt; 0)\n                    t = t.left;\n                else if (cmp > 0)\n                    t = t.right;\n                else\n                    return t.setValue(value);\n            &#125; while (t != null);\n        &#125;\n        Entry&lt;K,V> e = new Entry&lt;>(key, value, parent);\n        if (cmp &lt; 0)\n            parent.left = e;\n        else\n            parent.right = e;\n        fixAfterInsertion(e);\n        size++;//size加1 操作\n        modCount++;\n        return null;\n    &#125;\n        \n        \n&#125;\n static final class Entry&lt;K,V> implements Map.Entry&lt;K,V> &#123;\n        K key;\n        V value;\n        Entry&lt;K,V> left = null;\n        Entry&lt;K,V> right = null;\n        Entry&lt;K,V> parent;\n        boolean color = BLACK;\n &#125;\n# TreeSet 源码\npublic class TreeSet&lt;E> extends AbstractSet&lt;E>\n    implements NavigableSet&lt;E>, Cloneable, java.io.Serializable&#123;\n                //重要属性：\n                private transient NavigableMap&lt;E,Object> m;\n                private static final Object PRESENT = new Object();\n                \n                //在调用空构造器的时候，底层创建了一个TreeMap\n                public TreeSet() &#123;\n                        this(new TreeMap&lt;E,Object>());\n                &#125;\n                \n                TreeSet(NavigableMap&lt;E,Object> m) &#123;\n                        this.m = m;\n                &#125;\n                \n                public boolean add(E e) &#123;\n        return m.put(e, PRESENT)==null;\n    &#125;\n                \n                \n        &#125;\n# Collections 工具类\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //Collections不支持创建对象，因为构造器私有化了\n        /*Collections cols = new Collections();*/\n        //里面的属性和方法都是被static修饰，我们可以直接用类名.去调用即可：\n        //常用方法：\n        //addAll：\n        ArrayList&lt;String> list = new ArrayList&lt;>();\n        list.add(\"cc\");\n        list.add(\"bb\");\n        list.add(\"aa\");\n        Collections.addAll(list,\"ee\",\"dd\",\"ff\");\n        Collections.addAll(list,new String[]&#123;\"gg\",\"oo\",\"pp\"&#125;);\n        System.out.println(list);\n        //binarySearch必须在有序的集合中查找：--》排序：\n        Collections.sort(list);//sort提供的是升序排列\n        System.out.println(list);\n        //binarySearch\n        System.out.println(Collections.binarySearch(list, \"cc\"));\n        //copy:替换方法\n        ArrayList&lt;String> list2 = new ArrayList&lt;>();\n        Collections.addAll(list2,\"tt\",\"ss\");\n        Collections.copy(list,list2);//将list2的内容替换到list上去\n        System.out.println(list);\n        System.out.println(list2);\n        //fill 填充\n        Collections.fill(list2,\"yyy\");\n        System.out.println(list2);\n    &#125;\n&#125;\n# 数据结构\n# 栈\npublic class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        /*\n        Stack是Vector的子类，Vector里面两个重要的属性：\n        Object[] elementData;底层依然是一个数组\n        int elementCount;数组中的容量\n         */\n        Stack s = new Stack();\n        s.add(\"A\");\n        s.add(\"B\");\n        s.add(\"C\");\n        s.add(\"D\");\n        System.out.println(s);//[A, B, C, D]\n        System.out.println(\"栈是否为空：\" + s.empty());\n        System.out.println(\"查看栈顶的数据，但是不移除：\" + s.peek());\n        System.out.println(s);\n        System.out.println(\"查看栈顶的数据，并且不移除：\" + s.pop());\n        System.out.println(s);\n        s.push(\"D\");//和add方法执行的功能一样，就是返回值不同\n        System.out.println(s);\n    &#125;\n&#125;\n# 同步类容器\n比如 ArrayList，HashMap，线程不安全，现在想把线程不安全的集合转换为线程安全的集合：\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //ArrayList为案例：从线程不安全  转为线程安全：\n        List list = Collections.synchronizedList(new ArrayList());\n    &#125;\n&#125;\n试试 ArrayList 的线程不安全：\npublic class Demo &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个ArrayList集合：\n        ArrayList list = new ArrayList();\n        //创建一个线程池：线程池定长100\n        ExecutorService es = Executors.newFixedThreadPool(100);\n        //并发向集合中添加10000个数据：\n        for (int i = 0; i &lt; 10000; i++) &#123;\n            //每个线程处理任务：run方法中的内容就是线程单元，任务，实际线程执行的部分\n            es.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    list.add(\"aaa\");\n                &#125;\n            &#125;);\n        &#125;\n        //关闭线程池：\n        es.shutdown();\n        //监控线程是否执行完毕：\n        while(true)&#123;\n            //线程都执行完以后返回true\n            if(es.isTerminated())&#123;\n                System.out.println(\"所有的子线程都执行完毕了！\");\n                //执行完毕以后看一下集合中元素的数量：\n                System.out.println(list.size());\n                if(list.size() == 10000)&#123;\n                    System.out.println(\"线程安全！\");\n                &#125;else&#123;\n                    System.out.println(\"线程不安全！\");\n                &#125;\n                //线程执行完以后，while循环可以停止：\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n结果：\n\n利用同步类容器解决：\npublic class Demo &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个ArrayList集合：\n        ArrayList oldlist = new ArrayList();\n        List list = Collections.synchronizedList(oldlist);\n        //创建一个线程池：线程池定长100\n        ExecutorService es = Executors.newFixedThreadPool(100);\n        //并发向集合中添加10000个数据：\n        for (int i = 0; i &lt; 10000; i++) &#123;\n            //每个线程处理任务：run方法中的内容就是线程单元，任务，实际线程执行的部分\n            es.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    list.add(\"aaa\");\n                &#125;\n            &#125;);\n        &#125;\n        //关闭线程池：\n        es.shutdown();\n        //监控线程是否执行完毕：\n        while(true)&#123;\n            //线程都执行完以后返回true\n            if(es.isTerminated())&#123;\n                System.out.println(\"所有的子线程都执行完毕了！\");\n                //执行完毕以后看一下集合中元素的数量：\n                System.out.println(list.size());\n                if(list.size() == 10000)&#123;\n                    System.out.println(\"线程安全！\");\n                &#125;else&#123;\n                    System.out.println(\"线程不安全！\");\n                &#125;\n                //线程执行完以后，while循环可以停止：\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n结果：\n\n源码解析：\n\n# ConcurrentMap 并发容器\nJDK5.0 之后提供了多种并发类容器可以替代同步类容器，提升性能、吞吐量\n ConcurrentHashMap 替代 HashMap、HashTable\nConcurrentSkipListMap 替代 TreeMap\n简单原理：\n\n并发情况下，验证提高性能：\nConcunrrentHashMap :\npublic class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //选择一个容器：\n        ConcurrentHashMap&lt;String,Integer> map = new ConcurrentHashMap&lt;>();\n        \n        //创建10个线程：\n        for (int i = 0; i &lt; 10; i++) &#123;\n            new Thread(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    long startTime = System.currentTimeMillis();\n                    for (int j = 0; j &lt; 1000000; j++) &#123;\n                        map.put(\"test\" + j , j);\n                    &#125;\n                    long endTime = System.currentTimeMillis();\n                    System.out.println(\"一共需要的时间：\" + (endTime - startTime));\n                &#125;\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;\n结果：\n\nHashtable：\npublic class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //选择一个容器：\n        //ConcurrentHashMap&lt;String,Integer> map = new ConcurrentHashMap&lt;>();\n        Hashtable map = new Hashtable();\n        //创建10个线程：\n        for (int i = 0; i &lt; 10; i++) &#123;\n            new Thread(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    long startTime = System.currentTimeMillis();\n                    for (int j = 0; j &lt; 1000000; j++) &#123;\n                        map.put(\"test\" + j , j);\n                    &#125;\n                    long endTime = System.currentTimeMillis();\n                    System.out.println(\"一共需要的时间：\" + (endTime - startTime));\n                &#125;\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;\n\nHashMap：\npublic class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //选择一个容器：\n        //ConcurrentHashMap&lt;String,Integer> map = new ConcurrentHashMap&lt;>();\n        //Hashtable map = new Hashtable();\n        HashMap map = new HashMap();\n        //创建10个线程：\n        for (int i = 0; i &lt; 10; i++) &#123;\n            new Thread(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    long startTime = System.currentTimeMillis();\n                    for (int j = 0; j &lt; 1000000; j++) &#123;\n                        map.put(\"test\" + j , j);\n                    &#125;\n                    long endTime = System.currentTimeMillis();\n                    System.out.println(\"一共需要的时间：\" + (endTime - startTime));\n                &#125;\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;\n\n\n线程安全的 HashMap：\npublic class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //选择一个容器：\n        //ConcurrentHashMap&lt;String,Integer> map = new ConcurrentHashMap&lt;>();\n        //Hashtable map = new Hashtable();\n        HashMap oldmap = new HashMap();\n        Map map = Collections.synchronizedMap(oldmap);\n        //创建10个线程：\n        for (int i = 0; i &lt; 10; i++) &#123;\n            new Thread(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    long startTime = System.currentTimeMillis();\n                    for (int j = 0; j &lt; 1000000; j++) &#123;\n                        map.put(\"test\" + j , j);\n                    &#125;\n                    long endTime = System.currentTimeMillis();\n                    System.out.println(\"一共需要的时间：\" + (endTime - startTime));\n                &#125;\n            &#125;).start();\n        &#125;\n    &#125;\n&#125;\n\n总结：\n\n\n\nConcurrentHashMap\n性能高，线程安全\n\n\n\n\nHashtable: 线程安全\n性能低\n\n\nHashMap: 线程不安全\n性能高\n\n\n\n线程安全的 HashMap：线程安全，性能低\n# COW 并发容器\n【1】COW 类并发容器，全称：Copy  On  Write 容器，写时复制容器。（读写分离容器）\n【2】原理：\n向容器中添加元素时，先将容器进行 Copy 复制出一个新容器，然后将元素添加到新容器中，再将原容器的引用指向新容器。\n并发读的时候不需要锁定容器，因为原容器没有变化，所以可以读取原容器中的值，使用的是一种读写分离的思想。\n\n【3】这种设计的好处是什么呢？\n注意上面的操作 arr 数组本身是无锁的，没有锁，在添加数据的时候，做了额外的复制，\n此时如果有线程来读数据，那么读取的是老 arr 的数据，此时 arr 的地址还没有改呢，在我添加元素的过程中，\n无论有多少个线程来读数据，都是读的原来的 arr，不是新的 arr\n 所以性能很高，读写分离。提高了并发的性能。如果再读再复制…\n【4】注意：\nCopyOnWrite 容器只能保证数据的最终一致性，不能保证数据实时一致性。\n所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite 容器。\n【5】适合特定场合：\n这个应用场景显而易见，适合读多写少的情况。如果一万个线程都添加操作，都在集合中添加数据，那数组不断复制，长度不断 + 1，\n那 JVM 肯定一直往上飙升，你用的时候肯定要评估使用场景的。\n由于每次更新都会复制新容器，所以如果数据量较大并且更新操作频繁则对内存消耗很高，建议在高并发读的场景下使用。\n【6】主要讲解：\nCOW 容器有两种一种是 CopyonWriteArrayList，一种是 CopyOnWriteArraySet\n 一个是替代 ArrayList，一个是代替 Set\n# CopyOnWriteArrayList\npublic class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        CopyOnWriteArrayList&lt;Integer> list = new CopyOnWriteArrayList&lt;>();\n        //添加方法：\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        list.add(4);\n        System.out.println(list);//[1, 2, 3, 4]\n        list.add(3);//add方法无论元素是否存在，都可以添加进去--》添加重复的元素\n        System.out.println(list);//[1, 2, 3, 4, 3]\n        //adj. 缺席的；缺少的；心不在焉的；茫然的\n        list.addIfAbsent(33);//添加不存在的元素--》不可以添加重复的数据\n        System.out.println(list);//[1, 2, 3, 4, 3, 33]\n    &#125;\n&#125;\n源码分析：\npublic class CopyOnWriteArrayList&lt;E>&#123;\n        //底层基于数组实现的\n        private transient volatile Object[] array;\n        \n        public CopyOnWriteArrayList() &#123;\n        setArray(new Object[0]);\n    &#125;\n        \n        final void setArray(Object[] a) &#123;\n        array = a; // array = new Object[0]\n    &#125;\n        //add方法：\n        public boolean add(E e) &#123;\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try &#123;\n                        //返回底层array数组,给了elements\n            Object[] elements = getArray();\n                        //获取elements的长度---》获取老数组的长度\n            int len = elements.length;\n                        //完成数组的复制，将老数组中的元素复制到新数组中，并且新数组的长度加1操作\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\n                        //将e元素放入新数组最后位置\n            newElements[len] = e;\n                        //array数组的指向从老数组变为新数组\n            setArray(newElements);\n            return true;\n        &#125; finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n        \n        \n        final Object[] getArray() &#123;\n        return array;//返回底层数组\n    &#125;\n        \n        \n        private boolean addIfAbsent(E e, Object[] snapshot) &#123;\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try &#123;\n                        //取出array数组给current\n            Object[] current = getArray();\n            int len = current.length;\n            if (snapshot != current) &#123;\n                // Optimize for lost race to another addXXX operation\n                int common = Math.min(snapshot.length, len);\n                                //遍历老数组：\n                for (int i = 0; i &lt; common; i++)\n                                        //eq(e, current[i])将放入的元素和老数组的每一个元素进行比较，如果有重复的元素，就返回false，不添加了\n                    if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))\n                        return false;\n                if (indexOf(e, current, common, len) >= 0)\n                        return false;\n            &#125;\n                        //完成数组的复制，将老数组中的元素复制到新数组中，并且新数组的长度加1操作\n            Object[] newElements = Arrays.copyOf(current, len + 1);\n                        //将e元素放入新数组最后位置\n            newElements[len] = e;\n                        //array数组的指向从老数组变为新数组\n            setArray(newElements);\n            return true;\n        &#125; finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;             \n&#125;\n# CopyOnWriteArraySet\npublic class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建一个集合：\n        CopyOnWriteArraySet&lt;Integer> set = new CopyOnWriteArraySet&lt;>();\n        //在这里也体现出Set和List的本质区别，就在于是否重复\n        //所以add方法直接不可以添加重复数据进去\n        set.add(1);\n        set.add(2);\n        set.add(2);\n        set.add(7);\n        System.out.println(set);//[1, 2, 7]\n        \n    &#125;\n&#125;\n源码：\npublic class CopyOnWriteArraySet&lt;E>&#123;\n        //CopyOnWriteArraySet底层基于CopyOnWriteArrayList\n        private final CopyOnWriteArrayList&lt;E> al;\n        \n        public CopyOnWriteArraySet() &#123;\n        al = new CopyOnWriteArrayList&lt;E>();\n    &#125;\n        \n        //添加方法：\n        public boolean add(E e) &#123;\n        return al.addIfAbsent(e);//底层调用的还是CopyOnWriteArrayList的addIfAbsent\n    &#125;\n&#125;\n总结：\n由上面的源码看出，每次调用 CopyOnWriteArraySet 的 add 方法时候，其实底层是基于 CopyOnWriteArrayList 的 addIfAbsent，\n每次在 addIfAbsent 方法中每次都要对数组进行遍历，所以 CopyOnWriteArraySet 的性能低于 CopyOnWriteArrayList\n# 队列\n数据结构分为：\n（1）逻辑结构 ：–》思想上的结构–》卧室，厨房，卫生间 —》线性表（数组，链表），图，树，栈，队列\n（2）物理结构 ：–》真实结构–》钢筋混凝土 + 牛顿力学 ------》紧密结构（顺序结构），跳转结构（链式结构）\n队列：特点：先进先出 （FIFO）（first in first out）\n\n\n他有两端，一端是让新元素进去，一端是让老元素出去\n在需要公平且经济地对各种自然或社会资源做管理或分配的场合，无论是调度银行和医院的服务窗口，还是管理轮耕的田地和轮伐的森林，队列都可大显身手。\n甚至计算机及其网络自身内部的各种计算资源，无论是多进程共享的 CPU 时间，还是多用户共享的打印机，也都需要借助队列结构实现合理和优化的分配。\n双端队列：两端都可以进行进队，出队的队列：\n（1）前端，后端都可以进出：\n\n（2）进行限制：\n\n（3）特殊情况，双端队列实现栈操作:\n\n栈和队列的物理结构实现 可以用线性表的数组，链表都可以\n# 队列 Queue\n# 阻塞队列\n# BlockingQueue 介绍\n\n总结：BlockingQueue 继承 Queue，Queue 继承自 Collection\n 所以 Collection 最基础的增删改查操作是有的，在这个基础上，多了 Queue 的特点，在这个基础上又多了阻塞的特点，最终形成了 BlockingQueue\n什么叫阻塞？\n\n\n常用的 API：\n添加：\n\n\n\nput 是阻塞的\n查询：\n\n\ntake 是阻塞的\n删除：\n\n# 常见子类\nArrayBlockingQueue\nLinkedBlockingQueue\nSynchronousQueue\nPriorityBlockingQueue\nDelayQueue\n\n\n\n\n\n\n\n\n\n\nArrayBlockingQueue\n源码中的注释的解释说明：\n\n【1】添加元素：\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws InterruptedException &#123;\n        //创建一个队列，队列可以指定容量指定长度3：\n        ArrayBlockingQueue aq = new ArrayBlockingQueue(3);\n        //添加元素：\n        //【1】添加null元素：不可以添加null元素，会报空指针异常：NullPointerException\n        //aq.add(null);\n        //aq.offer(null);\n        //aq.put(null);\n        //【2】正常添加元素：\n        aq.add(\"aaa\");\n        aq.offer(\"bbb\");\n        aq.put(\"ccc\");\n        System.out.println(aq);//[aaa, bbb, ccc]\n        //【3】在队列满的情况下，再添加元素：\n        //aq.add(\"ddd\");//在队列满的情况下，添加元素 出现异常：Queue full\n        //System.out.println(aq.offer(\"ddd\"));//没有添加成功，返回false\n        //设置最大阻塞时间，如果时间到了，队列还是满的，就不再阻塞了\n        //aq.offer(\"ddd\",2, TimeUnit.SECONDS);\n        //真正阻塞的方法： put ,如果队列满，就永远阻塞 \n        aq.put(\"ddd\");\n        System.out.println(aq);\n    &#125;\n&#125;\n【2】获取元素：\npublic class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws InterruptedException &#123;\n        //创建一个队列，队列可以指定容量指定长度3：\n        ArrayBlockingQueue aq = new ArrayBlockingQueue(3);\n        aq.add(\"aaa\");\n        aq.add(\"bbb\");\n        aq.add(\"ccc\");\n        //得到头元素但是不移除\n        System.out.println(aq.peek());\n        System.out.println(aq);\n        //得到头元素并且移除\n        System.out.println(aq.poll());\n        System.out.println(aq);\n        //得到头元素并且移除\n        System.out.println(aq.take());\n        System.out.println(aq);\n        //清空元素：\n        aq.clear();\n        System.out.println(aq);\n        System.out.println(aq.peek());//null\n        System.out.println(aq.poll());//null\n        //设置阻塞事件，如果队列为空，返回null，时间到了以后就不阻塞了\n        //System.out.println(aq.poll(2, TimeUnit.SECONDS));\n        //真正阻塞：队列为空，永远阻塞\n        System.out.println(aq.take());\n    &#125;\n&#125;\n【3】源码：\npublic class ArrayBlockingQueue&lt;E> &#123;\n        //底层就是一个数组：\n        final Object[] items;\n        //取元素用到的索引，初始结果为0\n        int takeIndex;\n        //放元素用到的索引，初始结果为0\n        int putIndex;\n        //数组中元素的个数：\n        int count;\n        \n        //一把锁：这个锁肯定很多方法中用到了，所以定义为属性，初始化以后可以随时使用\n    final ReentrantLock lock;\n    //锁伴随的一个等待吃：notEmpty\n    private final Condition notEmpty;\n    //锁伴随的一个等待吃：notFull\n    private final Condition notFull;\n        \n        //构造器：\n        public ArrayBlockingQueue(int capacity) &#123;//传入队列指定的容量\n        this(capacity, false);\n    &#125;\n        \n        public ArrayBlockingQueue(int capacity, boolean fair) &#123;//传入队列指定的容量\n                //健壮性考虑\n        if (capacity &lt;= 0)\n            throw new IllegalArgumentException();\n                //初始化底层数组\n        this.items = new Object[capacity];\n                //初始化锁 和  等待队列\n        lock = new ReentrantLock(fair);\n        notEmpty = lock.newCondition();\n        notFull =  lock.newCondition();\n    &#125;\n        \n        //两个基本方法：一个是入队，一个是出队  ，是其他方法的基础：\n        //入队：\n        private void enqueue(E x) &#123;\n        // assert lock.getHoldCount() == 1;\n        // assert items[putIndex] == null;\n        final Object[] items = this.items;//底层数组赋给items\n                //在对应的下标位置放入元素\n        items[putIndex] = x;\n        if (++putIndex == items.length) //++putIndex putIndex 索引 加1 \n            putIndex = 0;\n                //每放入一个元素，count加1操作\n        count++;\n        notEmpty.signal();\n    &#125;\n        \n        \n        //出队：\n        private E dequeue() &#123;\n        // assert lock.getHoldCount() == 1;\n        // assert items[takeIndex] != null;\n        final Object[] items = this.items;//底层数组赋给items\n        @SuppressWarnings(\"unchecked\")\n        E x = (E) items[takeIndex];//在对应的位置取出元素\n        items[takeIndex] = null;//对应位置元素取出后就置为null\n        if (++takeIndex == items.length)//++takeIndex 加1操作\n            takeIndex = 0;\n        count--;//每取出一个元素，count减1操作\n        if (itrs != null)\n            itrs.elementDequeued();\n        notFull.signal();\n        return x;//将取出的元素作为方法的返回值\n    &#125;       \n&#125;\ntakeIndex 和 putIndex 置为 0 的原因：\n\n【4】其他的添加或者获取的方法都是依托与这个入队和出队的基础方法\n\n【5】感受一下 put 和 take 的阻塞：\n\n上面的 while 不可以换为 if，因为如果 notFull 中的线程被激活的瞬间，有其他线程放入元素，那么队列就又满了\n那么沿着 await 后面继续执行就不可以，所以一定要反复确定队列是否满的，才能放入元素\n\n\n\n\n\n\n\n\n\n\nLinkedBlockingQueue\n一个可选择的有边界的队列：意思就是队列的长度可以指定，也可以不指定\n\n【1】添加元素：\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws InterruptedException &#123;\n        //创建一个队列，队列可以指定容量指定长度3：\n        LinkedBlockingQueue aq = new LinkedBlockingQueue(3);\n        //添加元素：\n        //【1】添加null元素：不可以添加null元素，会报空指针异常：NullPointerException\n        //aq.add(null);\n        //aq.offer(null);\n        aq.put(null);\n        //【2】正常添加元素：\n        aq.add(\"aaa\");\n        aq.offer(\"bbb\");\n        aq.put(\"ccc\");\n        System.out.println(aq);//[aaa, bbb, ccc]\n        //【3】在队列满的情况下，再添加元素：\n        //aq.add(\"ddd\");//在队列满的情况下，添加元素 出现异常：Queue full\n        //System.out.println(aq.offer(\"ddd\"));//没有添加成功，返回false\n        //设置最大阻塞时间，如果时间到了，队列还是满的，就不再阻塞了\n        //aq.offer(\"ddd\",2, TimeUnit.SECONDS);\n        //真正阻塞的方法： put ,如果队列满，就永远阻塞\n        aq.put(\"ddd\");\n        System.out.println(aq);\n    &#125;\n&#125;\n【2】取出元素：\npublic class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws InterruptedException &#123;\n        //创建一个队列，队列可以指定容量指定长度3：\n        LinkedBlockingQueue aq = new LinkedBlockingQueue();\n        aq.add(\"aaa\");\n        aq.add(\"bbb\");\n        aq.add(\"ccc\");\n        //得到头元素但是不移除\n        System.out.println(aq.peek());\n        System.out.println(aq);\n        //得到头元素并且移除\n        System.out.println(aq.poll());\n        System.out.println(aq);\n        //得到头元素并且移除\n        System.out.println(aq.take());\n        System.out.println(aq);\n        //清空元素：\n        aq.clear();\n        System.out.println(aq);\n        System.out.println(aq.peek());//null\n        System.out.println(aq.poll());//null\n        //设置阻塞事件，如果队列为空，返回null，时间到了以后就不阻塞了\n        //System.out.println(aq.poll(2, TimeUnit.SECONDS));\n        //真正阻塞：队列为空，永远阻塞\n        System.out.println(aq.take());\n    &#125;\n&#125;\n【3】特点：\nArrayBlockingQueue ： 不支持读写同时操作，底层基于数组的。\nLinkedBlockingQueue：支持读写同时操作，并发情况下，效率高。底层基于链表。\n【4】源码：\n入队操作：\n\n出队操作：\n\npublic class LinkedBlockingQueue&lt;E>&#123;\n        //内部类Node就是链表的节点的对象对应的类：\n        static class Node&lt;E> &#123;\n        E item;//封装你要装的那个元素\n        \n        Node&lt;E> next;//下一个Node节点的地址\n        Node(E x) &#123; item = x; &#125;//构造器\n    &#125;\n        //链表的长度\n        private final int capacity;\n        //计数器：\n        private final AtomicInteger count = new AtomicInteger();\n        //链表的头结点\n        transient Node&lt;E> head;\n        //链表的尾结点\n        private transient Node&lt;E> last;\n        //取元素用的锁\n        private final ReentrantLock takeLock = new ReentrantLock();\n        //等待池\n    private final Condition notEmpty = takeLock.newCondition();\n    //放元素用的锁\n    private final ReentrantLock putLock = new ReentrantLock();\n    //等待池\n    private final Condition notFull = putLock.newCondition();\n        \n        public LinkedBlockingQueue() &#123;\n        this(Integer.MAX_VALUE);//调用类本类的空构造器，传入正21亿\n    &#125;\n        \n        public LinkedBlockingQueue(int capacity) &#123;\n                //健壮性考虑\n        if (capacity &lt;= 0) throw new IllegalArgumentException();\n                //给队列指定长度  \n        this.capacity = capacity;\n                //last，head指向一个新的节点，新的节点中 元素为null \n        last = head = new Node&lt;E>(null);\n    &#125;\n        \n        \n        //入队：\n        private void enqueue(Node&lt;E> node) &#123;\n        last = last.next = node;\n    &#125;\n        \n        //出队：\n        private E dequeue() &#123;\n        Node&lt;E> h = head;//h指向了head\n        Node&lt;E> first = h.next;//first 指向head的next\n        h.next = h; // help GC   h.next指向自己，更容易被GC发现 被GC\n        head = first;//head的指向指为first\n        E x = first.item;//取出链中第一个元素，给了x\n        first.item = null;\n        return x;//把x作为方法的返回值\n    &#125;\n&#125;\n【5】put 的阻塞：\n阻塞的前提是  队列是固定长度的\n\n\n\n\n\n\n\n\n\n\n\nSynchronousQueue\n\n这个特殊的队列设计的意义：\n\n测试 1：先添加元素：\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        SynchronousQueue sq = new SynchronousQueue();\n        sq.add(\"aaa\");\n    &#125;\n&#125;\n直接报错：说队列满了，因为队列没有容量，理解为满也是正常的：\n\n测试 2：put 方法  阻塞：队列是空的，可以理解为队列满了，满的话放入元素 put 一定会阻塞：\npublic class Test01 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws InterruptedException &#123;\n        SynchronousQueue sq = new SynchronousQueue();\n        sq.put(\"aaa\");\n    &#125;\n&#125;\n\n测试 3：先取  再放：\npublic class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        SynchronousQueue sq = new SynchronousQueue();\n        //创建一个线程，取数据：\n        new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                while(true)&#123;\n                    try &#123;\n                        System.out.println(sq.take());\n                    &#125; catch (InterruptedException e) &#123;\n                        e.printStackTrace();\n                    &#125;\n                &#125;\n            &#125;\n        &#125;).start();\n        //搞一个线程，往里面放数据：\n        new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                try &#123;\n                    sq.put(\"aaa\");\n                    sq.put(\"bbb\");\n                    sq.put(\"ccc\");\n                    sq.put(\"ddd\");\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;).start();\n    &#125;\n&#125;\n\n测试 4：poll 方法：\npublic class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        SynchronousQueue sq = new SynchronousQueue();\n        //创建一个线程，取数据：\n        new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                while(true)&#123;\n                    try &#123;\n                        //设置一个阻塞事件：超出事件就不阻塞了\n                        Object result = sq.poll(5, TimeUnit.SECONDS);\n                        System.out.println(result);\n                        if(result == null)&#123;\n                            break;\n                        &#125;\n                    &#125; catch (InterruptedException e) &#123;\n                        e.printStackTrace();\n                    &#125;\n                &#125;\n            &#125;\n        &#125;).start();\n        //搞一个线程，往里面放数据：\n        new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                try &#123;\n                    sq.put(\"aaa\");\n                    sq.put(\"bbb\");\n                    sq.put(\"ccc\");\n                    sq.put(\"ddd\");\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;).start();\n    &#125;\n&#125;\n\n\n注意：取出元素 不能用 peek，因为 peek 不会将元素从队列中拿走，只是查看的效果；\n\n\n\n\n\n\n\n\n\n\nPriorityBlockingQueue\n带有优先级的阻塞队列。\n优先级队列，意味着队列有先后顺序的，数据有不同的权重。\n无界的队列，没有长度限制，但是在你不指定长度的时候，默认初始长度为 11，也可以手动指定，\n当然随着数据不断的加入，底层（底层是数组 Object []）会自动扩容，直到内存全部消耗殆尽了，导致 OutOfMemoryError 内存溢出 程序才会结束。\n\n不可以放入 null 元素的，不允许放入不可比较的对象（导致抛出 ClassCastException），对象必须实现内部比较器或者外部比较器。\n测试 1：添加 null 数据：\npublic class Test &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        PriorityBlockingQueue pq = new PriorityBlockingQueue();\n        pq.put(null);\n    &#125;\n&#125;\n\n测试 2：添加四个数据：\npublic class Student implements Comparable&lt;Student> &#123;\n    String name;\n    int age;\n    public Student() &#123;\n    &#125;\n    public Student(String name, int age) &#123;\n        this.name = name;\n        this.age = age;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return \"Student&#123;\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '&#125;';\n    &#125;\n    @Override\n    public int compareTo(Student o) &#123;\n        return this.age - o.age;\n    &#125;\n&#125;\npublic class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        PriorityBlockingQueue&lt;Student> pq = new PriorityBlockingQueue&lt;>();\n        pq.put(new Student(\"nana\",18));\n        pq.put(new Student(\"lulu\",11));\n        pq.put(new Student(\"feifei\",6));\n        pq.put(new Student(\"mingming\",21));\n        System.out.println(pq);\n    &#125;\n&#125;\n结果\n\n发现结果并没有按照优先级顺序排列\n测试 3：取出数据：\npublic class Test02 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) throws InterruptedException &#123;\n        PriorityBlockingQueue&lt;Student> pq = new PriorityBlockingQueue&lt;>();\n        pq.put(new Student(\"nana\",18));\n        pq.put(new Student(\"lulu\",11));\n        pq.put(new Student(\"feifei\",6));\n        pq.put(new Student(\"mingming\",21));\n        System.out.println(\"------------------------------------------\");\n        System.out.println(pq.take());\n        System.out.println(pq.take());\n        System.out.println(pq.take());\n        System.out.println(pq.take());\n    &#125;\n&#125;\n\n从结果证明，这个优先级队列，并不是在 put 数据的时候计算谁在前谁在后\n而是取数据的时候，才真正判断谁在前 谁在后\n优先级 --》取数据的优先级\n\n\n\n\n\n\n\n\n\n\nDelayQueue\n一、DelayQueue 是什么\n DelayQueue 是一个无界的 BlockingQueue，用于放置实现了 Delayed 接口的对象，其中的对象只能在其到期时才能从队列中取走。\n\n​\t 当生产者线程调用 put 之类的方法加入元素时，会触发 Delayed 接口中的 compareTo 方法进行排序，也就是说队列中元素的顺序是按到期时间排序的，而非它们进入队列的顺序。排在队列头部的元素是最早到期的，越往后到期时间赿晚。\n消费者线程查看队列头部的元素，注意是查看不是取出。然后调用元素的 getDelay 方法，如果此方法返回的值小０或者等于０，则消费者线程会从队列中取出此元素，并进行处理。如果 getDelay 方法返回的值大于 0，则消费者线程 wait 返回的时间值后，再从队列头部取出元素，此时元素应该已经到期。\n​\t注意：不能将 null 元素放置到这种队列中。\n二、DelayQueue 能做什么\n\n\n淘宝订单业务：下单之后如果三十分钟之内没有付款就自动取消订单。\n\n\n饿了吗订餐通知：下单成功后 60s 之后给用户发送短信通知。\n\n\n关闭空闲连接。服务器中，有很多客户端的连接，空闲一段时间之后需要关闭之。\n\n\n缓存。缓存中的对象，超过了空闲时间，需要从缓存中移出。\n\n\n任务超时处理。在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求等。\n\n\n案例：\npublic class User implements Delayed &#123;\n    private int id;//用户id\n    private String name;//用户名字\n    private long endTime;//结束时间\n    public int getId() &#123;\n        return id;\n    &#125;\n    public void setId(int id) &#123;\n        this.id = id;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public long getEndTime() &#123;\n        return endTime;\n    &#125;\n    public void setEndTime(long endTime) &#123;\n        this.endTime = endTime;\n    &#125;\n    public User(int id, String name, long endTime) &#123;\n        this.id = id;\n        this.name = name;\n        this.endTime = endTime;\n    &#125;\n    //只包装用户名字就可以\n    @Override\n    public String toString() &#123;\n        return \"User&#123;\" +\n                \"name='\" + name + '\\'' +\n                '&#125;';\n    &#125;\n    @Override\n    public long getDelay(TimeUnit unit) &#123;\n        //计算剩余时间 剩余时间小于0 &lt;=0  证明已经到期\n        return this.getEndTime() - System.currentTimeMillis();\n    &#125;\n    @Override\n    public int compareTo(Delayed o) &#123;\n        //队列中数据 到期时间的比较\n        User other = (User)o;\n        return ((Long)(this.getEndTime())).compareTo((Long)(other.getEndTime()));\n    &#125;\n&#125;\ncompareTo：看谁先被移除\n getDelay ：看剩余时间\npublic class TestDelayQueue &#123;\n    //创建一个队列：\n    DelayQueue&lt;User> dq = new DelayQueue&lt;>();\n    //登录游戏：\n    public void login(User user)&#123;\n        dq.add(user);\n        System.out.println(\"用户：[\" + user.getId() +\"],[\" + user.getName() + \"]已经登录，预计下机时间为：\" + user.getEndTime() );\n    &#125;\n    //时间到，退出游戏，队列中移除：\n    public void logout()&#123;\n        //打印队列中剩余的人：\n        System.out.println(dq);\n        try &#123;\n            User user = dq.take();\n            System.out.println(\"用户：[\" + user.getId() +\"],[\" + user.getName() + \"]上机时间到，自动退出游戏\");\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    //获取在线人数：\n    public int onlineSize()&#123;\n        return dq.size();\n    &#125;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        //创建测试类对象：\n        TestDelayQueue test = new TestDelayQueue();\n        //添加登录的用户：\n        test.login(new User(1,\"张三\",System.currentTimeMillis()+5000));\n        test.login(new User(2,\"李四\",System.currentTimeMillis()+2000));\n        test.login(new User(3,\"王五\",System.currentTimeMillis()+10000));\n        //一直监控\n        while(true)&#123;\n            //到期的话，就自动下线：\n            test.logout();\n            //队列中元素都被移除了的话，那么停止监控，停止程序即可\n            if(test.onlineSize() == 0)&#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n# 双端队列 Deque\npublic class Test03 &#123;\n    //这是main方法，程序的入口\n    public static void main(String[] args) &#123;\n        /*\n        双端队列：\n        Deque&lt;E> extends Queue\n        Queue一端放 一端取的基本方法  Deque是具备的\n        在此基础上 又扩展了 一些 头尾操作（添加，删除，获取）的方法\n         */\n        Deque&lt;String> d = new LinkedList&lt;>() ;\n        d.offer(\"A\");\n        d.offer(\"B\");\n        d.offer(\"C\");\n        System.out.println(d);//[A, B, C]\n        d.offerFirst(\"D\");\n        d.offerLast(\"E\");\n        System.out.println(d);//[D, A, B, C, E]\n        System.out.println(d.poll());\n        System.out.println(d);//[A, B, C, E]\n        System.out.println(d.pollFirst());\n        System.out.println(d.pollLast());\n        System.out.println(d);\n    &#125;\n&#125;\n","slug":"第11章集合","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,集合","tags_index":"JavaSE","author_index":"雾都"},{"id":"0ed879ee9bae9c3930e12cda3b50c3db","title":"第14章_网络编程","content":"# 引入\n【1】网络编程：\n把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。\n设备之间在网络中进行数据的传输，发送 / 接收数据。\n\n【2】通信两个重要的要素：IP+PORT\n\n域名：www.baidu.com ------&gt;DNS 服务器解析 ----&gt; IP 地址\nwww.mashibing.com\nwww.sina.com\nwww.wanda.com\nwww.bbbb.com\n【3】设备之间进行传输的时候，必须遵照一定的规则 —》通信协议：\n\n\n【4】TCP 协议：可靠的\n建立连接： 三次握手\n\n释放连接：四次挥手\n\n【5】UDP 协议：不可靠的\n\n# InetAddress,InetSocketAddress\n前情提要：File —》 封装盘符一个文件\n【1】InetAddress —》 封装了 IP\npublic class Test01 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws UnknownHostException &#123;\n        //封装IP：\n        //InetAddress ia = new InetAddress();不能直接创建对象，因为InetAddress()被default修饰了。\n        InetAddress ia = InetAddress.getByName(\"192.168.199.217\");\n        System.out.println(ia);\n        InetAddress ia2 = InetAddress.getByName(\"localhost\");//localhost指代的是本机的ip地址\n        System.out.println(ia2);\n        InetAddress ia3 = InetAddress.getByName(\"127.0.0.1\");//127.0.0.1指代的是本机的ip地址\n        System.out.println(ia3);\n        InetAddress ia4 = InetAddress.getByName(\"LAPTOP-CRIVSRRU\");//封装计算机名\n        System.out.println(ia4);\n        InetAddress ia5 = InetAddress.getByName(\"www.mashibing.com\");//封装域名\n        System.out.println(ia5);\n\n        System.out.println(ia5.getHostName());//获取域名\n        System.out.println(ia5.getHostAddress());//获取ip地址\n    &#125;\n&#125;\n【2】InetSocketAddress —》封装了 IP，端口号\npublic class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        InetSocketAddress isa = new InetSocketAddress(\"192.168.199.217\",8080);\n        System.out.println(isa);\n        System.out.println(isa.getHostName());\n        System.out.println(isa.getPort());\n\n        InetAddress ia = isa.getAddress();\n        System.out.println(ia.getHostName());\n        System.out.println(ia.getHostAddress());\n    &#125;\n&#125;\n# 网络通信原理–套接字\n\n# 基于 TCP 的网络编程\n功能：模拟网站的登录，客户端录入账号密码，然后服务器端进行验证。\n# 功能分解 1：单向通信\n功能：客户端发送一句话到服务器：\n客户端：\npublic class TestClient &#123;//客户端\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.创建套接字：指定服务器的ip和端口号：\n        Socket s = new Socket(\"192.168.199.217\",8888);\n        //2.对于程序员来说，向外发送数据 感受 --》利用输出流：\n        OutputStream os = s.getOutputStream();\n        DataOutputStream dos = new DataOutputStream(os);\n        //利用这个OutputStream就可以向外发送数据了，但是没有直接发送String的方法\n        //所以我们又在OutputStream外面套了一个处理流：DataOutputStream\n        dos.writeUTF(\"你好\");\n\n        //3.关闭流 + 关闭网络资源：\n        dos.close();\n        os.close();\n        s.close();\n    &#125;\n&#125;\n服务器：\npublic class TestServer &#123;//服务器\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.创建套接字： 指定服务器的端口号\n        ServerSocket ss = new ServerSocket(8888);\n        //2.等着客户端发来的信息：\n        Socket s = ss.accept();//阻塞方法:等待接收客户端的数据，什么时候接收到数据，什么时候程序继续向下执行。\n        //accept()返回值为一个Socket，这个Socket其实就是客户端的Socket\n        //接到这个Socket以后，客户端和服务器才真正产生了连接，才真正可以通信了\n        //3.感受到的操作流：\n        InputStream is = s.getInputStream();\n        DataInputStream dis = new DataInputStream(is);\n\n        //4.读取客户端发来的数据：\n        String str = dis.readUTF();\n        System.out.println(\"客户端发来的数据为：\"+str);\n\n        //5.关闭流+关闭网络资源：\n        dis.close();\n        is.close();\n        s.close();\n        ss.close();\n    &#125;\n&#125;\n\n测试：\n（1）先开启客户端还是先开启服务器：先开服务器，再开启客户端\n侧面验证：先开客户端：出错：\n\n# \n# 功能分解 2：双向通信\n服务器端：\n\n\n\nimport java.io.\\*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n/\\*\\*\n    \\* @author : msb-zhaoss\n        \\*/\n        public class TestServer &#123;//服务器\n\n            //这是一个main方法，是程序的入口：\n            public static void main(String[] args) throws IOException &#123;\n                //1.创建套接字： 指定服务器的端口号\n                ServerSocket ss = new ServerSocket(8888);\n                //2.等着客户端发来的信息：\n                Socket s = ss.accept();//阻塞方法:等待接收客户端的数据，什么时候接收到数据，什么时候程序继续向下执行。\n                //accept()返回值为一个Socket，这个Socket其实就是客户端的Socket\n                //接到这个Socket以后，客户端和服务器才真正产生了连接，才真正可以通信了\n                //3.感受到的操作流：\n                InputStream is = s.getInputStream();\n                DataInputStream dis = new DataInputStream(is);\n\n                //4.读取客户端发来的数据：\n                String str = dis.readUTF();\n                System.out.println(\"客户端发来的数据为：\"+str);\n\n                //向客户端输出一句话：---》操作流---》输出流\n                OutputStream os = s.getOutputStream();\n                DataOutputStream dos = new DataOutputStream(os);\n                dos.writeUTF(\"你好，我是服务器端，我接受到你的请求了\");\n\n\n                //5.关闭流+关闭网络资源：\n                dos.close();\n                os.close();\n                dis.close();\n                is.close();\n                s.close();\n                ss.close();\n            &#125;\n        &#125;\n\n\n客户端：\n\n\n\nimport java.io.\\*;\nimport java.net.Socket;\n\npublic class TestClient &#123;//客户端\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.创建套接字：指定服务器的ip和端口号：\n        Socket s = new Socket(\"192.168.199.217\",8888);\n        //2.对于程序员来说，向外发送数据 感受 --》利用输出流：\n        OutputStream os = s.getOutputStream();\n        DataOutputStream dos = new DataOutputStream(os);\n        //利用这个OutputStream就可以向外发送数据了，但是没有直接发送String的方法\n        //所以我们又在OutputStream外面套了一个处理流：DataOutputStream\n        dos.writeUTF(\"你好\");\n\n        //接收服务器端的回话--》利用输入流：\n        InputStream is = s.getInputStream();\n        DataInputStream dis = new DataInputStream(is);\n        String str = dis.readUTF();\n        System.out.println(\"服务器端对我说：\"+str);\n\n        //3.关闭流 + 关闭网络资源：\n        dis.close();\n        is.close();\n        dos.close();\n        os.close();\n        s.close();\n    &#125;\n&#125;\n\n\n注意：关闭防火墙\n# 功能分解 3：对象流传送\n封装的 User 类：\n\n\n\nimport java.io.Serializable;\n\n\npublic class User implements Serializable &#123;\n    private static final long serialVersionUID = 9050691344308365540L;\n    private String name;\n    private String pwd;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public String getPwd() &#123;\n        return pwd;\n    &#125;\n\n    public void setPwd(String pwd) &#123;\n        this.pwd = pwd;\n    &#125;\n\n    public User(String name, String pwd) &#123;\n        this.name = name;\n        this.pwd = pwd;\n    &#125;\n&#125;\n\n\n客户端：\n\n\n\nimport java.io.\\*;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class TestClient &#123;//客户端\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        //1.创建套接字：指定服务器的ip和端口号：\n        Socket s = new Socket(\"192.168.199.217\",8888);\n\n        //录入用户的账号和密码：\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请录入您的账号：\");\n        String name = sc.next();\n        System.out.println(\"请录入您的密码：\");\n        String pwd = sc.next();\n        //将账号和密码封装为一个User的对象：\n        User user = new User(name,pwd);\n\n\n        //2.对于程序员来说，向外发送数据 感受 --》利用输出流：\n        OutputStream os = s.getOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(os);\n        oos.writeObject(user);\n\n\n        //接收服务器端的回话--》利用输入流：\n        InputStream is = s.getInputStream();\n        DataInputStream dis = new DataInputStream(is);\n        boolean b = dis.readBoolean();\n        if(b)&#123;\n            System.out.println(\"恭喜，登录成功\");\n        &#125;else&#123;\n            System.out.println(\"对不起，登录失败\");\n        &#125;\n\n        //3.关闭流 + 关闭网络资源：\n        dis.close();\n        is.close();\n        oos.close();\n        os.close();\n        s.close();\n    &#125;\n&#125;\n\n\n服务器：\n\n\n\nimport java.io.\\*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n\npublic class TestServer &#123;//服务器\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;\n        //1.创建套接字： 指定服务器的端口号\n        ServerSocket ss = new ServerSocket(8888);\n        //2.等着客户端发来的信息：\n        Socket s = ss.accept();//阻塞方法:等待接收客户端的数据，什么时候接收到数据，什么时候程序继续向下执行。\n        //accept()返回值为一个Socket，这个Socket其实就是客户端的Socket\n        //接到这个Socket以后，客户端和服务器才真正产生了连接，才真正可以通信了\n        //3.感受到的操作流：\n        InputStream is = s.getInputStream();\n        ObjectInputStream ois = new ObjectInputStream(is);\n\n        //4.读取客户端发来的数据：\n        User user = (User)(ois.readObject());\n\n        //对对象进行验证：\n        boolean flag = false;\n        if(user.getName().equals(\"娜娜\")&amp;&amp;user.getPwd().equals(\"123123\"))&#123;\n            flag = true;\n        &#125;\n\n        //向客户端输出结果：---》操作流---》输出流\n        OutputStream os = s.getOutputStream();\n        DataOutputStream dos = new DataOutputStream(os);\n        dos.writeBoolean(flag);\n\n\n        //5.关闭流+关闭网络资源：\n        dos.close();\n        os.close();\n        ois.close();\n        is.close();\n        s.close();\n        ss.close();\n    &#125;\n&#125;\n\n\n# 功能分解 4：加入完整的处理异常方式\n服务器端：\n\n\n\nimport java.io.\\*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n\npublic class TestServer &#123;//服务器\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //1.创建套接字： 指定服务器的端口号\n        ServerSocket ss = null;\n        Socket s = null;\n        InputStream is = null;\n        ObjectInputStream ois = null;\n        OutputStream os = null;\n        DataOutputStream dos = null;\n        try &#123;\n            ss = new ServerSocket(8888);\n            //2.等着客户端发来的信息：\n            s = ss.accept();//阻塞方法:等待接收客户端的数据，什么时候接收到数据，什么时候程序继续向下执行。\n            //accept()返回值为一个Socket，这个Socket其实就是客户端的Socket\n            //接到这个Socket以后，客户端和服务器才真正产生了连接，才真正可以通信了\n            //3.感受到的操作流：\n            is = s.getInputStream();\n            ois = new ObjectInputStream(is);\n\n            //4.读取客户端发来的数据：\n            User user = (User)(ois.readObject());\n\n            //对对象进行验证：\n            boolean flag = false;\n            if(user.getName().equals(\"娜娜\")&amp;&amp;user.getPwd().equals(\"123123\"))&#123;\n                flag = true;\n            &#125;\n\n            //向客户端输出结果：---》操作流---》输出流\n            os = s.getOutputStream();\n            dos = new DataOutputStream(os);\n            dos.writeBoolean(flag);\n        &#125; catch (IOException \\| ClassNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            //5.关闭流+关闭网络资源：\n            try &#123;\n                if(dos!=null)&#123;\n                    dos.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(os!=null)&#123;\n                    os.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(ois!=null)&#123;\n                    ois.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(is!=null)&#123;\n                    is.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(s!=null)&#123;\n                    s.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(ss!=null)&#123;\n                    ss.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n\n\n\n    &#125;\n&#125;\n\n\n客户端：\n\n\n\nimport java.io.\\*;\nimport java.net.Socket;\nimport java.util.Scanner;\n\n\npublic class TestClient &#123;//客户端\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args)&#123;\n        //1.创建套接字：指定服务器的ip和端口号：\n        Socket s = null;\n        OutputStream os = null;\n        ObjectOutputStream oos = null;\n        InputStream is = null;\n        DataInputStream dis = null;\n        try &#123;\n            s = new Socket(\"192.168.199.217\",8888);\n            //录入用户的账号和密码：\n            Scanner sc = new Scanner(System.in);\n            System.out.println(\"请录入您的账号：\");\n            String name = sc.next();\n            System.out.println(\"请录入您的密码：\");\n            String pwd = sc.next();\n            //将账号和密码封装为一个User的对象：\n            User user = new User(name,pwd);\n            //2.对于程序员来说，向外发送数据 感受 --》利用输出流：\n            os = s.getOutputStream();\n            oos = new ObjectOutputStream(os);\n            oos.writeObject(user);\n            //接收服务器端的回话--》利用输入流：\n            is = s.getInputStream();\n            dis = new DataInputStream(is);\n            boolean b = dis.readBoolean();\n            if(b)&#123;\n                System.out.println(\"恭喜，登录成功\");\n            &#125;else&#123;\n                System.out.println(\"对不起，登录失败\");\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; finally&#123;\n            //3.关闭流 + 关闭网络资源：\n            try &#123;\n                if(dis!=null)&#123;\n                    dis.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(is!=null)&#123;\n                    is.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(oos!=null)&#123;\n                    oos.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(os!=null)&#123;\n                    os.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(s!=null)&#123;\n                    s.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n\n\n\n    &#125;\n&#125;\n\n\n# 功能分解 5：多线程接收用户请求\n遗留问题：服务器针对一个请求服务，之后服务器就关闭了（程序自然结束了）\n现在需要解决：服务器必须一直在监听 ，一直开着，等待客户端的请求\n在当前代码中，客户端不用动了\n\n更改服务器代码：\n\n\n\nimport java.io.\\*;\nimport java.net.Socket;\n\n\npublic class ServerThread extends Thread &#123;//线程：专门处理客户端的请求\n    InputStream is = null;\n    ObjectInputStream ois = null;\n    OutputStream os = null;\n    DataOutputStream dos = null;\n    Socket s = null;\n    public ServerThread(Socket s)&#123;\n        this.s = s;\n    &#125;\n    @Override\n    public void run() &#123;\n        try&#123;\n            //2.等着客户端发来的信息：\n\n            is = s.getInputStream();\n            ois = new ObjectInputStream(is);\n\n            //4.读取客户端发来的数据：\n            User user = (User)(ois.readObject());\n\n            //对对象进行验证：\n            boolean flag = false;\n            if(user.getName().equals(\"娜娜\")&amp;&amp;user.getPwd().equals(\"123123\"))&#123;\n                flag = true;\n            &#125;\n\n            //向客户端输出结果：---》操作流---》输出流\n            os = s.getOutputStream();\n            dos = new DataOutputStream(os);\n            dos.writeBoolean(flag);\n        &#125;catch (IOException \\| ClassNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;finally &#123;\n            try &#123;\n                if(dos!=null)&#123;\n                    dos.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(os!=null)&#123;\n                    os.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(ois!=null)&#123;\n                    ois.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            try &#123;\n                if(is!=null)&#123;\n                    is.close();\n                &#125;\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\nimport java.io.\\*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TestServer &#123;//服务器\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        System.out.println(\"服务器启动了\");\n        //1.创建套接字： 指定服务器的端口号\n        ServerSocket ss = null;\n        Socket s = null;\n        int count = 0;//定义一个计数器，用来计数 客户端的请求\n        try &#123;\n            ss = new ServerSocket(8888);\n            while(true)&#123;//加入死循环，服务器一直监听客户端是否发送数据\n                s = ss.accept();//阻塞方法:等待接收客户端的数据，什么时候接收到数据，什么时候程序继续向下执行。\n                //每次过来的客户端的请求 靠 线程处理：\n                new ServerThread(s).start();\n                count++;\n                //输入请求的客户端的信息：\n                System.out.println(\"当前是第\"+count+\"个用户访问我们的服务器,对应的用户是：\"+s.getInetAddress());\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\n# 基于 UDP 的网络编程\nTCP:\n客户端：Socket\n程序感受到的 使用流 ：输出流\n服务器端： ServerSocket —&gt;Socket 程序感受到的 使用流 ：输入流\n（客户端和服务器端地位不平等。）\nUDP:\n发送方：DatagramSocket 发送：数据包 DatagramPacket\n接收方：DatagramSocket 接收：数据包 DatagramPacket\n（发送方和接收方的地址是平等的。）\nUDP 案例： 完成网站的咨询聊天\n# 功能分解 1：单向通信\n发送方：\n\n\n\nimport java.io.IOException;\nimport java.net.\\*;\n\n\npublic class TestSend &#123;//发送方：\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        System.out.println(\"学生上线。。。\");\n        //1.准备套接字： 指定发送方的端口号\n        DatagramSocket ds = new DatagramSocket(8888);\n        //2.准备数据包\n        String str = \"你好\";\n        byte[] bytes = str.getBytes();\n        /\\*\n            需要四个参数：\n            1.指的是传送数据转为字节数组\n            2.字节数组的长度\n            3.封装接收方的ip\n            4.指定接收方的端口号\n            \\*/\n            DatagramPacket dp = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(\"localhost\"),9999);\n        //发送：\n        ds.send(dp);\n\n        //关闭资源\n        ds.close();\n    &#125;\n&#125;\n\n\n接收方：\n\n\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\n\n\npublic class TestReceive &#123;//接收方\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        System.out.println(\"老师上线了。。\");\n        //1.创建套接字：指定接收方的端口\n        DatagramSocket ds = new DatagramSocket(9999);\n        //2.有一个空的数据包，打算用来接收 对方传过来的数据包：\n        byte[] b = new byte[1024];\n        DatagramPacket dp = new DatagramPacket(b,b.length);\n        //3.接收对方的数据包，然后放入我们的dp数据包中填充\n        ds.receive(dp);//接收完以后 dp里面就填充好内容了\n\n        //4.取出数据：\n        byte[] data = dp.getData();\n        String s = new String(data,0,dp.getLength());//dp.getLength()数组包中的有效长度\n        System.out.println(\"学生对我说：\"+s);\n\n        //5.关闭资源：\n        ds.close();\n\n\n    &#125;\n&#125;\n\n\n# \n# 功能分解 2：双向通信\n发送方：\n\n\n\nimport java.io.IOException;\nimport java.net.\\*;\nimport java.util.Scanner;\n\npublic class TestSend &#123;//发送方：\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        System.out.println(\"学生上线。。。\");\n        //1.准备套接字： 指定发送方的端口号\n        DatagramSocket ds = new DatagramSocket(8888);\n        //2.准备数据包\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"学生：\");\n        String str = sc.next();\n        byte[] bytes = str.getBytes();\n        /\\*\n            需要四个参数：\n            1.指的是传送数据转为Z字节数组\n            2.字节数组的长度\n            3.封装接收方的ip\n            4.指定接收方的端口号\n            \\*/\n            DatagramPacket dp = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(\"localhost\"),9999);\n        //发送：\n        ds.send(dp);\n\n        //接收老师发送回来的信息：\n        byte[] b = new byte[1024];\n        DatagramPacket dp2 = new DatagramPacket(b,b.length);\n        ds.receive(dp2);//接收完以后 dp2里面就填充好内容了\n\n        //取出数据：\n        byte[] data = dp2.getData();\n        String s = new String(data,0,dp2.getLength());//dp.getLength()数组包中的有效长度\n        System.out.println(\"老师对我说：\"+s);\n\n        //关闭资源\n        ds.close();\n    &#125;\n&#125;\n\n\n接收方：\n\n\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.util.Scanner;\n\n\npublic class TestReceive &#123;//接收方\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws IOException &#123;\n        System.out.println(\"老师上线了。。\");\n        //1.创建套接字：指定接收方的端口\n        DatagramSocket ds = new DatagramSocket(9999);\n        //2.有一个空的数据包，打算用来接收 对方传过来的数据包：\n        byte[] b = new byte[1024];\n        DatagramPacket dp = new DatagramPacket(b,b.length);\n        //3.接收对方的数据包，然后放入我们的dp数据包中填充\n        ds.receive(dp);//接收完以后 dp里面就填充好内容了\n\n        //4.取出数据：\n        byte[] data = dp.getData();\n        String s = new String(data,0,dp.getLength());//dp.getLength()数组包中的有效长度\n        System.out.println(\"学生对我说：\"+s);\n\n        //老师进行回复：\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"老师：\");\n        String str = sc.next();\n        byte[] bytes = str.getBytes();\n        //封装数据，并且指定学生的ip和端口号\n        DatagramPacket dp2 = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(\"localhost\"),8888);\n        //发送：\n        ds.send(dp2);\n        //5.关闭资源：\n        ds.close();\n\n\n    &#125;\n&#125;\n\n\n# 功能分解 3：加入完整的处理异常方式\n发送方：\n\n\n\nimport java.io.IOException;\nimport java.net.\\*;\nimport java.util.Scanner;\n\n\npublic class TestSend &#123;//发送方：\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        System.out.println(\"学生上线。。。\");\n        //1.准备套接字： 指定发送方的端口号\n        DatagramSocket ds = null;\n        try &#123;\n            ds = new DatagramSocket(8888);\n            //2.准备数据包\n            Scanner sc = new Scanner(System.in);\n            System.out.print(\"学生：\");\n            String str = sc.next();\n            byte[] bytes = str.getBytes();\n            /\\*\n                需要四个参数：\n                1.指的是传送数据转为Z字节数组\n                2.字节数组的长度\n                3.封装接收方的ip\n                4.指定接收方的端口号\n                \\*/\n                DatagramPacket dp = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(\"localhost\"),9999);\n            //发送：\n            ds.send(dp);\n\n            //接收老师发送回来的信息：\n            byte[] b = new byte[1024];\n            DatagramPacket dp2 = new DatagramPacket(b,b.length);\n            ds.receive(dp2);//接收完以后 dp2里面就填充好内容了\n\n            //取出数据：\n            byte[] data = dp2.getData();\n            String s = new String(data,0,dp2.getLength());//dp.getLength()数组包中的有效长度\n            System.out.println(\"老师对我说：\"+s);\n        &#125; catch (SocketException e) &#123;\n            e.printStackTrace();\n        &#125; catch (UnknownHostException e) &#123;\n            e.printStackTrace();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            //关闭资源\n            ds.close();\n        &#125;\n\n\n\n    &#125;\n&#125;\n\n\n接收方：\n\n\n\nimport java.io.IOException;\nimport java.net.\\*;\nimport java.util.Scanner;\n\npublic class TestReceive &#123;//接收方\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args)&#123;\n        System.out.println(\"老师上线了。。\");\n        //1.创建套接字：指定接收方的端口\n        DatagramSocket ds = null;\n        try &#123;\n            ds = new DatagramSocket(9999);\n            //2.有一个空的数据包，打算用来接收 对方传过来的数据包：\n            byte[] b = new byte[1024];\n            DatagramPacket dp = new DatagramPacket(b,b.length);\n            //3.接收对方的数据包，然后放入我们的dp数据包中填充\n            ds.receive(dp);//接收完以后 dp里面就填充好内容了\n\n            //4.取出数据：\n            byte[] data = dp.getData();\n            String s = new String(data,0,dp.getLength());//dp.getLength()数组包中的有效长度\n            System.out.println(\"学生对我说：\"+s);\n\n            //老师进行回复：\n            Scanner sc = new Scanner(System.in);\n            System.out.print(\"老师：\");\n            String str = sc.next();\n            byte[] bytes = str.getBytes();\n            //封装数据，并且指定学生的ip和端口号\n            DatagramPacket dp2 = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(\"localhost\"),8888);\n            //发送：\n            ds.send(dp2);\n        &#125; catch (SocketException e) &#123;\n            e.printStackTrace();\n        &#125; catch (UnknownHostException e) &#123;\n            e.printStackTrace();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            //5.关闭资源：\n            ds.close();\n        &#125;\n\n\n\n\n    &#125;\n&#125;\n\n# 功能分解 4：正常通信\n发送方：\n\n\n\nimport java.io.IOException;\nimport java.net.\\*;\nimport java.util.Scanner;\n\npublic class TestSend &#123;//发送方：\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        System.out.println(\"学生上线。。。\");\n        //1.准备套接字： 指定发送方的端口号\n        DatagramSocket ds = null;\n        try &#123;\n            ds = new DatagramSocket(8888);\n            while(true)&#123;\n                //2.准备数据包\n                Scanner sc = new Scanner(System.in);\n                System.out.print(\"学生：\");\n                String str = sc.next();\n\n                byte[] bytes = str.getBytes();\n                /\\*\n                    需要四个参数：\n                    1.指的是传送数据转为Z字节数组\n                    2.字节数组的长度\n                    3.封装接收方的ip\n                    4.指定接收方的端口号\n                    \\*/\n                    DatagramPacket dp = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(\"localhost\"),9999);\n                //发送：\n                ds.send(dp);\n                if(str.equals(\"byebye\"))&#123;\n                    System.out.println(\"学生下线。。\");\n                    break;\n                &#125;\n                //接收老师发送回来的信息：\n                byte[] b = new byte[1024];\n                DatagramPacket dp2 = new DatagramPacket(b,b.length);\n                ds.receive(dp2);//接收完以后 dp2里面就填充好内容了\n\n                //取出数据：\n                byte[] data = dp2.getData();\n                String s = new String(data,0,dp2.getLength());//dp.getLength()数组包中的有效长度\n                System.out.println(\"老师对我说：\"+s);\n            &#125;\n        &#125; catch (SocketException e) &#123;\n            e.printStackTrace();\n        &#125; catch (UnknownHostException e) &#123;\n            e.printStackTrace();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            //关闭资源\n            ds.close();\n        &#125;\n\n\n\n    &#125;\n&#125;\n\n\n接收方：\n\n\n\nimport java.io.IOException;\nimport java.net.\\*;\nimport java.util.Scanner;\n\n\npublic class TestReceive &#123;//接收方\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args)&#123;\n        System.out.println(\"老师上线了。。\");\n        //1.创建套接字：指定接收方的端口\n        DatagramSocket ds = null;\n        try &#123;\n            ds = new DatagramSocket(9999);\n            while(true)&#123;\n                //2.有一个空的数据包，打算用来接收 对方传过来的数据包：\n                byte[] b = new byte[1024];\n                DatagramPacket dp = new DatagramPacket(b,b.length);\n                //3.接收对方的数据包，然后放入我们的dp数据包中填充\n                ds.receive(dp);//接收完以后 dp里面就填充好内容了\n\n                //4.取出数据：\n                byte[] data = dp.getData();\n                String s = new String(data,0,dp.getLength());//dp.getLength()数组包中的有效长度\n                System.out.println(\"学生对我说：\"+s);\n                if(s.equals(\"byebye\"))&#123;\n                    System.out.println(\"学生已经下线了，老师也下线。。。\");\n                    break;\n                &#125;\n\n                //老师进行回复：\n                Scanner sc = new Scanner(System.in);\n                System.out.print(\"老师：\");\n                String str = sc.next();\n                byte[] bytes = str.getBytes();\n                //封装数据，并且指定学生的ip和端口号\n                DatagramPacket dp2 = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(\"localhost\"),8888);\n                //发送：\n                ds.send(dp2);\n            &#125;\n        &#125; catch (SocketException e) &#123;\n            e.printStackTrace();\n        &#125; catch (UnknownHostException e) &#123;\n            e.printStackTrace();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            //5.关闭资源：\n            ds.close();\n        &#125;\n\n\n\n\n    &#125;\n\n","slug":"第14章_网络编程","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,网络编程","tags_index":"JavaSE","author_index":"雾都"},{"id":"64686085a348e977c3de22cd2f49f718","title":"第16章_反射","content":"# 通过案例体会反射的好处\n案例：美团外卖 —&gt; 付款 —》要么用微信支付 要么用支付宝支付\n//接口的制定方：美团外卖\npublic interface Mtwm &#123;\n    //在线支付功能：\n    void payOnline();\n&#125;\n\npublic class WeChat implements Mtwm&#123;\n    @Override\n    public void payOnline() &#123;\n        //具体实现微信支付的功能：\n        System.out.println(\"我已经点了外卖，正在使用微信支付\");\n    &#125;\n&#125;\npublic class AliPay implements Mtwm &#123;\n    @Override\n    public void payOnline() &#123;\n        //具体的支付宝支付：\n        System.out.println(\"我已经点了外卖，我正在使用支付宝进行支付\");\n    &#125;\n&#125;\npublic class BankCard implements Mtwm&#123;\n    @Override\n    public void payOnline() &#123;\n        System.out.println(\"我已经定了外卖，我正在用招商银行信用卡支付\");\n    &#125;\n&#125;\npublic class Test &#123;\npublic static void main(String[] args) &#123;\n//定义一个字符串，用来模拟前台的支付方式：\nString str = \"微信\";\nif(\"微信\".equals(str))&#123;//str.equals(\"微信\")---？避免空指针异常\n//微信支付：\n//new WeChat().payOnline();\npay(new WeChat());\n&#125;\n\nif(\"支付宝\".equals(str))&#123;\n//支付宝支付：\n//new AliPay().payOnline();\npay(new AliPay());\n&#125;\n\nif(\"招商银行\".equals(str))&#123;\npay(new BankCard());\n&#125;\n&#125;\n//微信支付\npublic static void pay(WeChat wc)&#123;\nwc.payOnline();\n&#125;\n//支付宝支付\npublic static void pay(AliPay ap)&#123;\nap.payOnline();\n&#125;\n\n//招商银行支付\npublic static void pay(BankCard bc)&#123;\nbc.payOnline();\n&#125;\n&#125;\n为了提高代码的扩展性 —》面向对象特性：多态：\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        //定义一个字符串，用来模拟前台的支付方式：\n        String str = \"微信\";\n        if(\"微信\".equals(str))&#123;//str.equals(\"微信\")---？避免空指针异常\n            //微信支付：\n            pay(new WeChat());\n        &#125;\n\n        if(\"支付宝\".equals(str))&#123;\n            //支付宝支付：\n            pay(new AliPay());\n        &#125;\n\n        if(\"招商银行\".equals(str))&#123;\n            pay(new BankCard());\n        &#125;\n    &#125;\n    //方法形参是接口，具体传入的是接口的实现类的对象---》多态的一种形式\n    public static void pay(Mtwm m)&#123;\n        m.payOnline();\n    &#125;\n&#125;\n\n\n\n多态确实可以提高代码的扩展性，但是：扩展性没有达到最好。\n怎么没有达到最好：上面的分支，还是需要手动的删除或者添加。\n解决办法：反射机制\n利用反射实现上述功能：\npublic class Demo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        //定义一个字符串，用来模拟前台的支付方式：\n        String str = \"com.zhaoss.test01.AliPay\"; //字符串：实际上：就是微信类的全限定路径\n\n        //下面的代码就是利用反射：\n        Class cls = Class.forName(str);//cls--\\>Class类具体的对象--》AliPay字节码信息\n        Object o = cls.newInstance();\n        Method method = cls.getMethod(\"payOnline\");\n        method.invoke(o);\n    &#125;\n&#125;\n# 通过概念再体会反射\nJAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，\n都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 java 语言的反射机制。\n在编译后产生字节码文件的时候，类加载器子系统通过二进制字节流，负责从文件系统加载 class 文件。\n在执行程序（java.exe）时候，将字节码文件读入 JVM 中 —&gt; 这个过程叫做类的加载。然后在内存中对应创建一个 java.lang.Class 对象–&gt; 这个对象会被放入字节码信息中，这个 Class 对象，就对应加载那个字节码信息，这个对象将被作为程序访问方法区中的这个类的各种数据的外部接口。\n所以：我们可以通过这个对象看到类的结构，这个对象就好像是一面镜子，透过镜子看到类的各种信息，我们形象的称之为反射\n这种 “看透” class 的能力（the ability of the program to examine itself）被称为 introspection（内省、内观、反省）。Reflection 和 introspection 是常被并提的两个术语。\n说明：在运行期间，如果我们要产生某个类的对象，Java 虚拟机 (JVM) 会检查该类型的 Class 对象是否已被加载。\n如果没有被加载，JVM 会根据类的名称找到.class 文件并加载它。一旦某个类型的 Class 对象已被加载到内存，就可以用它来产生该类型的所有对象。\n补充:\n动态语膏 vs 静态语言\n1、动态语言\n是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以\n被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运\n行时代码可以根据某些条件改变自身结构。\n主要动态语言: Object-C、 C#、JavaScript、 PHP、 Python、 Erlang 。\n2、静态语言\n与动态语言相对应的，运行时结构不可变的语言就是静态语言。如 Java、C、\nC++。\n所以 Java 不是动态语言，但 Java 可以称之为 “准动态语言”。即 Java 有一定的动\n态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。\nJava 的动态性让编程的时候更加灵活！\nClass 类的理解\n\n# 提供丰富的类\n//作为一个父类\npublic class Person &#123;\n    //属性\n    private int age;\n    public String name;\n\n    //方法\n    private void eat()&#123;\n        System.out.println(\"Person---eat\");\n    &#125;\n    public void sleep()&#123;\n        System.out.println(\"Person---sleep\");\n    &#125;\n&#125;\n//Student作为子类\npublic class Student extends Person &#123;\n    //属性：\n    private int sno;//学号\n    double height;//身高\n    protected double weight;//体重\n    public double score;//成绩\n\n    //方法：\n    public String showInfo()&#123;\n        return \"我是一名三好学生\";\n    &#125;\n    private void work()&#123;\n        System.out.println(\"我以后会找工作--》成为码农 程序员 程序猿 程序媛\");\n    &#125;\n\n    //构造器\n    public Student()&#123;\n        System.out.println(\"空参构造器\");\n    &#125;\n    private Student(int sno)&#123;\n        this.sno = sno;\n    &#125;\n    Student(int sno,double weight)&#123;\n        this.sno = sno;\n        this.weight = weight;\n    &#125;\n&#125;\n# 获取字节码信息的四种形式\n\npublic class Test &#123;\n    public static void main(String[] args) throws ClassNotFoundException &#123;\n        //案例：以Person的字节码信息为案例\n        //方式1：通过getClass()方法获取\n        Person p = new Person();\n        Class c1 = p.getClass();\n        System.out.println(c1);\n\n        //方式2：通过内置class属性：\n        Class c2 = Person.class;\n        System.out.println(c2);\n\n        System.out.println(c1==c2);\n\n        //注意：方式1和方式2 不常用\n\n        //方式3：--》用的最多：调用Class类提供的静态方法forName\n        Class c3 = Class.forName(\"com.zhaoss.test02.Person\");\n        //方式4：利用类的加载器(了解技能点)\n        ClassLoader loader = Test.class.getClassLoader();\n        Class c4 = loader.loadClass(\"com.zhaoss.test02.Person\");\n    &#125;\n&#125;\n\n# 可以作为 Class 类的实例的种类\nClass 类的具体的实例：\n（1）类：外部类，内部类\n（2）接口\n（3）注解\n（4）数组\n（5）基本数据类型\n（6）void\n验证：\n\n\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        /\\*\n            Class类的具体的实例：\n            （1）类：外部类，内部类\n            （2）接口\n            （3）注解\n            （4）数组\n            （5）基本数据类型\n            （6）void\n            \\*/\n            Class c1 = Person.class;\n        Class c2 = Comparable.class;\n        Class c3 = Override.class;\n\n        int[] arr1 = &#123;1,2,3&#125;;\n        Class c4 = arr1.getClass();\n        int[] arr2 = &#123;5,6,7&#125;;\n        Class c5 = arr2.getClass();\n        System.out.println(c4==c5);//结果：true .同一个维度，同一个元素类型,得到的字节码就是同一个\n\n        Class c6 = int.class;\n        Class c7 = void.class;\n    &#125;\n&#125;\n# 获取运行时类的完整结构\n# 补充完善上面提供的丰富的类\n\n// 作为一个父类\n\npublic class Person implements Serializable &#123;\n    //属性\n    private int age;\n    public String name;\n\n    //方法\n    private void eat()&#123;\n        System.out.println(\"Person---eat\");\n    &#125;\n    public void sleep()&#123;\n        System.out.println(\"Person---sleep\");\n    &#125;\n&#125;\n\n//Student作为子类\n@MyAnnotation(value=\"hello\")\npublic class Student extends Person implements MyInterface&#123;\n    //属性：\n    private int sno;//学号\n    double height;//身高\n    protected double weight;//体重\n    public double score;//成绩\n\n    //方法：\n    @MyAnnotation(value=\"himethod\")\n    public String showInfo()&#123;\n        return \"我是一名三好学生\";\n    &#125;\n    public String showInfo(int a,int b)&#123;\n        return \"重载方法====我是一名三好学生\";\n    &#125;\n    private void work()&#123;\n        System.out.println(\"我以后会找工作--》成为码农 程序员 程序猿 程序媛\");\n    &#125;\n    void happy()&#123;\n        System.out.println(\"做人最重要的就是开心每一天\");\n    &#125;\n    protected int getSno()&#123;\n        return sno;\n    &#125;\n\n    //构造器\n    public Student()&#123;\n        System.out.println(\"空参构造器\");\n    &#125;\n    private Student(int sno)&#123;\n        this.sno = sno;\n    &#125;\n    Student(int sno,double weight)&#123;\n        this.sno = sno;\n        this.weight = weight;\n    &#125;\n    protected Student(int sno,double height,double weight)&#123;\n        this.sno = sno;\n    &#125;\n\n    @Override\n    @MyAnnotation(value=\"hellomyMethod\")\n    public void myMethod() &#123;\n        System.out.println(\"我重写了myMethod方法。。\");\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"Student&#123;\" +\n            \"sno=\" + sno +\n            \", height=\" + height +\n            \", weight=\" + weight +\n            \", score=\" + score +\n            '&#125;';\n    &#125;\n&#125;\n/\\*\n    @Target:定义当前注解能够修饰程序中的哪些元素\n        @Retention:定义注解的声明周期\n            \\*/\n@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)\n            @Retention(RetentionPolicy.RUNTIME)\n            public @interface MyAnnotation &#123;\n            String value();//属性\n        &#125;\npublic interface MyInterface &#123;//自定义的接口\n//随便定义一个抽象方法：\nvoid myMethod();\n&#125;\n# 获取构造器和创建对象\npublic class Test01 &#123;\n    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;\n        //获取字节码信息：\n        Class cls = Student.class;\n\n        //通过字节码信息可以获取构造器：\n        //getConstructors只能获取当前运行时类的被public修饰的构造器\n        Constructor[] c1 = cls.getConstructors();\n        for(Constructor c:c1)&#123;\n            System.out.println(c);\n        &#125;\n\n        System.out.println(\"-------------------\");\n        //getDeclaredConstructors:获取运行时类的全部修饰符的构造器\n        Constructor[] c2 = cls.getDeclaredConstructors();\n        for(Constructor c:c2)&#123;\n            System.out.println(c);\n        &#125;\n        System.out.println(\"-------------------\");\n        //获取指定的构造器：\n        //得到空构造器\n        Constructor con1 = cls.getConstructor();\n        System.out.println(con1);\n\n        //得到两个参数的有参构造器：\n        Constructor con2 = cls.getConstructor(double.class, double.class);\n        System.out.println(con2);\n\n        //得到一个参数的有参构造器：并且是private修饰的\n        Constructor con3 = cls.getDeclaredConstructor(int.class);\n        System.out.println(con3);\n\n        //有了构造器以后我就可以创建对象：\n        Object o1 = con1.newInstance();\n        System.out.println(o1);\n\n        Object o2 = con2.newInstance(180.5, 170.6);\n        System.out.println(o2);\n    &#125;\n&#125;\n# 获取属性和对属性进行赋值\npublic class Test02 &#123;\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123;\n        //获取运行时类的字节码信息：\n        Class cls = Student.class;\n        //获取属性：\n        //getFields：获取运行时类和父类中被public修饰的属性\n        Field[] fields = cls.getFields();\n        for(Field f:fields)&#123;\n            System.out.println(f);\n        &#125;\n        System.out.println(\"---------------------\");\n        //getDeclaredFields：获取运行时类中的所有属性\n        Field[] declaredFields = cls.getDeclaredFields();\n        for(Field f:declaredFields)&#123;\n            System.out.println(f);\n        &#125;\n        System.out.println(\"---------------------\");\n        //获取指定的属性：\n        Field score = cls.getField(\"score\");\n        System.out.println(score);\n        Field sno = cls.getDeclaredField(\"sno\");\n        System.out.println(sno);\n\n        System.out.println(\"---------------------\");\n        //属性的具体结构：\n        //获取修饰符\n        /\\*int modifiers = sno.getModifiers();\n        System.out.println(modifiers);\n        System.out.println(Modifier.toString(modifiers));\\*/\n            System.out.println(Modifier.toString(sno.getModifiers()));\n        //获取属性的数据类型：\n        Class clazz = sno.getType();\n        System.out.println(clazz.getName());\n\n        //获取属性的名字：\n        String name = sno.getName();\n        System.out.println(name);\n        System.out.println(\"-------------------------------\");\n        //给属性赋值：(给属性设置值，必须要有对象)\n        Field sco = cls.getField(\"score\");\n        Object obj = cls.newInstance();\n        sco.set(obj,98);//给obj这个对象的score属性设置具体的值，这个值为98\n        System.out.println(obj);\n    &#125;\n&#125;\n# 获取方法和调用方法\npublic class Test03 &#123;\n    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123;\n        //获取字节码信息：\n        Class cls = Student.class;\n        //获取方法：\n        //getMethods:获取运行时类的方法还有所有父类中的方法（被public修饰）\n        Method[] methods = cls.getMethods();\n        for(Method m:methods)&#123;\n            System.out.println(m);\n        &#125;\n        System.out.println(\"-----------------------\");\n        //getDeclaredMethods:获取运行时类中的所有方法：\n        Method[] declaredMethods = cls.getDeclaredMethods();\n        for(Method m:declaredMethods)&#123;\n            System.out.println(m);\n        &#125;\n        System.out.println(\"-----------------------\");\n        //获取指定的方法：\n        Method showInfo1 = cls.getMethod(\"showInfo\");\n        System.out.println(showInfo1);\n        Method showInfo2 = cls.getMethod(\"showInfo\", int.class, int.class);\n        System.out.println(showInfo2);\n        Method work = cls.getDeclaredMethod(\"work\",int.class);\n        System.out.println(work);\n        System.out.println(\"-----------------------\");\n        //获取方法的具体结构：\n        /\\*\n            @注解\n            修饰符 返回值类型 方法名(参数列表) throws XXXXX&#123;&#125;\n        \\*/\n            //名字：\n            System.out.println(work.getName());\n        //修饰符：\n        int modifiers = work.getModifiers();\n        System.out.println(Modifier.toString(modifiers));\n        //返回值：\n        System.out.println(work.getReturnType());\n        //参数列表：\n        Class[] parameterTypes = work.getParameterTypes();\n        for(Class c:parameterTypes)&#123;\n            System.out.println(c);\n        &#125;\n\n        //获取注解：\n        Method myMethod = cls.getMethod(\"myMethod\");\n        Annotation[] annotations = myMethod.getAnnotations();\n        for(Annotation a:annotations)&#123;\n            System.out.println(a);\n        &#125;\n\n        //获取异常：\n        Class[] exceptionTypes = myMethod.getExceptionTypes();\n        for(Class c:exceptionTypes)&#123;\n            System.out.println(c);\n        &#125;\n\n\n        //调用方法：\n        Object o = cls.newInstance();\n        myMethod.invoke(o);//调用o对象的mymethod方法\n\n        System.out.println(showInfo2.invoke(o,12,45));;\n\n    &#125;\n&#125;\n# 获取类的接口，所在包，注解\n\n\npublic class Test04 &#123;\n    public static void main(String[] args) &#123;\n        //获取字节码信息：\n        Class cls = Student.class;\n        //获取运行时类的接口：\n        Class[] interfaces = cls.getInterfaces();\n        for(Class c:interfaces)&#123;\n            System.out.println(c);\n        &#125;\n\n        //得到父类的接口：\n        //先得到父类的字节码信息：\n        Class superclass = cls.getSuperclass();\n\n        //得到接口：\n        Class[] interfaces1 = superclass.getInterfaces();\n        for(Class c:interfaces1)&#123;\n            System.out.println(c);\n        &#125;\n\n        //获取运行时类所在的包：\n        Package aPackage = cls.getPackage();\n        System.out.println(aPackage);\n        System.out.println(aPackage.getName());\n\n        //获取运行类的注解：\n        Annotation[] annotations = cls.getAnnotations();\n        for(Annotation a:annotations)&#123;\n            System.out.println(a);\n        &#125;\n\n    &#125;\n&#125;\n# 关于反射的面试题\n【1】问题 1：创建 Person 的对象，以后用 new Person () 创建，还是用反射创建？\n【2】问题 2：反射是否破坏了面向对象的封装性？\n","slug":"第16章_反射","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,反射","tags_index":"JavaSE","author_index":"雾都"},{"id":"40562668ed2ca56f9747a37e5490ff93","title":"第2章_数据类型","content":"# 标识符\n【1】标识符：读音 biao zhi fu\n【2】什么是标识符？\n包，类，变量，方法… 等等，只要是起名字的地方，那个名字就是标识符\n【3】标识符定义规则：\n1. 四个可以（组成部分）：数字，字母，下划线_，美元符号 $\n注意：字母概念比较宽泛，指的是英文字母，汉字，日语，俄语…\n但是我们一般起名字尽量使用英文字母\n2. 两个不可以：不可以以数字开头，不可以使用 java 中的关键字\n3. 见名知意：增加可读性\n4. 大小写敏感： int a ; int A;\n5. 遵照驼峰命名：\n类名：首字母大写，其余遵循驼峰命名\n方法名，变量名：首字母小写，其余遵循驼峰命名\n包名：全部小写，不遵循驼峰命名\n6. 长度无限制，但是不建议太长 asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasfd\n# 关键字\n** 关键字：** 被 JAVA 语言赋予了特殊含义，用作专门用途的单词\n特点：JAVA 中所有关键字都为小写\n官网：https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html\n\n\n# 变量和常量\n举例：\n丽丽的年龄：去年 17 岁，今年 18 岁，明年 19 岁\n年龄：17–》18—》19 --》值不断变化\n年龄 —》变量\n常量： 17 ， 18 ， 19 ----》 常量中的字面常量\n# 字面常量\n常量分为两种：\n常量通常指的是一个固定的值，例如：1、2、3、’a’、’b’、true、false、”helloWorld” 等。\n在 Java 语言中，主要是利用关键字 final 来定义一个常量。 常量一旦被初始化后不能再更改其值。\n为了更好的区分和表述，一般将 1、2、3、’a’、’b’、true、false、”helloWorld” 等称为字面常量，而使用 final 修饰的 PI 等称为符号常量（字符常量）。\n字面常量的类型：\n\n注意：逻辑常量就两个值，一个是 true，一个是 false\n# 变量\n变量本质上就是代表一个” 可操作的存储空间”，空间位置是确定的，但是里面放置什么值不确定。我们可通过变量名来访问 “对应的存储空间”，从而操纵这个 “存储空间” 存储的值。Java 是一种强类型语言，每个变量都必须声明其数据类型。变量的数据类型决定了变量占据存储空间的大小。 比如，int a=3; 表示 a 变量的空间大小为 4 个字节。变量作为程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。变量在使用前必须对其声明，只有在变量声明以后，才能为其分配相应长度的存储空间。\n【1】变量声明格式：\ntype varName [=value][,varName [=value]…]; //[ ] 中的内容为可选项，即可有可无\n数据类型 变量名 [= 初始值] [, 变量名 [= 初始值]…];\n案例：\nint age = 19 , age2 = 90 ;\nint age,age2;\n【2】变量的声明：\n（1）如果你只定义一个变量，没有给变量进行赋值的话，那么其实这个变量相当于没有定义：\n\n（2）变量如果没有进行赋值的话，那么使用的时候会出错，告诉你：尚未初始化变量：\n\n【3】变量的赋值：\n\n我们自己定义的时候直接就可以用一句话定义：\nint age = 10;\n变量的值可以更改：\npublic class TestVar01&#123;\n    public static void main(String[] args)&#123;\n        //变量的声明（定义变量）（以年龄为案例讲解）\n        //java是一个强类型的语言，只要声明变量就必须定义类型：定义整数类型\n        int age ; //定义一个整数类型的变量，变量名字为age\n        //对变量进行赋值操作：\n        age = 10; //变量名字为age，具体的值为10\n        age = 12;\n        age = 20;\n        age = age + 4;\n        age = 9;\n        age = 9;\n        System.out.println(age);\n        \n    &#125;\n&#125;\n变量不可以重复定义：\n\n【4】变量的使用：\npublic class TestVar01&#123;\n    public static void main(String[] args)&#123;\n        //变量的声明（定义变量）（以年龄为案例讲解）\n        //java是一个强类型的语言，只要声明变量就必须定义类型：定义整数类型\n        int age ; //定义一个整数类型的变量，变量名字为age\n        //对变量进行赋值操作：\n        age = 10; //变量名字为age，具体的值为10\n        age = 12;\n        age = 20;\n        age = age + 4;\n        age = 9;\n        age = 9;\n        System.out.println(age);\n        System.out.println(age-2);\n        System.out.println(age+10);\n        int num = age + 66;\n        System.out.println(num);\n        \n    &#125;\n&#125;\n扩展：\npublic class TestVar02&#123;\n    public static void main(String[] args)&#123;\n        int a = 10;\n        int b = 20;\n        int c = a + b ;\n    &#125;\n&#125;\n现在对上述代码进行 “反编译过程”“反汇编过程”\n\n\n【5】变量的内存：\n\n【6】习题：\npublic class TestVar03&#123;\n    public static void main(String[] args)&#123;\n        int num1 = 10;\n        int num2 = 20;\n        num1 = num2;\n        num2 = num2 + 10;\n        num1 = num2 - 10;\n        num2 = num1;\n        System.out.println(\"num1=\"+num1);\n        System.out.println(\"num2=\"+num2);\n    &#125;\n&#125;\n内存分析：\n\n结果：\n\n【7】变量的作用域：\n作用域指的就是作用范围，变量在什么范围中有效\n作用范围就是离它最近的 {}\n备注：一会我们写的代码，不要去运行，会出错\n/\\*\n    局部变量：定义在方法中\n    成员变量：定义在类中，方法外\n    \\*/\npublic class TestVar04&#123;\n    int b = 20;\n    public static void main(String[] args)&#123;\n        System.out.println(a);//no\n        int a = 10;\n        System.out.println(a);//yes\n        System.out.println(b);//yes\n        &#123;\n            int c = 40;\n            System.out.println(c);//yes\n            int a = 50;//属于变量的重复定义\n        &#125;\n        System.out.println(c);//no\n    &#125;\n\n    public void eat()&#123;\n        System.out.println(b);//yes\n        System.out.println(a);//no\n        int a = 30;//不是变量的重复定义\n        System.out.println(a);//yes\n    &#125;\n&#125;\n# 基本数据类型\nJava 是一种强类型语言，每个变量都必须声明其数据类型。\nJava 的数据类型可分为两大类：基本数据类型（primitive data type）和引用数据类型（reference data type）。\n\nPS: 巧妙记忆：除了基本数据类型以外的所有类型都属于引用数据类型，本章重点：基本数据类型\n# 整数类型\n# 整数类型常量\n十进制整数，如：99, -500, 0\n八进制整数，要求以 0 开头，如：015\n十六进制数，要求 0x 或 0X 开头，如：0x15\n二进制：要求 0b 或者 0B 开头，如：0b11\n几进制：就是逢几进 1 的问题：\n平时实际生活中用的最多的是：十进制\n计算机用二进制最多\n\n扩展：进制转换问题\n【1】二进制转换为十进制：\n二进制： 1101\n1*2^3 + 1*2^2 + 0*2^1 + 1*2^0\n= 8 + 4 + 0 + 1\n= 13\n【2】十进制转换为二进制：\n十进制 13\n\n【3】八进制转换十进制：\n八进制： 16\n1*8^1 + 6*8^0\n= 8 + 6\n=14\n【4】十进制转换为八进制：\n十进制 14：\n\n【5】八进制转换为十六进制：\n把十进制当做一个中转站：\n八进制 —》十进制 —》十六进制\n实际上根本不用自己转换这么麻烦：我们可以直接用系统中提供给我们的计算器：\n\n# 整数类型变量\n整型数据类型：\n\n比如：byte 的右侧表数范围 127 怎么算出来的？\nbyte: 1 字节 = 8 位\n二进制：01111111\n1*2^6 + 1*2^5 + 1*2^4 + 1*2^3 + 1*2^2 + 1*2^1 + 1*2^0\n= 64 + 32 + 16 +8 +4 + 2 +1\n= 127\n代码：\npublic class TestVar05&#123;\n    public static void main(String[] args)&#123;\n        //定义整数类型的变量：\n        //给变量赋值的时候，值可以为不同进制的：\n        int num1 = 12 ;//默认情况下赋值就是十进制的情况\n        System.out.println(num1);\n        int num2 = 012;//前面加上0，这个值就是八进制的\n        System.out.println(num2);\n        int num3 = 0x12;//前面加上0x或者0X，这个值就是十六进制的\n        System.out.println(num3);\n        int num4 = 0b10;//前面加上0b或者0B,这个值就是二进制的\n        System.out.println(num4);\n        \n        //定义byte类型的变量：\n        byte b = 126;//定义了一个byte类型的变量，名字叫b，赋值为12\n        System.out.println(b);\n        //注意：超范围的赋值会报错。\n        short s = 30000;\n        System.out.println(s);\n        int i = 1234;\n        System.out.println(i);\n        //整数类型默认就是int类型的，所以12345678910是一个int类型的数，对于int类型来说，它超出范围了\n        //要想把一个数给long类型变量，那么后面加上L(推荐)或者l就可以了\n        long num5 = 12345678910L;\n        System.out.println(num5);\n        //注意：只有这个数超出int类型的范围了后面才需要加上L，否则无需加L也可以赋值给long类型：\n        long num6 = 12;\n        System.out.println(num6);\n        \n    &#125;\n&#125;\n# 浮点类型\n# 浮点类型常量\n（1）十进制数形式，例如:\n3.14 314.0 0.314\n（2）科学记数法形式，如\n314e2 314E2 (E 的大小写没有区分) 314E-2\ndouble f = 314e2; //314*10^2–&gt;31400.0\ndouble f2 = 314e-2; //314*10^(-2)–&gt;3.14\n# 浮点类型变量\nfloat 类型又被称作单精度类型，尾数可以精确到 7 位有效数字，在很多情况下，float 类型的精度很难满足需求。\n而 double 表示这种类型的数值精度约是 float 类型的两倍，又被称作双精度类型，绝大部分应用程序都采用 double 类型。\nfloat 类型的数值有一个后缀 F 或者 f ，没有后缀 F/f 的浮点数值默认为 double 类型。\n也可以在浮点数值后添加后缀 D 或者 d， 以明确其为 double 类型。\n\nPS：有效数字指的是从左开始第一个不为 0 的数到最后一个数\n代码：\npublic class TestVar06&#123;\n    public static void main(String[] args)&#123;\n        //浮点类型的常量有两种形式：\n        //十进制形式：\n        double num1 = 3.14;\n        System.out.println(num1);\n        //科学计数法形式：\n        double num2 = 314E-2;\n        System.out.println(num2);\n        \n        //浮点类型的变量：\n        //注意：浮点型默认是double类型的，要想将一个double类型的数赋给float类型，必须后面加上F或者f\n        float f1 = 3.14234567898623F;\n        System.out.println(f1);\n        //注意：double类型后面可以加D或者d，但是一般我们都省略不写\n        double d1 = 3.14234567898623D;\n        System.out.println(d1);\n        \n        //注意：我们最好不要进行浮点类型的比较：\n        float f2 = 0.3F;\n        double d2 = 0.3;\n        System.out.println(f2==d2);\n        /\\*\n            区别：\n            = 赋值运算： 将等号右侧的值赋给等号左侧\n            == 判断==左右两侧的值是否相等 ：结果要么相等 要么不相等\n            ==运算符的结果就是要么是true，要么是false\n            \\*/\n            \n    &#125;\n&#125;\n# 字符类型\n【1】Java 中使用单引号来表示字符常量，字符型在内存中占 2 个字节。\nchar 类型用来表示在 Unicode 编码表中的字符。Unicode 编码被设计用来处理各种语言的文字，它占 2 个字节，可允许有 65536 个字符。\n【2】转义字符：\n\n【3】ASCII 表：\n\n【4】Unicode 编码表：\nhttps://www.cnblogs.com/csguo/p/7401874.html\n代码 1：\npublic class TestVar07&#123;\n    public static void main(String[] args)&#123;\n        //定义字符类型的变量：\n        char ch1 = 'a';\n        System.out.println(ch1);\n        char ch2 = 'A';\n        System.out.println(ch2);\n        char ch3 = '4';\n        System.out.println(ch3);\n        char ch4 = '中';\n        System.out.println(ch4);\n        char ch5 = '?';\n        System.out.println(ch5);\n        //java中无论：字母，数字，符号，中文都是字符类型的常量，都占用2个字节。\n        char ch6 = ' ';\n        System.out.println(ch6);\n        //字符类型：单引号引起来的单个字符\n        System.out.println(\"--------------------------------\");\n        /\\*\n            转义字符：\n            \\\\将后面的普通字符转换为特殊含义\n            \\*/\n            char ch7 = '\\\\n';\n        System.out.println(\"aaa\"+ch7+\"bbb\");\n        \n        System.out.println(\"aaa\\\\nbbb\");// \\\\n 换行\n        \n        System.out.println(\"aaaaaaa\\\\tbbb\"); // \\\\t 制表符\n        \n        System.out.println(\"aaa\\\\bbbb\");//aabbb \\\\b 向前退一格\n        System.out.println(\"aaa\\\\rbbb\");//bbb \\\\r 将光标到本行开头 ：回车\n        \n        System.out.println(\"\\\\\"java\\\\\"\"); // \\\\\" 将双引号原样输出 \\\\' 将单引号原样输出 \\\\\\\\ 将\\\\原样输出\n    &#125;\n&#125;\n代码 2：\npublic class TestVar08&#123;\n    public static void main(String[] args)&#123;\n        char ch1 = 'A';\n        System.out.println(ch1);//A\n        System.out.println(ch1+90);//155\n        System.out.println(155-ch1);//90\n        //char类型我们看到的样子就是它本身的字面常量,但是底层在进行计算的时候，实际上是按照一个码进行计算的。\n        //这个码就是ASCII\n        //之前说char类型是按照Unicode码表进行存储的 (Unicode兼容了ASCII码，Unicode的前128位置ASCII)\n        \n        char ch2 = '中';\n        System.out.println(ch2);// 中\n        System.out.println(ch2+90);// 20103\n        System.out.println(20103-ch2);// 90\n        \n        //转换：\n        int num1 = (int)ch2;\n        System.out.println(num1);//20013\n        \n        char ch = (char)20013;\n        System.out.println(ch);\n        \n        int num2 = '中';\n        char ch5 = 20013;\n        System.out.println(ch5);\n        \n        //面试题：\n        char ch6 = '2'+2;\n        System.out.println(ch6);//'4'---\\>4\n    &#125;\n&#125;\n# 编码和字符集\n【1】什么是编码？\n\n【2】通过生活案例：\n\n【3】由权威机构形成的编码表才可以称之为：字符集\n\nASCII\n\n英文字符集\n用一个字节的 7 位表示\n\nIOS8859-1\n\n西欧字符集\n用一个字节的 8 位表示\n\nGB2312\n\n简体中文字符集\n最多使用两个字节编码\nPS：中文：2 个字节\nGB2312 兼容了 ASCII 中的字符：\n\nGBK\n\nGB2312 的升级，加入了繁体字\n最多使用两个字节编码\n疑问：\n\n首位如果是 0：一个字节代码代表一个字符\n首位如果是 1：那么一个字节不够，要加上后面的字节才能完整的表示一个字符。\n\nUnicode\n\n国际通用字符集，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。\n退出了 UTF 标准：\n三种编码方案： UTF-8，UTF-16,UTF-32\n以 UTF-8 为案例讲解：\n中文： 珊 —》Unicode ： 29642\n\n\n底层存储：\n\nUTF-8 标准最多可以用 6 个字节表示：\n\n以后我们用的最多的就是 UTF-8.\n# 解释乱码问题\n\n用记事本选择编码方法的时候一般要选择为 ANSI—》获取当前操作系统的编码格式：GBK\n# 布尔类型\nboolean 类型有两个常量值，true 和 false，在内存中占一位（不是一个字节），不可以使用 0 或非 0 的整数替代 true 和 false ，这点和 C 语言不同。 boolean 类型用来判断逻辑条件，一般用于程序流程控制 。\npublic class TestVar09&#123;\n    public static void main(String[] args)&#123;\n        //创建一个布尔类型的变量：\n        boolean flag1 = true;\n        System.out.println(flag1);\n        boolean flag2 = false;\n        System.out.println(flag2);\n        boolean flag3 = 5==9;\n        System.out.println(flag3);\n        boolean flag4 = 5\\&lt;9;\n        System.out.println(flag4);\n    &#125;\n&#125;\n# 基本数据类型的转换\n【1】什么是类型转换：\n在赋值运算或者算数运算的时候，要求数据类型一致，就要进行类型的转换。\n【2】类型转换的种类：\n自动转换，强制转换\n【3】内存演示：\n\n【4】代码：\npublic class TestVar10&#123;\n    public static void main(String[] args)&#123;\n        //类型转换的两种形式：\n        double d = 6;//int--\\>double 自动类型转换\n        System.out.println(d);\n        int i = (int)6.5;//double---\\>int 强制类型转换 （强转）\n        System.out.println(i);\n        \n        //在同一个表达式中，有多个数据类型的时候，应该如何处理：\n        //多种数据类型参与运算的时候，整数类型，浮点类型，字符类型都可以参与运算，唯独布尔类型不可以参与运算。\n        //double d2 = 12+1294L+8.5F+3.81+'a'+true;\n        double d2 = 12+1294L+8.5F+3.81+'a';\n        System.out.println(d2);\n        /\\*\n            类型级别：(从低到高的)\n            byte,short,char--\\>int---\\>long---\\>float---\\>double\n            级别用来做什么？当一个表达式中有多种数据类型的时候，要找出当前表达式中级别最高的那个类型，然后\n            其余的类型都转换为当前表达式中级别最高的类型进行计算。\n            double d2 = 12+1294L+8.5F+3.81+'a';\n        = 12.0+1294.0+8.5+3.81+97.0\n            \\*/\n            int i2 = (int)(12+1294L+8.5F+3.81+'a');\n        System.out.println(i2);\n        /\\*\n            在进行运算的时候：\n            左=右 : 直接赋值\n                左\\&lt;右 ：强转\n                左\\>右 ：直接自动转换\n                \\*/\n                \n                //以下情况属于特殊情形：对于byte，short，char类型来说，只要在他们的表数范围中，赋值的时候就不需要进行\n                //强转了直接赋值即可。\n                byte b = 12;\n        System.out.println(b);\n        byte b2 = (byte)270;\n        System.out.println(b2);\n        \n        \n        \n    &#125;\n&#125;\n# 练习：final，字符常量，Scanner 的使用\nimport java.util.Scanner;//形象理解：在java.util下将Scanner拿过来用\npublic class TestVar11&#123;\n    public static void main(String[] args)&#123;\n        //实现功能：求圆的周长和面积\n        //【1】提取变量：提取变量，就是为了一劳永逸，以后只要改变变量的值，下面只要用到这个变量的地方，取值也都发生变化了\n        //【2】一个变量被final修饰，这个变量就变成了一个常量，这个常量的值就不可变了\n        // 这个常量就是我们所说的 字符常量 ---》pi\n        // 约定俗成的规定：字符常量的名字全部大写\n        //【3】使用扫描器：Scanner的使用--》注意通过形象的理解去使用\n        final double PI = 3.14;\n        //拿来一个扫描器：\n        Scanner sc = new Scanner(System.in);\n        //给一个友好性的提示：\n        System.out.print(\"请录入一个半径：\");\n        //让扫描器扫描键盘录入的int类型的数据：\n        int r = sc.nextInt();\n        \n        //求周长：\n        double c = 2\\*PI\\*r;\n        System.out.println(\"周长为：\"+c);\n        \n        //求面积：\n        //PI = 9.29;报错：TestVar11.java:12: 错误: 无法为最终变量pi分配值\n        double s = PI\\*r\\*r;\n        System.out.println(\"面积为：\"+s);\n        \n        \n    &#125;\n&#125;\n# 练习：加深对 Scanner 的使用\n\nimport java.util.Scanner;\npublic class TestVar12&#123;\n    public static void main(String[] args)&#123;\n        //键盘录入学生的信息：年龄，身高，姓名，性别：\n        //键盘录入年龄：(接收int类型数据)\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"请录入年龄：\");\n        int age = sc.nextInt();\n        //键盘录入身高：（接收double类型数据）\n        System.out.print(\"请录入身高：\");\n        double height = sc.nextDouble();\n        //键盘录入姓名：(接收String类型数据--》字符串)\n        System.out.print(\"请录入姓名：\");\n        String name = sc.next();\n        //键盘录入性别：(接受char类型)\n        System.out.print(\"请录入性别：\");\n        String sexStr = sc.next();\n        char sex = sexStr.charAt(0);\n        //上面两句可以合为一句表示：char sex = sc.next().charAt(0);\n        System.out.println(\"该学生的信息为:姓名是：\"+name+\",年龄是：\"+age+\",身高为：\"+height+\",性别是：\"+sex);\n    &#125;\n&#125;\n","slug":"第2章_数据类型","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,数据类型","tags_index":"JavaSE","author_index":"雾都"},{"id":"9d15e79fc8681384f7574570adfb152d","title":"第15章Junit注解_枚举","content":"# 第 15 章_Junit_注解_枚举\n# Junit 单元测试\n# 引入\n【1】软件测试的目的：\n软件测试的目的是在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。\n【2】测试分类：\n（1）黑盒测试：\n软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试。\n（2）白盒测试：—》Junit 属于白盒测试。\n软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序的所有逻辑路径进行测试，通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试。\n\n# 没有 Junit 的情况下如何测试\n在没有使用 Junit 的时候，缺点：\n（1）测试一定走 main 方法，是程序的入口，main 方法的格式必须不能写错。\n（2）要是在同一个 main 方法中测试的话，那么不需要测试的东西必须注释掉。\n（3）测试逻辑如果分开的话，需要定义多个测试类，麻烦。\n（4）业务逻辑和测试代码，都混淆了。\n代码：\npublic class Calculator &#123;\n    //加法：\n    public int add(int a,int b)&#123;\n        return a+b;\n    &#125;\n\n    //减法：\n    public int sub(int a,int b)&#123;\n        return a-b;\n    &#125;\n&#125;\n\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //测试加法：\n        Calculator cal = new Calculator();\n        int result = cal.add(10, 20);\n        System.out.println(result);\n        //测试减法：\n        /\\* int result = cal.sub(30, 10);\n        System.out.println(result);\\*/\n    &#125;\n&#125;\npublic class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Calculator cal = new Calculator();\n        //测试减法：\n        int result = cal.sub(30, 10);\n        System.out.println(result);\n    &#125;\n&#125;\n\n\n# Junit 的使用\n【1】一般测试和业务做一个分离，分离为不同的包：\n建议起名：公司域名倒着写 + test\n以后测试类就单独放在这个包下\n【2】测试类的名字：****Test —&gt; 见名知意\n【3】测试方法的定义–》这个方法可以独立运行，不依托于 main 方法\n建议：\n名字：testAdd () testSub () 见名知意\n参数：无参\n返回值：void\n【4】测试方法定义完以后，不能直接就独立运行了，必须要在方法前加入一个注解： @Test\n【5】导入 Junit 的依赖的环境：\n\n【6】代码：\npublic class CalculatorTest &#123;\n    //测试add方法\n    @Test\n    public void testAdd()&#123;\n        System.out.println(\"测试add方法\");\n        Calculator cal = new Calculator();\n        int result = cal.add(10, 30);\n        System.out.println(result);\n    &#125;\n\n    //测试sub方法\n    @Test\n    public void testSub()&#123;\n        System.out.println(\"测试sub方法\");\n        Calculator cal = new Calculator();\n        int result = cal.sub(10, 30);\n        System.out.println(result);\n    &#125;\n&#125;\n\n\n【7】判定结果：\n绿色：正常结果\n红色：出现异常\n【8】即使出现绿色效果，也不意味着你的测试就通过了，因为代码中逻辑也可能出现问题，这种情况怎么解决呢？\n加入断言\npublic class CalculatorTest &#123;\n    //测试add方法\n    @Test\n    public void testAdd()&#123;\n        System.out.println(\"测试add方法\");\n        Calculator cal = new Calculator();\n        int result = cal.add(10, 30);\n        //System.out.println(result);--》程序的运行结果可以不关注\n        //加入断言：预测一下结果，判断一下我预测的结果和 实际的结果是否一致：\n        Assert.assertEquals(40,result);//第一个参数：预测结果 第二个参数：实际结果\n    &#125;\n\n    //测试sub方法\n    @Test\n    public void testSub()&#123;\n        System.out.println(\"测试sub方法\");\n        Calculator cal = new Calculator();\n        int result = cal.sub(10, 30);\n        System.out.println(result);\n    &#125;\n&#125;\n\n\n\n# @Before_@After\n@Before:\n某一个方法中，加入了 @Before 注解以后，那么这个方法中的功能会在测试方法执行前先执行\n一般会在 @Beforer 修饰的那个方法中加入：加入一些申请资源的代码：申请数据库资源，申请 IO 资源，申请网络资源。。。\n@After:\n某一个方法中，加入了 @After 注解以后，那么这个方法中的功能会在测试方法执行后先执行\n一般会在 @After 修饰的那个方法中加入：加入释放资源的代码：释放数据库资源，释放 IO 资源，释放网络资源。。。\n代码：\npublic class CalculatorTest &#123;\n    @Before\n    public void init()&#123;\n        System.out.println(\"方法执行开始了。。。\");\n    &#125;\n    @After\n    public void close()&#123;\n        System.out.println(\"方法执行结束了。。。\");\n    &#125;\n    //测试add方法\n    @Test\n    public void testAdd()&#123;\n        System.out.println(\"测试add方法\");\n        Calculator cal = new Calculator();\n        int result = cal.add(10, 30);\n        //System.out.println(result);--》程序的运行结果可以不关注\n        //加入断言：预测一下结果，判断一下我预测的结果和 实际的结果是否一致：\n        Assert.assertEquals(40,result);//第一个参数：预测结果 第二个参数：实际结果\n    &#125;\n\n    //测试sub方法\n    @Test\n    public void testSub()&#123;\n        System.out.println(\"测试sub方法\");\n        Calculator cal = new Calculator();\n        int result = cal.sub(10, 30);\n        System.out.println(result);\n    &#125;\n&#125;\n\n\n# 注解\n# 引入\n【1】历史：\nJDK5.0 新增 — 注解（Annotation）, 也叫元数据\n【2】什么是注解？\n注解其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用注解，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。\n使用注解时要在其前面增加 @符号，并把该注解当成一个修饰符使用。用于修饰它支持的程序元素。\n【3】注解的重要性：\nAnnotation 可以像修饰符一样被使用，可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明，这些信息被保存在 Annotation 的 &quot;name=value&quot; 对中。在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE/ArIdroid 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等。未来的开发模式都是基于注解的，JPA (java 的持久化 API) 是基于注解的，Spring2.5 以. E 都是基于注解的，Hibernate3.x 以后也是基于注解的，现在的 Struts2 有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说 ：框架 = 注解 + 反射 + 设计模式。\n# 注解的使用实例\n# Junit 的注解\n@Test\n@Before\n@After\n代码：\n\n\npublic class CalculatorTest &#123;\n@Before\npublic void init()&#123;\nSystem.out.println(\"方法执行开始了。。。\");\n&#125;\n@After\npublic void close()&#123;\nSystem.out.println(\"方法执行结束了。。。\");\n&#125;\n@Test\npublic void testAdd()&#123;\nSystem.out.println(\"测试add方法\");\nCalculator cal = new Calculator();\nint result = cal.add(10, 30);\nAssert.assertEquals(40,result);//第一个参数：预测结果 第二个参数：实际结果\n&#125;\n&#125;\n# 文档相关的注解\n说明注释允许你在程序中嵌入关于程序的信息。你可以使用 javadoc 工具软件来生成信息，并输出到 HTML 文件中。\n说明注释，使你更加方便的记录你的程序信息。\n文档注解我们一般使用在文档注释中，配合 javadoc 工具\njavadoc 工具软件识别以下标签：\n\n其中注意：\nØ @param @return 和 @exception 这三个标记都是只用于方法的。\nØ @param 的格式要求: @param 形参名 形参类型 形参说明\nØ @return 的格式要求: @return 返回值类型返回值说明，如果方法的返回值类型是 void 就不能写\nØ @exception 的格式要求: @exception 异常类型异常说明\nØ @param 和 @exception 可以并列多个\n代码：\npublic class Person &#123;\n    /**\n * 下面是eat方法，实现了XXX功能。\n * @param num1 就餐人数\n * @param num2 点了几个菜\n */\n    public void eat(int num1,int num2)&#123;\n\n    &#125;\n\n    /\\*\\*\n        \\* @param age 年龄\n        \\* @return int\n        \\* @exception RuntimeException 当年龄过大的时候\n        \\* @exception IndexOutOfBoundsException 当年龄过小的时候\n        \\* @see Student\n        \\*/\n        public int sleep(int age)&#123;\n        new Student();\n        if(age\\>100)&#123;\n            throw new RuntimeException();\n        &#125;\n        if(age\\&lt;0)&#123;\n            throw new IndexOutOfBoundsException();\n        &#125;\n        return 10;\n    &#125;\n&#125;\n\nIDEA 中的 javadoc 使用：\n\n防止乱码：\n\n\n# JDK 内置的 3 个注解\n@Override: 限定重写父类方法，该注解只能用于方法\n\n| ------------------------------------------------------------ |\n\n@Deprecated: 用于表示所修饰的元素 (类，方法，构造器，属性等) 已过时。通常是因为所修饰的结构危险或存在更好的选择\npublic class Student extends Person &#123;\n    /\\*\n        @Override的作用：限定重写的方法，只要重写方法有问题，就有错误提示。\n        \\*/\n        @Override\n        public void eat()&#123;\n        System.out.println(\"子类eat..\");\n    &#125;\n    /\\*\n        在方法前加入@Deprecated，这个方法就会变成一个废弃方法/过期方法/过时方法\n        \\*/\n\n        @Deprecated\n        public void study()&#123;\n        System.out.println(\"学习。。\");\n    &#125;\n&#125;\n\n\n@SuppressWarnings: 抑制编译器警告\npublic class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        @SuppressWarnings(\"unused\")\n        int age = 10;\n\n        int num = 10;\n        System.out.println(num);\n        @SuppressWarnings(&#123;\"unused\",\"rwatypes\"&#125;)\n        ArrayList al = new ArrayList();\n    &#125;\n&#125;\n\n# 实现替代配置文件功能的注解\n在 servlet3.0 之前的配置：\n\n\n\n&lt;?xml version=“1.0” encoding=“UTF-8”?&gt;  &lt;web-app xmlns=“http://xmlns.jcp.org/xml/ns/javaee”   xmlns:xsi=“http://www.w3.org/2001/XMLSchema-instance”   xsi:schemaLocation=“http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd”   version=“4.0”&gt;   &lt;!–配置 Servlet–&gt;   &lt;!–配置 Servlet 的信息–&gt;   &lt;servlet&gt;   &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;   &lt;servlet-class&gt;com.bjsxt.servlet.HelloServlet&lt;/servlet-class&gt;   &lt;/servlet&gt;   &lt;!–配置 Servlet 的映射路径–&gt;   &lt;servlet-mapping&gt;   &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;   &lt;!–http://localhost:8080/01-hello-servlet/hello--&gt;   &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;   &lt;/servlet-mapping&gt;  &lt;/web-app&gt;\n\n\n\n在 servlet3.0 之后使用注解：替代配置文件。\n\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n# 自定义注解\n【1】自定义注解使用很少，一般情况下都是用现成的注解。\n【2】如何自定义注解：\n\n\n发现定义的注解的声明使用的关键字：[@interface](file:///D:\\ 下载 @interface)，跟接口没有一点关系。\n【3】注解的内部：\n以 [@SuppressWarnings](file:///D:\\ 下载 @SuppressWarnings) 为例，发现内部：\n\n这 value 是属性还是方法？\n答案：看上去是无参数方法，实际上理解为一个成员变量，一个属性\n无参数方法名字–》成员变量的名字\n无参数方法的返回值–》成员变量的类型\n这个参数叫 配置参数\n无参数方法的类型：基本数据类型（八种），String，枚举，注解类型，还可以是以上类型对应的数组。\nPS：注意：如果只有一个成员变量的话，名字尽量叫 value。\n【4】使用注解：\n（1）使用注解的话，如果你定义了配置参数，就必须给配置参数进行赋值操作：\n@MyAnnotation(value=&#123;\"abc\",\"def\",\"hij\"&#125;)\npublic class Person &#123;\n &#125;\n\n（2）如果只有一个参数，并且这个参数的名字为 value 的话，那么 value = 可以省略不写。\n@MyAnnotation(&#123;\"abc\",\"def\",\"hij\"&#125;)\npublic class Person &#123;\n &#125;\n\n（3）如果你给配置参数设置默认的值了，那么使用的时候可以无需传值：\n\npublic @interface MyAnnotation2 {\nString value() default “abc”;\n}\n\n使用：\n@MyAnnotation2\n@MyAnnotation(&#123;\"abc\",\"def\",\"hij\"&#125;)\npublic class Person &#123;\n    \n &#125;\n\n（4）一个注解的内部是可以不定义配置参数的：\npublic @interface MyAnnotation3 &#123;\n&#125;\n内部没有定义配置参数的注解–》可以叫做标记\n\n内部定义配置参数的注解–》元数据\n\n【5】注解的使用：\n现在只学习注解的大致技能点，具体怎么应用 后面慢慢学习。\n# 元注解\n元注解是用于修饰其它注解的注解。\n举例：\n\nJDK5.0 提供了四种元注解：Retention, Target, Documented, Inherited\n# Retention\n@Retention: 用于修饰注解，用于指定修饰的那个注解的生命周期，@Rentention 包含一个 RetentionPolicy 枚举类型的成员变量，使用 @Rentention 时必须为该 value 成员变量指定值:\n➢RetentionPolicy.SOURCE: 在源文件中有效 (即源文件保留), 编译器直接丢弃这种策略的注释，在.class 文件中不会保留注解信息\n案例：\n\n\n反编译查看字节码文件：发现字节码文件中没有 MyAnnotation 这个注解：\n\n➢RetentionPolicy.CLASS: 在 class 文件中有效 (即 class 保留)，保留在.class 文件中，但是当运行 Java 程序时，他就不会继续加载了，不会保留在内存中，JVM 不会保留注解。如果注解没有加 Retention 元注解，那么相当于默认的注解就是这种状态。\n案例：\n\n\n反编译看字节码文件，字节码文件中带有 MyAnnotation 注解：\n\n➢RetentionPolicy.RUNTIME: 在运行时有效 (即运行时保留), 当运行 Java 程序时，JVM 会保留注释，加载在内存中了，那么程序可以通过反射获取该注释。\n# Target\n用于修饰注解的注解，用于指定被修饰的注解能用于修饰哪些程序元素。@Target 也包含一个名为 value 的成员变量。\n案例：\n@Target(&#123;TYPE,CONSTRUCTOR,METHOD&#125;)\npublic @interface MyAnnotation4 &#123;\n&#125;\n使用：\n\n# Documented（很少）\n用于指定被该元注解修饰的注解类将被 javadoc 工具提取成文档。默认情况下，javadoc 是 不包括注解的，但是加上了这个注解生成的文档中就会带着注解了\n案例：\n如果：Documented 注解修饰了 Deprecated 注解，\n\n那么 Deprecated 注解就会在 javadoc 提取的时候，提取到 API 中：\n\n# Inherited（极少）\n被它修饰的 Annotation 将具有继承性。如果某个类使用了被\n@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。\n案例：\n注解：如果 MyAnno 注解使用了 @Inherited 之后，就具备了继承性，那么相当于子类 Student 也使用了这个 MyAnno\n\n父类：\n\n子类：\n\n# 枚举\n# 引入\n【1】数学：枚举法：\n1&lt;x&lt;4\n2&lt;y&lt;5\n求 x+y=6\n枚举法：一枚一枚的列举出来。前提：有限，确定\n【2】在 java 中，类的对象是有限个，确定的。这个类我们可以定义为枚举类。\n举例：\n星期：一二三四五六日\n性别：男女\n季节：春夏秋冬\n【3】自定义枚举类：（JDK1.5 之前自定义枚举类）\n\n\n/**\n* @author : msb-zhaoss\n* 定义枚举类：季节\n*/\n\npublic class Season &#123;\n    //属性：\n    private final String seasonName ;//季节名字\n    private final String seasonDesc ;//季节描述\n    //利用构造器对属性进行赋值操作：\n    //构造器私有化，外界不能调用这个构造器，只能Season内部自己调用\n    private Season(String seasonName,String seasonDesc)&#123;\n        this.seasonName = seasonName;\n        this.seasonDesc = seasonDesc;\n    &#125;\n\n    //提供枚举类的有限的 确定的对象：\n    public static final Season SPRING = new Season(\"春天\",\"春暖花开\");\n    public static final Season SUMMER = new Season(\"夏天\",\"烈日炎炎\");\n    public static final Season AUTUMN = new Season(\"秋天\",\"硕果累累\");\n    public static final Season WINTER = new Season(\"冬天\",\"冰天雪地\");\n\n    //额外因素：\n\n    public String getSeasonName() &#123;\n        return seasonName;\n    &#125;\n\n    public String getSeasonDesc() &#123;\n        return seasonDesc;\n    &#125;\n\n    //toString();\n\n    @Override\n    public String toString() &#123;\n        return \"Season&#123;\" +\n            \"seasonName='\" + seasonName + '\\\\'' +\n            \", seasonDesc='\" + seasonDesc + '\\\\'' +\n            '&#125;';\n    &#125;\n&#125;\n\n\n测试类：\npublic class TestSeason &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Season summer = Season.SUMMER;\n        System.out.println(summer/\\*.toString()\\*/);\n        System.out.println(summer.getSeasonName());\n    &#125;\n&#125;\n\n# JDK1_5 之后使用 enum 关键字来创建枚举类\nJDK1.5 以后使用 enum 关键字创建枚举类：\n\n变为下面的枚举类：\npublic enum Season &#123;\n    //提供枚举类的有限的 确定的对象：---\\>enum枚举类要求对象（常量）必须放在最开始位置\n    //多个对象之间用，进行连接，最后一个对象后面用;结束\n    SPRING(\"春天\",\"春暖花开\"),\n    SUMMER(\"夏天\",\"烈日炎炎\"),\n    AUTUMN(\"秋天\",\"硕果累累\"),\n    WINTER(\"冬天\",\"冰天雪地\");\n    //属性：\n    private final String seasonName ;//季节名字\n    private final String seasonDesc ;//季节描述\n    //利用构造器对属性进行赋值操作：\n    //构造器私有化，外界不能调用这个构造器，只能Season内部自己调用\n    private Season(String seasonName, String seasonDesc)&#123;\n        this.seasonName = seasonName;\n        this.seasonDesc = seasonDesc;\n    &#125;\n\n\n\n    //额外因素：\n\n    public String getSeasonName() &#123;\n        return seasonName;\n    &#125;\n\n    public String getSeasonDesc() &#123;\n        return seasonDesc;\n    &#125;\n\n    //toString();\n\n    @Override\n    public String toString() &#123;\n        return \"Season&#123;\" +\n            \"seasonName='\" + seasonName + '\\\\'' +\n            \", seasonDesc='\" + seasonDesc + '\\\\'' +\n            '&#125;';\n    &#125;\n&#125;\n\n使用枚举类：\npublic class TestSeason &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Season winter = Season.WINTER;\n        System.out.println(winter);\n        //enum关键字对应的枚举类的上层父类是 ：java.lang.Enum\n        //但是我们自定义的枚举类的上层父类：Object\n        System.out.println(Season.class.getSuperclass().getName());//java.lang.Enum\n    &#125;\n&#125;\n\n\n在源码中经常看到别人定义的枚举类形态：\npublic enum Season &#123;\n    SPRING,\n    SUMMER,\n    AUTUMN,\n    WINTER;\n&#125;\n为什么这么简单：因为这个枚举类底层没有属性，属性，构造器，toString，get 方法都删掉不写了，然后案例来说应该\n写为：SPRING () 现在连（）可以省略 就变成 SPRING\n看到的形态就剩：常量名（对象名）\n案例：Thread 中的枚举类：State\n\npublic enum State &#123;\n    /\\*\\*\n        \\* Thread state for a thread which has not yet started.\n            \\*/\n            NEW,\n\n    /\\*\\*\n        \\* Thread state for a runnable thread. A thread in the runnable\n            \\* state is executing in the Java virtual machine but it may\n            \\* be waiting for other resources from the operating system\n                \\* such as processor.\n                \\*/\n                RUNNABLE,\n\n    /\\*\\*\n        \\* Thread state for a thread blocked waiting for a monitor lock.\n            \\* A thread in the blocked state is waiting for a monitor lock\n                \\* to enter a synchronized block/method or\n                \\* reenter a synchronized block/method after calling\n                \\* &#123;@link Object\\#wait() Object.wait&#125;.\n                \\*/\n                BLOCKED,\n\n    /\\*\\*\n        \\* Thread state for a waiting thread.\n            \\* A thread is in the waiting state due to calling one of the\n            \\* following methods:\n    \\* \\&lt;ul\\>\n        \\* \\&lt;li\\>&#123;@link Object\\#wait() Object.wait&#125; with no timeout\\&lt;/li\\>\n        \\* \\&lt;li\\>&#123;@link \\#join() Thread.join&#125; with no timeout\\&lt;/li\\>\n        \\* \\&lt;li\\>&#123;@link LockSupport\\#park() LockSupport.park&#125;\\&lt;/li\\>\n        \\* \\&lt;/ul\\>\n        \\*\n        \\* \\&lt;p\\>A thread in the waiting state is waiting for another thread to\n            \\* perform a particular action.\n            \\*\n            \\* For example, a thread that has called \\&lt;tt\\>Object.wait()\\&lt;/tt\\>\n            \\* on an object is waiting for another thread to call\n                \\* \\&lt;tt\\>Object.notify()\\&lt;/tt\\> or \\&lt;tt\\>Object.notifyAll()\\&lt;/tt\\> on\n                \\* that object. A thread that has called \\&lt;tt\\>Thread.join()\\&lt;/tt\\>\n                \\* is waiting for a specified thread to terminate.\n                    \\*/\n                    WAITING,\n\n    /\\*\\*\n        \\* Thread state for a waiting thread with a specified waiting time.\n            \\* A thread is in the timed waiting state due to calling one of\n            \\* the following methods with a specified positive waiting time:\n    \\* \\&lt;ul\\>\n        \\* \\&lt;li\\>&#123;@link \\#sleep Thread.sleep&#125;\\&lt;/li\\>\n        \\* \\&lt;li\\>&#123;@link Object\\#wait(long) Object.wait&#125; with timeout\\&lt;/li\\>\n        \\* \\&lt;li\\>&#123;@link \\#join(long) Thread.join&#125; with timeout\\&lt;/li\\>\n        \\* \\&lt;li\\>&#123;@link LockSupport\\#parkNanos LockSupport.parkNanos&#125;\\&lt;/li\\>\n        \\* \\&lt;li\\>&#123;@link LockSupport\\#parkUntil LockSupport.parkUntil&#125;\\&lt;/li\\>\n        \\* \\&lt;/ul\\>\n        \\*/\n        TIMED_WAITING,\n\n    /\\*\\*\n        \\* Thread state for a terminated thread.\n            \\* The thread has completed execution.\n            \\*/\n            TERMINATED;\n&#125;\n# Enum 类的常用方法\npublic class TestSeason &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //用enum关键字创建的Season枚举类上面的父类是：java.lang.Enum,常用方法子类Season可以直接拿过来使用：\n        //toString();---\\>获取对象的名字\n        Season autumn = Season.AUTUMN;\n        System.out.println(autumn/\\*.toString()\\*/);//AUTUMN\n\n        System.out.println(\"--------------------\");\n        //values:返回枚举类对象的数组\n        Season[] values = Season.values();\n        for(Season s:values)&#123;\n            System.out.println(s/\\*.toString()\\*/);\n        &#125;\n\n        System.out.println(\"--------------------\");\n        //valueOf：通过对象名字获取这个枚举对象\n        //注意：对象的名字必须传正确，否则抛出异常\n        Season autumn1 = Season.valueOf(\"AUTUMN\");\n        System.out.println(autumn1);\n    &#125;\n&#125;\n\n\n# 枚举类实现接口\n定义一个接口：\npublic interface TestInterface &#123;\n    void show();\n&#125;\n枚举类实现接口，并且重写 show 方法：\npublic enum Season implements TestInterface &#123;\n    SPRING,\n    SUMMER,\n    AUTUMN,\n    WINTER;\n\n    @Override\n    public void show() &#123;\n        System.out.println(\"这是Season....\");\n    &#125;\n&#125;\n测试类：\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Season autumn = Season.AUTUMN;\n        autumn.show();\n        Season summer = Season.SUMMER;\n        summer.show();\n    &#125;\n&#125;\n\n上面发现所有的枚举对象，调用这个 show 方法的时候走的都是同一个方法，结果都一样：\n\n但是现在我想要：不同的对象 调用的 show 方法也不同：\npublic enum Season implements TestInterface &#123;\n    SPRING&#123;\n        @Override\n        public void show() &#123;\n            System.out.println(\"这是春天。。。\");\n        &#125;\n    &#125;,\n    SUMMER&#123;\n        @Override\n        public void show() &#123;\n            System.out.println(\"这是夏天。。\");\n        &#125;\n    &#125;,\n    AUTUMN&#123;\n        @Override\n        public void show() &#123;\n            System.out.println(\"这是秋天\");\n        &#125;\n    &#125;,\n    WINTER&#123;\n        @Override\n        public void show() &#123;\n            System.out.println(\"这是冬天\");\n        &#125;\n    &#125;;\n\n    /\\*@Override\n        public void show() &#123;\n        System.out.println(\"这是Season....\");\n    &#125;\\*/\n&#125;\n\n\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Season autumn = Season.AUTUMN;\n        autumn.show();\n        Season summer = Season.SUMMER;\n        summer.show();\n    &#125;\n&#125;\n\n\n# 实际应用\npublic class Person &#123;\n    //属性：\n    private int age;\n    private String name;\n    private Gender sex;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public Gender getSex() &#123;\n        return sex;\n    &#125;\n\n    public void setSex(Gender sex) &#123;\n        this.sex = sex;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"Person&#123;\" +\n            \"age=\" + age +\n            \", name='\" + name + '\\\\'' +\n            \", sex='\" + sex + '\\\\'' +\n            '&#125;';\n    &#125;\n&#125;\n\npublic enum Gender &#123;\n    男,\n    女;\n&#125;\n\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Person p = new Person();\n        p.setAge(19);\n        p.setName(\"lili\");\n        p.setSex(Gender.男);//传入枚举类Gender的对象：--\\>在入口处对参数进行了限制\n        System.out.println(p);\n    &#125;\n&#125;\n\n\n还可以通过枚举结合 switch 处理：\npublic class Test02 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Gender sex = Gender.男;\n        //switch后面的（）中可以传入枚举类型\n        //switch后面的（）:int,short,byte,char,String ,枚举\n        switch (sex)&#123;\n            case 女:\n                System.out.println(\"是个女孩\");\n                break;\n            case 男:\n                System.out.println(\"是个男孩\");\n                break;\n        &#125;\n    &#125;\n&#125;\n\n","slug":"第15章Junit注解_枚举","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,Junit注解_枚举","tags_index":"JavaSE","author_index":"雾都"},{"id":"9a615c2cbfa580b4a365b136d5081085","title":"第1章初识JAVA","content":"# 计算机语言的发展历史\n计算机编程语言的发展，是随着计算机本身硬件发展而发展的。硬件速度越快、体积越小、成本越低，应用到人类社会的场景就会越多，那么所需要的算法就会越复杂，也就要求计算机编程语言越高级。最初重达几十吨但一秒只能运算 5000 次的 ENIAC (世界上第一台计算机)，只能做非常小的应用，比如：某些情况的弹道计算。现在任何一个人的手机运算能力都可以秒杀那个年代地球上所有计算机运算能力的总和。计算机编程语言的发展历经了从低级到高级发展。发展的核心思想就是 “让人更容易编程”。越容易使用的语言，就有越多人使用；越多人使用，就有越多协作；越多协作，就可以创造越复杂的物体；计算机语言经历了三代：第一代是机器语言，第二代是汇编语言，第三代是高级语言。\n\n【1】第一代：机器语言（相当于人类的原始阶段）\n机器语言是机器指令的集合，机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字。计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，从而进行运算。上面所说的计算机，指的是可以执行机器指令，进行运算的机器。这是早期计算机的概念。早期的程序设计均使用机器语言。程序员们将用 0、1 数字编程的程序代码打在纸袋或卡片上，1 打孔，0 不打孔，再将程序通过纸带机或卡片机输入计算机，从而进行运算。\n应用 8086CPU 完成运算 s=768+12288-1280，机器码如下:\n\n假如将程序错写成以下的错误，请你找出错误:\n\n书写和阅读机器码程序不是一件简单的工作，要记住所有抽象的二进制码。上面只是一个非常简单的小程序，就暴露出机器码的晦涩难懂和不易查错。写如此小的一个程序尚且如此，实际上一个有用的程序至少要有几十行的机器码。那么，情况将会怎么样呢？\n在显示器输出 “welcome to masm”，机器码如下：\n看到这样的程序，你有什么感想？如果程序里有一个 “1” 被误写成为 “0”，又如何去查找错误呢？\n【2】第二代：汇编语言（相当于人类的手工业阶段）\n为了编程的方便，以及解决更加复杂的问题。程序员开始改进机器语言，使用英文缩写的助记符来表示基本的计算机操作。这些助记符构成了汇编语言的基础。如下是一些常见的汇编语言助记符 (单词) 比如：mov，add，sub 之类，这样人更容易使用了。识别几百、几千个单词，感觉要比几百几千个数字，美妙多了。汇编语言相当于人类的手工业社会，需要技术极其娴熟的工匠，但是开发效率也非常低。汇编语言虽然能编写高效率的程序，但是学习和使用都不是易事，并且很难调试。另一个复杂的问题，汇编语言以及早期的计算机语言（Basic、Fortran 等）没有考虑结构化设计原则，而是使用 goto 语句来作为程序流程控制的主要方法。这样做的后果是：一大堆混乱的调转语句使得程序几乎不可能被读懂。对于那个时代的程序员，能读懂上个月自己写的代码都成为一种挑战。 汇编语言仍然应用于工业电子编程领域、软件的加密解密、计算机病毒分析等。\n下面以 Masm 软件为例，编写一个简单的 “hello world!” 程序。\n\n【3】第三代：高级语言（相当于人类的工业阶段）\n对于简单的任务，汇编语言可以胜任。但是随着计算机的发展，渗透到了工作生活的更多的方面，一些复杂的任务出现了，汇编语言就显得力不从心（应该说是程序员使用汇编语言解决复杂问题出现了瓶颈）。于是，出现了高级语言。像我们熟知的 C、C++、Java 等等都是高级语言。\n高级语言允许程序员使用接近日常英语的指令来编写程序。例如下图所示:\n\n# JAVA 简史\n【1】SUN 公司\n美国 SUN (Stanford University Network) 公司在中国大陆的正式中文名为 “太阳计算机系统（中国）有限公司” ，在台湾中文名为 “升 阳电脑公司”。\n【2】Java 为什么被发明\nGreen 项目。\n应用环境：像电视盒这样的消费类电子产品\n要求： 语言本身是中立的，也就是跨平台\n1996 年 Java 第一次发布就引起了人们的极大兴趣。关注 Java 的人士不仅限于计算机出版界， 还有诸如《纽约时报》《华盛顿邮报》《商业周刊》这样的主流媒体。Java 是第一种也是唯一种在 National Public Radio 上占用了 10 分钟时间来进行介绍的程序设计语言，并且还得到了 $100000000 的风险投资基金。这些基金全部用来支持用这种特别的计算机语言开发的产品。重温那些令人兴奋的日子是很有意思的。我们将简要地介绍一下 Java 语言的发展历史：\nJava 的历史要追溯到 1991 年，由 Patrick Naughton 及其伙伴 James Gosling (一个全能的计算机奇才) 带领的 Sun 公同的工程师小组想要设计一种小型的计算机语言，主要用于像有线电视转换盒这类的消费设备。由于这些消费设备的处理能力和内存都很有限，所以语言必须非常小且能够生成非常紧凑的代码。另外，由于不同的厂商会选择不同的中央处理器 (CPU)，因此这种语言的关键是不能与任何特定的体系结构捆绑在一起。这个项目被命名为 &quot;Green&quot;。\n所有就要求有这样的一种代码： 代码短小、紧凑且与平台无关。但是，Sun 公司的人都有 UNIX 的应用背景。因此，所开发的语言以 C++ 为基础。 是 Gosling 率先创造了这个语言，把这种语言称为 “Oak&quot;(这么起名的原因大概是因为他非常喜欢自己办公室外的橡树)。Sun 公司的人后来发现 Oak 是一种已有的计算机语言的名字，于是，将其改名为 Java。\n\n【3】Java 的发明人\nJames Gosling \n【4】经历阶段\n1991 年，James Gosling 在 SUN 公司的工程师小组想要设计这样一种小型计算机语言。该语言主要用于像电视盒这样的消费类电子产品。另外，由于不同的厂商选择不同的 CPU 和操作系统，因此，要求该语言不能和特定的体系结构绑在一起，要求语言本身是中立的，也就是跨平台的。所以，将这个语言命名为 “Green”，类似于绿色软件的意思。后来，改名为 Oak，橡树的意思。改名后发现已经有一种语言叫这个名字了，再改名叫 Java。Java 语言发展到今天经历了一系列的过程：\n 1991 年，SUN 公司的 Green 项目，Oak\n 1995 年，推出 Java 测试版\n 1996 年，JDK1.0\n 1997 年，JDK1.1\n 1998 年，JDK1.2，大大改进了早期版本缺陷，是一个革命性的版本，更名为 Java2。\n 2004 年，J2SE 5.0 (1.5.0) Tiger 老虎 成为 Java 语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5 更名为 Java SE 5.0\n 2005 年，Java 的各种版本已经更名，以取消其中的数字 &quot;2&quot;： J2ME 更名为 Java ME， J2SE 更名为 Java SE， J2EE 更名为 Java EE；\n 2006 年，J2SE 6.0 (1.6.0) Mustang 野马\n 2009 年，甲骨文 (oracle) 收购 SUN，交易高达价格 74 亿\n 2011 年，JavaSE7.0 Dolphin 海豚\n 2014 年，JavaSE8.0\n2017 年，JAVA 9.0\n 2018 年 3 月，JAVA 10\n 2018 年 9 月，JAVA 11\n 2019 年 3 月，JAVA 12\n 2019 年 9 月，JAVA 13\n 2020 年 3 月，JAVA 14\n注意：SUN 公司已经被 oracle 公司收购，目前每半年更新一次 java 的版本。但是，企业中的主流仍然以 7 和 8 为主。对于初学者，应该以企业主流应用版本为核心进行学习，没有必须在此处追求最新版本。\n\n【5】不同版本 JDK 说明\nJDK Version 1.1\n于 1997-02-19 发行。\n引入的新特性包括：\n引入 JDBC（Java Database Connectivity）；\n支持内部类；\n引入 Java Bean；\n引入 RMI（Remote Method Invocation）；\n引入反射（仅用于内省）。\nJ2SE Version 1.2\n开发代号为 Playground（操场），于 1998-12-08 发行。\n引入的新特性包括：\n引入集合（Collection）框架；\n对字符串常量做内存映射；\n引入 JIT（Just In Time）编译器；\n引入对打包的 Java 文件进行数字签名；\n引入控制授权访问系统资源的策略工具；\n引入 JFC（Java Foundation Classes），包括 Swing 1.0、拖放和 Java 2D 类库；\n引入 Java 插件；\n在 JDBC 中引入可滚动结果集、BLOB、CLOB、批量更新和用户自定义类型；\n在 Applet 中添加声音支持。\nJ2SE Version 1.3\n开发代号为 Kestrel（红隼），于 2000-05-08 发行。\n引入的新特性包括：\n引入 Java Sound API；\njar 文件索引；\n对 Java 的各个方面都做了大量优化和增强。\nJ2SE Version 1.4\n开发代号为 Merlin（隼），于 2004-02-06 发行（首次在 JCP 下发行）。\n引入的新特性包括:\nXML 处理；\nJava 打印服务；\n引入 Logging API；\n引入 Java Web Start；\n引入 JDBC 3.0 API；\n引入断言；\n引入 Preferences API；\n引入链式异常处理；\n支持 IPv6；\n支持正则表达式；\n引入 Image I/O slot machine API。\nJava Version SE 5.0\n开发代号为 Tiger（老虎），于 2004-09-30 发行。\n引入的新特性包括:\n引入泛型；\n增强循环，可以使用迭代方式；\n自动装箱与自动拆箱；\n类型安全的枚举；\n可变参数；\n静态引入；\n元数据（注解）；\n引入 Instrumentation。\nJava Version SE 6\n开发代号为 Mustang（野马），于 2006-12-11 发行。\n引入的新特性包括：\n支持脚本语言；\n引入 JDBC 4.0 API；\n引入 Java Compiler API；\n可插拔注解；\n增加对 Native PKI (Public Key Infrastructure)、Java GSS (Generic Security Service)、Kerberos 和 LDAP (Lightweight Directory Access Protocol) 的支持；\n继承 Web Services；\n做了很多优化。\nJava Version SE 7\n开发代号是 Dolphin（海豚），于 2011-07-28 发行。\n引入的新特性包括：\nswitch 语句块中允许以字符串作为分支条件；\n在创建泛型对象时应用类型推断；\n在一个语句块中捕获多种异常；\n支持动态语言；\n支持 try-with-resources；\n引入 Java NIO.2 开发包；\n数值类型可以用 2 进制字符串表示，并且可以在字符串表示中添加下划线；\n钻石型语法；\nnull 值的自动处理。\nJava Version SE 8\n开发代号是 Spider（蜘蛛），于 2014-03-18 发行。\n支持 lambda 支持；\n增强日期与时间 API 的功能；\n对垃圾回收的性能也进行了改进；\n并且移除了 permgen 区。\nLambdas 表达式与 Functional 接口\n接口的默认与静态方法\n方法引用\n重复注解\n更好的类型推测机制\n扩展注解的支持\n\n# JAVA 体系结构\nJavaSE（Java Standard Edition）：标准版，定位在个人计算机上的应用\n这个版本是 Java 平台的核心，它提供了非常丰富的 API 来开发一般个人计算机上的应用程序，包括用户界面接口 AWT 及 Swing，网络功能与国际化、图像处理能力以及输入输出支持等。在上世纪 90 年代末互联网上大放异彩的 Applet 也属于这个版本。Applet 后来为 Flash 取代，Flash 即将被 HTML5 取代。\nJavaEE（Java Enterprise Edition）：企业版，定位在服务器端的应用\nJavaEE 是 JavaSE 的扩展，增加了用于服务器开发的类库。如：JDBC 是让程序员能直接在 Java 内使用的 SQL 的语法来访问数据库内的数据；Servlet 能够延伸服务器的功能，通过请求 - 响应的模式来处理客户端的请求；JSP 是一种可以将 Java 程序代码内嵌在网页内的技术；\nJavaME（Java Micro Edition）：微型版，定位在消费性电子产品的应用上\nJavaME 是 JavaSE 的内伸，包含 J2SE 的一部分核心类，也有自己的扩展类，增加了适合微小装置的类库：javax.microedition.io.* 等。该版本针对资源有限的电子消费产品的需求精简核心类库，并提供了模块化的架构让不同类型产品能够随时增加支持的能力。\n\n# JAVA 的特性和优势\n 跨平台 / 可移植性\n这是 Java 的核心优势。Java 在设计时就很注重移植和跨平台性。比如：Java 的 int 永远都是 32 位。不像 C++ 可能是 16，32，可能是根据编译器厂商规定的变化。这样的话程序的移植就会非常麻烦。\n 安全性\nJava 适合于网络 / 分布式环境，为了达到这个目标，在安全性方面投入了很大的精力，使 Java 可以很容易构建防病毒，防篡改的系统。\n 面向对象\n面向对象是一种程序设计技术，非常适合大型软件的设计和开发。由于 C++ 为了照顾大量 C 语言使用者而兼容了 C，使得自身仅仅成为了带类的 C 语言，多少影响了其面向对象的彻底性！Java 则是完全的面向对象语言。\n 简单性\nJava 就是 C 语法的简化版，我们也可以将 Java 称之为 “C-”。跟我念 “C 加加减”，指的就是将 C++ 的一些内容去掉；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。同时，由于语法基于 C 语言，因此学习起来完全不费力。\n 高性能\nJava 最初发展阶段，总是被人诟病 “性能低”；客观上，高级语言运行效率总是低于低级语言的，这个无法避免。Java 语言本身发展中通过虚拟机的优化提升了几十倍运行效率。比如，通过 JIT (JUST IN TIME) 即时编译技术提高运行效率。 将一些 “热点” 字节码编译成本地机器码，并将结果缓存起来，在需要的时候重新调用。这样的话，使 Java 程序的执行效率大大提高，某些代码甚至接待 C++ 的效率。\n因此，Java 低性能的短腿，已经被完全解决了。业界发展上，我们也看到很多 C 应用转到 Java 开发，很多 C 程序员转型为 Java 程序员。\n 分布式\nJava 是为 Internet 的分布式环境设计的，因为它能够处理 TCP/IP 协议。事实上，通过 URL 访问一个网络资源和访问本地文件是一样简单的。Java 还支持远程方法调用 (RMI,Remote Method Invocation)，使程序能够通过网络调用方法。\n 多线程\n多线程的使用可以带来更好的交互响应和实时行为。 Java 多线程的简单性是 Java 成为主流服务器端开发语言的主要原因之一。\n 健壮性\nJava 是一种健壮的语言，吸收了 C/C++ 语言的优点，但去掉了其影响程序健壮性的部分（如：指针、内存的申请与释放等）。Java 程序不可能造成计算机崩溃。即使 Java 程序也可能有错误。如果出现某种出乎意料之事，程序也不会崩溃，而是把该异常抛出，再通过异常处理机制加以处理。\n总结：一句话：java 很好！\n但是，并不是说学习了 java，以后所有的东西都要用 java 开发了：某些领域其他语言有更出色的表现，比如，Objective C 和后来的 Swift 在 iOS 设备上就有着无可取代的地位。浏览器中的处理几乎完全由 JavaScript 掌控。Windows 程序通常都用 C++ 或 C# 编写。Java 在服务器端编程和跨平台客户端应用领域则很有优势。\n只能说，不同的语言之间，平分秋色！\n# 核心机制\n# 垃圾收集机制\n垃圾收集的目的在除不再使用的对象，当对象建立的时候垃圾收集期，就开始监控对象的动态情况，垃圾收集主要是对内存的释放。创建对象的时候申请一个空间\n1. 不再使用的内存空间应回收 —》垃圾收集；\n2.Java 消除了程序员回收无用内存空间的职责；提供一种系统级线程跟踪存储空间的分配情况。在 JVM 的空闲时，检查并释放可被释放的存储器空间；相比 c++, 开发人员负责要自己收回无用内存。\n3. 垃圾收集在 Java 程序运行过程中自动进行，程序员无法精确控制和干预；\n4.GC 的自动回收，提高了内存空间的利用效率，也提高了编程人员的效率，很大程度上减少了因为没有释放空间而导致的内存泄露。\n后续：\n更高级：\n1. 垃圾收集器有几种\n2. 垃圾收集器底层原理剖析\n3. 垃圾收集器算法，优化\n# 跨平台原理\nJAVA 跨平台原理的解释：\n\nC 语言的跨平台解释：\n\n总结\nJVM (Java Virtual Machine) 就是一个虚拟的用于执行 bytecode 字节码的” 虚拟计算机”。他也定义了指令集、寄存器集、结构栈、垃圾收集堆、内存区域。JVM 负责将 Java 字节码解释运行，边解释边运行，这样，速度就会受到一定的影响。\n不同的操作系统有不同的虚拟机。Java 虚拟机机制屏蔽了底层运行平台的差别，实现了 “一次编译，随处运行”。 Java 虚拟机是实现跨平台的核心机制。如图所示：\n\n我们说的语言跨平台是编译后的文件跨平台，而不是源程序跨平台。\n接下来我们再比较下两种方式的差异：第一，C 语言是编译执行的，编译器与平台相关，编译生成的可执行文件与平台相关；第二，Java 是解释执行的，编译为中间码的编译器与平台无关，编译生成的中间码也与平台无关（一次编译，到处运行），中间码再由解释器解释执行，解释器是与平台相关的，也就是不同的平台需要不同的解释器.\n# 常用 DOS 命令\n【1】DOS 操作系统\n–Microsoft 公司推出的操作系统。（在 windows 之前的操作系统）\n–DOS 是英文 &quot;Disk Operating System&quot; 的缩写，其中文含意是 &quot;磁盘操作系统&quot;.\n–DOS 是单用户、单任务的操作系统.（只能执行一个任务）\n\n【2】DOS 命令\n–在 windows 中，我们通过鼠标菜单等来操作系统，而在 dos 操作系统中，要通过 dos 命令来操作系统。\n–是 DOS 操作系统的命令，是一种面向磁盘的操作命令，\n–不区分大小写。\n【3】命令学习：\nwindows 给我们保留了类似 dos 系统的操作界面，可以直接操作磁盘！\ndos 也是一种操作系统，是在 windows 出现以前用的，后来 windows 出来后基本没人用了，但是当 windows 崩溃的时候，还是要的 dos 方式解决，它是一种纯命令方式，cmd 其实就是在 windows 状态下进入 dos 方式。\n控制命令台：win+r—&gt;cmd\n\n【4】具体 dos 命令：\n（1）切换盘符： c: d: e: 大小写没有区分\n（2）显示详细信息：dir\n\n（3）改变当前目录：cd\n\n（4）\n. 当前目录\n… 代表上一层目录\n\n\n（5）清屏：cls\n（6）切换历史命令：上下箭头\n（7）补全命令： tab 按键\n（8）创建目录：md\n删除目录：rd\n\n（9）复制文件命令：copy:\n\n（10）删除文件：del\ndel 后面如果接的是文件夹 / 目录：那么删除的就是这个文件夹下的文件，而不是文件夹\n\n# JAVA 环境准备–&gt;JDK\n# 【1】下载 JDK\nwww.oracle.com/technetwork/java/javase/downloads/index.html\n\n【2】安装 JDK\n\n\n\n# 【3】卸载 JDK\n控制面板卸载即可\n\n# 【4】 验证 JDK 是否安装成功\n（1）方式 1：去安装目录下看一眼：\n\n（2）方式 2：通过控制命令台查看：\n\n（3）方式 3：通过控制面板查看：\n\n【5】JDK 和 JRE：\nJDK： Java Development kit ----&gt; 编写 Java 程序的程序员使用的软件\nJRE : Java Runtime Enviroment ----》运行 Java 程序的用户使用的软件\n# 安装 notepad++，配置 path 环境变量\n【1】安装记事本：notepad\n【2】安装：一直下一步\n\n【3】打开记事本进行设置：\n设置–》首选项：\n\n设置–》语言格式设置：\n\n【4】打开 notepad++:\n（1）方式 1：通过快捷方式：\n\n（2）方式 2：通过可执行文件：\n\n（3）方式 3：利用控制命令台：\nwin+r–&gt;cmd:\n\n(4) 方式 4：在任意的路径下去执行 notepad++.exe 这个命令：\n但是发现报错：\n\n需要配置系统环境变量：\n\n找系统环境变量：\n\n\n将 notepad++.exe 所在的路径配置到 path 环境变量中去：\n\n这样我就可以在任意的路径下去执行这个命令：（注意：控制命令台需要重启）\n\npath 环境变量作用：\n将命令所在的路径配置到 path 中去，就相当于在计算机中 “注册” 了一样，以后找这个命令，会直接去你配置的路径下寻找。\n达到了一个效果：在任意的路径下去执行某个命令 —》path 环境针对整个操作系统而言。\n# 第一段程序\n【1】用 notepad 编写代码：\n\npublic class HelloWorld{\npublic static void main(String[] args){\nSystem.out.println (“hi 这是一段 Java 程序。。。”);\n}\n}\n\n记得保存 ctrl+s\n【2】进行编译：\n\n发现出错了，分析出错原因：\n\n解决办法：\n将 javac.exe 所在的路径 配置到 环境变量 path 中去，这样我就可以在任意的路径下去执行这个命令：\n\n配置好环境变量以后发现代码可以成功编译：\n\n验证：\n\n【3】进行解释 / 翻译 / 执行:\n\n上面执行过程成功的原因：\n\n# 程序中常见问题\n【1】最低级的错误：单词拼写错误\n【2】要求源文件名字和类名必须一模一样：\n\n出错：\n\n【3】所有的标点必须是英文状态下的：\n中文状态：【】（）{} ！；：“‘《》？\n英文状态：[] () {} ! ; : &quot; &amp;apos; &lt;&gt; ?\n【4】成对编程：\n[] {} () &lt;&gt; “” &amp;apos;’\n【5】注意缩进 ：只要遇到 {} 就进行缩进 —&gt; 为了格式好看\n缩进：tab\n向前缩进： shift+tab\n【6】编译：\njavac HelloWorld.java\n【7】执行：\njava HelloWorld\n【8】java 中大小写严格区分，大小敏感：\nHelloWorld Helloworld\na A\npublic PUBLIC\n【9】我们要写代码：就当做有一个 “框子”\n\npublic class HelloWorld{\npublic static void main(String[] args){\n\n\n}\n}\n\n【10】一个源文件中可以有多个类，只能有一个类被 public 修饰，源文件的名字必须跟 public 修饰的那个类名保持一致。\n\n多个类会产生独立的字节码文件：\n\n执行的时候执行各自独立的字节码文件即可：\n\n# 编译方式\n【1】方式 1：\n\n【2】方式 2：\n\n【3】方式 3：\n\n【4】方式 4：\n在 notepad 中右键文件 --》打开文件夹所在命令行\n\n# 扩展：classpath 环境变量\n**【1】系统有一个环境变量叫：**classpath，现在我们将 classpath 环境变量显式的写出来：\n\nclasspath 作用：只要你配置到 classpath 中的路径，在执行 java 的字节码文件的时候，就会去这个配置的路径下找 对应的字节码文件：\n现在我不配置.\\ 了 我配置：\n\n自从我配置了这个环境变量以后，可以在任意的路径下去执行字节码文件：\n总结：\nclasspath 作用：针对 java 执行字节码文件而产生的环境变量，只要配置了字节码文件所在的路径以后，那么以后你在任意位置都可以执行对应的字节码文件\n# 扩展：JAVA_HOME 环境变量\n后续我们会用到一个软件：tomcat，在执行 startup.bat 的时候会出现闪退问题：\n解决： 必须要配置一个环境变量叫：JAVA_HOME\n\n我再次启动才会成功：\n然后我们的 path 环境变量中刚好可以借助 JAVA_HOME 里面的内容，通过 %% 做引入 % JAVA_HOME%\\bin\n\n# API\n\n\nJDK 帮助文档\nSUN 公司为 JDK 工具包提供了一整套文档资料，我们习惯上称之为 JDK 文档。\nJDK 文档中提供了 Java 中的各种技术的详细资料，以及 JDK 中提供的各种类的帮助说明。\nJDk 文档是 Java 语言的完整说明，大多数书籍中的类的介绍都要参照它来完成，它是编程者经常查阅的资料\n如何理解 API：就当做是一个 “字典”，“使用手册”，API 就相当于是一个电子的帮助文档，可以帮我们查看 JDK 提供的类的信息，平时查看的时候可结合百度一起看。\n\n其实 API 没有什么神奇的，就是一个电子文档而已，帮助我们查看 JAVA 中涉及到的一些技能点：\n\n# 代码量统计工具\n\n# 注释\n为了方便程序的阅读，Java 语言允许程序员在程序中写上一些说明性的文字，用来提高程序的可读性，这些文字性的说明就称为注释。\n注释不会出现在字节码文件中，即 Java 编译器编译时会跳过注释语句。\n在 Java 中根据注释的功能不同，主要分为单行注释、多行注释和文档注释。\n\n单行注释\n\n单行注释使用 “//” 开头，“//” 后面的单行内容均为注释。\n\n多行注释\n\n多行注释以 “/*” 开头以 “*/” 结尾，在 “/*” 和 “*/” 之间的内容为注释，我们也可以使用多行注释作为行内注释。但是在使用时要注意，多行注释不能嵌套使用。\n\n文档注释\n\n文档注释以 “/**” 开头以 “*/” 结尾， 注释中包含一些说明性的文字及一些 JavaDoc 标签（后期写项目时，可以生成项目的 API）\n# 单行注释和多行注释\n\n// 下面是一段标准代码\n// 这是代码的 “框子”，当前阶段你可以当做一个模板\n// 其实这就是一个类，类的名字是 HelloWorld，这个名字可以随便起，但是一般首字母大写，驼峰命名，见名知意\npublic class HelloWorld{\n// 下面是一个 main 方法，方法的格式是固定的\npublic static void main(String[] args){\n// 下面这句话的作用：将双引号中的内容进行原样输出\n/*\n这是多行注释\n每行都可以写\n单行注释和多行注释，按照你自己的需求去使用即可\n*/\nSystem.out.println(“hi…java”);\n}\n}\n\n注意：\n1. 注释不会参与编译，编译后产生的字节码文件中不会有注释的内容\n2. 注释的作用：\n（1）注释就起到了标注解释的作用，提高代码的可读性，方便自己，方便他人–》是一个非常良好，非常专业的习惯！！！\n（2）方便代码的调试：\n\npublic class HelloWorld2{\npublic static void main(String[] args){\nSystem.out.println(“hi…java1”);\n//System.out.println(“hi…java2”)\nSystem.out.println(“hi…java3”);\n}\n}\n\n# 文档注释\n\n/**\n文档注释\n@author zhaoss\n@version 1.0\n这是我们第一章文档注释的代码，比较重要\n*/\npublic class HelloWorld3{\npublic static void main(String[] args){\nSystem.out.println(“hi…java1”);\n}\n/**\n@param name 姓名\n@param age 年龄\n*/\npublic void eat(String name,int age){\nSystem.out.println(“hello”);\n}\n}\n\n一般文档注释可以配合：jdk 提供的工具 javadoc.exe 来一起使用，通过 javadoc.exe 可以对文档注释进行解析，生成一套以网页文件形式体现的该程序的说明文档。（自定义类对应的 API）\n\n\n\n\n# 反编译工具的使用\n\n编译\n\n源代码 -----&gt;class\n\n反编译\n\nclass----&gt; 源代码\n\n反编译工具\n\njd-gui.exe\n\n# 本章最后一段代码\n\npublic class HiWorld{\npublic static void main(String[] args){\n// 进行自我介绍：\nSystem.out.print (“姓名：”);\nSystem.out.print (&quot;\\t 丽丽 \\n&quot;);\nSystem.out.print (“职业：”);\nSystem.out.print (&quot;\\t 学生&quot;);\n/*\n(1) System.out.print 和 System.out.println 区别联系：\nSystem.out.print ： 将双引号中内容原样输出，不换行\nSystem.out.println ：将双引号中内容原样输出，换行\n(2) 转义字符：\n\\ 就是转义字符：作用：将后面普通的字母转换为特殊含义\n\\n : 换行\n\\t : 距离前面有一个制表符位置\n*/\n\nSystem.out.println ();// 换行\nSystem.out.println(“1111111111111111111”);\nSystem.out.println(“11111111\\t2222”);\n}\n}\n\n# 扩展面试题：JDK，JRE，JVM 的区别\nJDK,JRE,JVM 的关系:\n\n先说 JDK 和 JRE:\n初学 JAVA 很容易被其中的很多概念弄的傻傻分不清楚，首先从概念上理解一下吧，JDK（Java Development Kit）简单理解就是 Java 开发工具包，JRE (Java Runtime Enviroment) 是 Java 的运行环境，JVM ( java virtual machine) 也就是常常听到 Java 虚拟机。JDK 是面向开发者的，JRE 是面向使用 JAVA 程序的用户，上面只是简单的区别\n通过上图发现发现有两个 JRE 文件夹，如果细看里面的内容基本上是一样的，如果是只是 Java 程序使用者，那么只会有最外层的那个 JRE 目录，JDK 中是 JRE 自带的，你如果安装了 JDK 必然里面会有一个 JRE. 那么问题来了，为什么会有两套 JRE 呢？\n从侧面证明:\n利用 javac.exe 进行编译:\n\n然后我将 C:\\Program Files\\Java\\jdk1.8.0_151\\lib\\tools.jar 改个名字，再去编译:\n\n证明:dt.jar 和 tools.jar 是两个 java 最基本的包，里面包含了从 java 最重要的 lang 包到各种高级功能如可视化的 swing 包，是 java 必不可少的。而 path 下面的 bin 里面都是 java 的可执行的编译器及其工具，如 java，javadoc 等，报错的原因就是输入的 javac 的命令不是去 JDK 中 bin 目录去找的 javac.exe，而是去 JDK 中 lib 目录中的 tools.jar 中 com.sun.tools.javac.Main 中执行，因此 javac.exe 只是一个包装器（Wrapper），存在的目的是为了让开发者免于输入过长的指命。这个时候发现 JDK 里的工具几乎是用 Java 所编写，同属于 Java 应用程序，因此要使用 JDK 所附的工具来开发 Java 程序，所以自身需要附一套 JRE 才能运行。上图中与 jdk 同级目录下的 JRE 就是用来运行一般 Java 程序用的。\n两套 JRE 运行的时候究竟运行哪一个呢，这个时候 JDK 中 java.exe 先从自身目录中找，然后父级目录中找，如果都没有就去注册表中找\n\n再说 JRE 和 JVM:\nJVM – java virtual machineJVM 就是我们常说的 java 虚拟机，它是整个 java 实现跨平台的最核心的部分，所有的 java 程序会首先被编译为.class 的类文件，这种类文件可以在虚拟机上执行，class 文件并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行，类似于 C# 中的 CLR。\nJVM 不能单独搞定 class 的执行，解释 class 的时候 JVM 需要调用解释所需要的类库 lib。在 JDK 下面的的 jre 目录里面有两个文件夹 bin 和 lib, 在这里可以认为 bin 里的就是 jvm，lib 中则是 jvm 工作所需要的类库，而 jvm 和 lib 和起来就称为 jre。\n\nJVM+Lib=JRE，如果讲的具体点就是 bin 目录下的 jvm.dll 文件， jvm.dll 无法单独工作，当 jvm.dll 启动后，会使用 explicit 的方法 (就是使用 Win32 API 之中的 LoadLibrary () 与 GetProcAddress () 来载入辅助用的动态链接库)，而这些辅助用的动态链接库 (.dll) 都必须位 于 jvm.dll 所在目录的父目录之中。因此想使用哪个 JVM，只需要设置 PATH，指向 JRE 所在目录下的 jvm.dll。\n\n","slug":"第1章初识JAVA","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,JAVA简介","tags_index":"JavaSE","author_index":"雾都"},{"id":"660e7e650553bed7272bd20db06da01d","title":"第3章_运算符","content":"# Java 中的运算符\n【1】Java 语言支持如下运算符：\n\n算术运算符\n\n+，-，*，/，%，++（自增），–（自减）\n\n赋值运算符\n\n=\n\n扩展赋值运算符\n\n+=，-=，*=，/=\n\n关系运算符\n\n&gt;，&lt;，&gt;=，&lt;=，==，!=\n\n逻辑运算符\n\n&amp;，|， &amp;&amp;，||，!，^\n\n位运算符\n\n&amp;，|，^，~ ， &gt;&gt;，&lt;&lt;，&gt;&gt;&gt; (了解！！！)\n\n条件运算符\n\n？：\n【2】相关概念辨析\n+ 运算符 操作符 Operator\n5+6 表达式 expression\n5 6 操作数 Operand\nint m =5+6; 语句 Sentence\n# 算术运算符\n# / 和 %\n【1】/ 除法运算符 ： 表示两个数相除运算\n% 取余运算符： 用来求余数的\npublic class TestOpe01&#123;\n\n    public static void main(String[] args)&#123;\n\n        //打印结果：\n\n        System.out.println(12/3);\n\n        System.out.println(12%5);\n\n        System.out.println(12/3.0);\n\n        System.out.println(12%5.0);\n\n    &#125;\n\n&#125;\n【2】练习：\nimport java.util.Scanner;\n\npublic class TestOpe02&#123;\n\n    public static void main(String[] args)&#123;\n\n        //实现功能：任意给出一个四位数，求出每位上的数字并输出\n\n        \n\n        //1.任意给出一个四位数：\n\n        Scanner input = new Scanner(System.in);\n\n        System.out.println(\"请录入一个四位数：\");\n\n        int num = input.nextInt();\n\n        \n\n        \n\n        //2.求出每位上的数字：\n\n        //个位数：\n\n        int num1 = num%10;\n\n        //十位数：\n\n        int num2 = num/10%10;//1234---\\>123---\\>3\n\n        //百位数：\n\n        int num3 = num/100%10;//1234---\\>12---\\>2\n\n        //千位数：\n\n        int num4 = num/1000;//1234---\\>1\n\n        \n\n        \n\n        //3.输出每位上的数字：\n\n        System.out.println(\"个位上的数为：\"+num1);\n\n        System.out.println(\"十位上的数为：\"+num2);\n\n        System.out.println(\"百位上的数为：\"+num3);\n\n        System.out.println(\"千位上的数为：\"+num4);\n\n    &#125;\n\n    \n\n&#125;\n# +\n【1】+ 的作用：\n（1）表示正数\n（2）表示相加操作\n（3）进行字符串的拼接\n【2】代码练习：\npublic class TestOpe03&#123;\n\n    public static void main(String[] args)&#123;\n\n        //表示正数：\n\n        System.out.println(+5);//5\n\n        //相加操作：\n\n        System.out.println(5+6);//11\n\n        System.out.println(5+'6');//59\n\n        //字符串的拼接：\n\n        //规则：+左右两侧的任意一侧有字符串，那么这个加号就是字符串拼接的作用，结果一定是字符串\n\n        int num = 56;\n\n        System.out.println(\"num=\"+num);//\"num=56\" ---\\> num=56\n\n        System.out.println(5+6+\"7\");//11+\"7\"---\\>\"117\" ---\\>117\n\n        System.out.println(5+'6'+\"7\");//59 +\"7\"---\\>\"597\" ---\\>597\n\n        System.out.println(\"5\"+6+\"7\");//\"56\"+\"7\" ---\\>\"567\"---\\>567\n\n        System.out.println(\"5\"+'6'+\"7\");//\"56\"+\"7\"---\\>\"567\"---\\>567\n\n        System.out.println(\"5\"+'6'+'7');//\"56\"+'7'---\\>\"567\"---567\n\n    &#125;\n\n&#125;\n# ++\n【1】++：\npublic class TestOpe04&#123;\n\n    public static void main(String[] args)&#123;\n\n        int a = 5;\n\n        a++;//理解为：相当于 a=a+1 操作\n\n        System.out.println(a);//6\n\n        \n\n        a = 5;\n\n        \\++a;//理解为：相当于 a=a+1 操作\n\n        System.out.println(a); //6\n\n        \n\n        //总结：++单独使用的时候，无论放在前还是后，都是加1操作\n\n        \n\n        //将++参与到运算中：\n\n        //规则：看++在前还是在后，如果++在后：先运算，后加1 如果++在前，先加1，后运算\n\n        a = 5;\n\n        int m = a++ + 7;//先运算 m=a+7 再加1： a = a+1\n\n        System.out.println(m);//12\n\n        System.out.println(a);//6\n\n        \n\n        a = 5;\n\n        int n = ++a + 7;//先加1 a=a+1 再运算： n = a+7\n\n        System.out.println(n);//13\n\n        System.out.println(a);//6\n\n    &#125;\n\n&#125;\n无论这个变量是否参与到运算中去，只要用 ++ 运算符，这个变量本身就加 1 操作\n只是说如果变量参与到运算中去的话，对运算结果是产生影响：\n看在前还是在后，如果在后：先运算，后加 1 如果 ++ 在前，先加 1，后运算\n【2】练习：\npublic class TestOpe05&#123;\n\n    public static void main(String[] args)&#123;\n\n        int a = 5;\n\n        System.out.println(a++ + a++);\n\n        System.out.println(a++ + ++a);\n\n        System.out.println(++a + a++);\n\n        System.out.println(++a + ++a);\n\n    &#125;\n\n&#125;\n运算过程：\n\n# 赋值运算符\n【1】= 的作用： 将等号右侧的值赋给等号左侧：\nint age = 19;\nint age = 10+3+8;\n【2】练习：\npublic class TestOpe06&#123;\n    public static void main(String[] args)&#123;\n        //任意给出两个数，交换两个数并输出：\n        //1.给出两个数：\n        int num1 = 10;\n        int num2 = 20;\n        \n        //2.输出交换前的两个数：\n        System.out.println(\"交换前：\"+num1+\"\\\\t\"+num2);\n        \n        //3.交换\n        /\\*\n            错误代码：\n            num1 = num2;\n        num2 = num1;\n        \\*/\n            //解决办法：\n            //引入一个中间变量:\n            int t;\n        t = num1;\n        num1 = num2;\n        num2 = t;\n        /\\*\n            int t;\n        t = num2;\n        num2 = num1;\n        num1 = t;\n        \n        \\*/\n            \n            //4.输出交换后的两个数：\n            System.out.println(\"交换后：\"+num1+\"\\\\t\"+num2);\n    &#125;\n&#125;\n\n面试题：两个数交换的四种方式：https://www.cnblogs.com/Brad-Lee/p/5808299.html\n# 扩展赋值运算符\n【1】代码：\npublic class TestOpe07&#123;\n    public static void main(String[] args)&#123;\n        //实现功能：给出三个数，求和：\n        //1.给出三个数：\n        int num1 = 10;\n        int num2 = 20;\n        int num3 = 30;\n        //2.求和\n        //int sum = num1+num2+num3;\n        //定义一个变量，用来接收和：\n        int sum = 0;\n        sum = sum + num1;//等效： sum += num1;\n        sum = sum + num2;// sum += num2;\n        sum = sum + num3;//sum += num3;\n        //3.将和输出：\n        System.out.println(\"和：\"+sum);\n    &#125;\n&#125;\n内存：\n\n【2】a+=b 和 a=a+b 区别：\n（1）a+=b 可读性稍差 编译效率高 底层自动进行类型转换\n（2）a=a+b 可读性好 编译效率低 手动进行类型转换\n【3】面试题\n（1）请问 a+=b 相当于 a=a+b, 那么也相当于 a=b+a 吗？\n\n（2）下面的代码哪一句出错： 4\nbyte a = 10; —&gt;1\nint b = 20; —&gt;2\na+=b; ----&gt;3\na = a+b ;----&gt;4\n更正： a = (byte)(a+b);\n# 关系运算符\npublic class TestOpe08&#123;\n    public static void main(String[] args)&#123;\n        //\\>，\\&lt;，\\>=，\\&lt;=，==，!=\n        //关系运算符最终结果：要么是true要么是false\n        System.out.println(4\\>9);//false\n        System.out.println(4\\&lt;9);//true\n        System.out.println(4\\>=9);//false\n        System.out.println(4\\&lt;=9);//true\n        System.out.println(4==9);//false\n        System.out.println(4!=9);//true\n        System.out.println((5\\&lt;9)!=(6==8));//true\n    &#125;\n&#125;\n# 逻辑运算符\n&amp;，|， &amp;&amp;，||，!，^\n逻辑运算符：进行逻辑运算的，运算符左右连接的都是 布尔类型的操作数，最终表达式的结果是布尔值：要么是 true，要么 false\n代码：\npublic class TestOpe09&#123;\n    public static void main(String[] args)&#123;\n        // 逻辑与 ：&amp; 规律：只要有一个操作数是false，那么结果一定是false\n        System.out.println(true&amp;true);\n        System.out.println(true&amp;false);\n        System.out.println(false&amp;false);\n        System.out.println(false&amp;true);\n        \n        // 短路与：&amp;&amp; 规律：效率高一些，只要第一个表达式是false，那么第二个表达式就不用计算了，结果一定是false\n        System.out.println(true&amp;&amp;true);\n        System.out.println(true&amp;&amp;false);\n        System.out.println(false&amp;&amp;false);\n        System.out.println(false&amp;&amp;true);\n        \n        // 逻辑或：\\| 规律：只要有一个操作数是true，那么结果一定是true\n        System.out.println(true\\|true);\n        System.out.println(true\\|false);\n        System.out.println(false\\|false);\n        System.out.println(false\\|true);\n        \n        // 短路或：\\|\\| 规律：效率高一些，只要第一个表达式是true，那么第二个表达式就不用计算了，结果一定是true\n        System.out.println(true\\|\\|true);\n        System.out.println(true\\|\\|false);\n        System.out.println(false\\|\\|false);\n        System.out.println(false\\|\\|true);\n        \n        //逻辑非： ! 规律：相反结果\n        System.out.println(!true);//false\n        System.out.println(!false);//true\n        \n        //逻辑异或： \\^ 规律：两个操作数相同，结果为false，不相同，结果为true\n        System.out.println(true\\^true);\n        System.out.println(true\\^false);\n        System.out.println(false\\^false);\n        System.out.println(false\\^true);\n    &#125;\n&#125;\n再做一个加深的练习：看代码 说结果：\npublic class TestOpe10&#123;\n    public static void main(String[] args)&#123;\n        int i=8;\n        System.out.println((5\\>7)&amp;&amp;(i++==2)); //false\n        System.out.println(i); //8\n\n\n        int a=8;\n        System.out.println((5\\>7)&amp;(a++==2)); //false\n        System.out.println(a); //9\n\n\n        int m=8;\n        System.out.println((5\\&lt;7)&amp;&amp;(m++==2)); //false\n        System.out.println(m); //9\n\n        int b=2;\n        System.out.println((5\\&lt;7)&amp;(b++==2)); //true\n        System.out.println(b); //3\n\n        int c=2;\n        System.out.println((5\\&lt;7)&amp;(++c==2)); //false\n        System.out.println(c); //3\n    &#125;\n&#125;\n\n# 条件运算符\n【1】条件运算符：又称： 三元运算符 / 三目运算符\n【2】格式：\na?b:c\n其中 a 是一个布尔类型的表达式，返回结果要么是 true 要么 false，通过 a 的结果决定最终表达式的结果:\n如果 a 的结果是 true，那么表达式最终结果为 b\n如果 a 的结果是 false，那么表达式最终结果为 c\n代码：\npublic class TestOpe11&#123;\n    public static void main(String[] args)&#123;\n        int num = (5\\>7)?6:9 ;\n        System.out.println(num);\n\n        String str = (4==4)?\"你好\":\"你不好\" ;\n        System.out.println(str);\n\n        System.out.println((4==4)?\"你好\":\"你不好\");\n    &#125;\n&#125;\n\n练习：\n\nimport java.util.*;//* 代表所有\n\npublic class TestOpe12&#123;\npublic static void main(String[] args)&#123;\n//实现功能：男孩女孩选择晚饭吃什么，如果意见一致，听男生的，如果意见不一致，听女生的\n\n//1.要让男孩女孩选择晚饭吃什么：\nScanner sc = new Scanner(System.in);\nSystem.out.println(\"请选择今晚吃什么：1.火锅 2.烧烤 3.麻辣烫 4.西餐\");\nSystem.out.println(\"请男孩选择：\");\nint boyChoice = sc.nextInt();\nSystem.out.println(\"请女孩选择：\");\nint girlChoice = sc.nextInt();\n//2.判断：\nSystem.out.println(boyChoice==girlChoice?\"听男孩的\":\"听女孩的\");\n&#125;\n&#125;\n\nPS: 三目运算符可以代替后续我们要学习的 if-else\n# 位运算符 (了解)\n位运算符：&amp;，|，^，~ ， &gt;&gt;，&lt;&lt;，&gt;&gt;&gt;\n如何区分逻辑运算符和位运算符：\n逻辑运算符：左右连接的是布尔类型的操作数\n位运算符：左右连接的是具体的数值\n【1】&lt;&lt; 左移\n3&lt;&lt;2 = 12\n\n面试题： 4 乘以 8 最快的方式： 4&lt;&lt;3\n【2】&gt;&gt; 有符号右移\n6&gt;&gt;2 = 1\n\n-6&gt;&gt;2 = -2\n\n【3】&gt;&gt;&gt; 无符号右移：\n6&gt;&gt;&gt;2 = 1\n\n【4】 &amp; 与\n6&amp;3 = 2\n\n【5】| 或\n6|3=7\n\n【6】^ 异或：\n6^3 = 5\n\n【7】~ 反：\n~6 = -7\n\nPS：\nbyte 类型的表数范围的 -128 是怎么算出来的\n127： 01111111\n-128： 10000000\n一看就是个负数\n减 1： 01111111\n取反： 10000000 —》2^7 = 128\n加负号： -128\n# 运算符总结\n\n\n\n# 运算符的优先级别\n\n不需要去刻意的记优先级关系\n赋值 &lt; 三目 &lt; 逻辑 &lt; 关系 &lt; 算术 &lt; 单目\n理解运算符的结合性\nPS: 实际开发中我们不会写特别复杂的表达式，你要想先算谁就用 ()\n案例：\n5&lt;6 | &amp;apos;A'&gt;'a' &amp;&amp; 12*6&lt;=45+23&amp;&amp;!true\n=5&lt;6 | &amp;apos;A'&gt;'a' &amp;&amp; 12*6&lt;=45+23&amp;&amp;false\n= 5&lt;6 | &amp;apos;A'&gt;'a' &amp;&amp;72&lt;=68&amp;&amp;false\n= true|false&amp;&amp;false&amp;&amp;false\n= true&amp;&amp;false&amp;&amp;false\n=false&amp;&amp;false\n=false\n","slug":"第3章_运算符","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,运算符","tags_index":"JavaSE","author_index":"雾都"},{"id":"ceae083d3bf0e78bb8b213d70446b383","title":"第4章_流程控制","content":"# 第 4 章_流程控制\n# 引入\n【1】流程控制的作用：\n流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。\n【2】控制语句的分类：\n控制语句分为三类：顺序、选择和循环。\n“顺序结构” 代表 “先执行 a，再执行 b” 的逻辑。\n“条件判断结构” 代表 “如果…，则…” 的逻辑。\n“循环结构” 代表 “如果…，则再继续…” 的逻辑。\n三种流程控制语句就能表示所有的事情！不信，你可以试试拆分你遇到的各种事情。这三种基本逻辑结构是相互支撑的，它们共同构成了算法的基本结构，无论怎样复杂的逻辑结构，都可以通过它们来表达。所以任何一种高级语言都具备上述两种结构。\n本章是大家真正进入编程界的 “门票”。\n【3】流程控制的流程：\n\n# 分支结构 (选择结构)\n# if\n# 单分支\n【1】语法结构:\n\n\n\nif (布尔表达式)\n\n\n\nif 语句对布尔表达式进行一次判定，若判定为真，则执行 {} 中的语句块，否则跳过该语句块。流程图如图所示：\n\n【2】代码：\npublic class TestIf01&#123;\n    public static void main(String[] args)&#123;\n        //实现一个功能：给出三个数（1-6），对三个数求和计算，根据和的大小来分配不同的奖品\n        //1.给出三个数：\n        int num1 = 6;\n        int num2 = 2;\n        int num3 = 3;\n        //2.求和\n        int sum = 0;\n        sum += num1;\n        sum += num2;\n        sum += num3;\n        System.out.println(\"和为：\"+sum);\n\n        //3.根据和判断奖品：\n        //如果和大于等于14，那么就是一等奖\n        if(sum\\>=14)&#123;\n            System.out.println(\"一等奖\");\n            System.out.println(\"恭喜你很幸运，中了一等奖\");\n        &#125;\n\n        if(sum\\>=10&amp;&amp;sum\\&lt;14)&#123;\n            System.out.println(\"二等奖\");\n        &#125;\n\n        if(sum\\>=6&amp;&amp;sum\\&lt;10)&#123;\n            System.out.println(\"三等奖\");\n        &#125;\n\n        if(sum\\&lt;6)&#123;\n            System.out.println(\"四等奖\");\n        &#125;\n\n        /\\*\n            if-单分支：\n                （1）结构：\n                if(条件表达式，这个表达式的结果是布尔值：要么是false，要么是true)&#123;\n                    //如果上面()中的表达式返回结果是true，那么执行&#123;&#125;中代码\n                    //如果上面()中的表达式返回结果是false ，那么不执行&#123;&#125;中代码\n                    //PS:&#123;&#125;中的代码是否执行，取决于()中表达式的返回结果\n                &#125;\n        （2）上面的代码中，我用四个单分支拼凑出四个选择，每个选择是独立的，依次判断执行的\n            （3）if后面的()中的条件，要按照自己需求尽量完善\n            （4）&#123;&#125;可以省略不写,但是一旦省略，这个if就只负责后面的一句话，所以我们不建议初学者省略\n            \\*/\n    &#125;\n&#125;\n\n# 多分支\n【1】语法结构：\n\n\n\nif (布尔表达式 1) {   语句块 1;  } else if (布尔表达式 2) {   语句块 2;  }……  else if (布尔表达式 n){   语句块 n;  } else\n\n\n\n当布尔表达式 1 为真时，执行语句块 1；否则，判断布尔表达式 2，当布尔表达式 2 为真时，执行语句块 2；否则，继续判断布尔表达式 3・・・・・・；如果 1~n 个布尔表达式均判定为假时，则执行语句块 n+1，也就是 else 部分。流程图如图所示：\n\n【2】数轴分析：\n\n【3】代码：\npublic class TestIf02&#123;\n    public static void main(String[] args)&#123;\n        //实现一个功能：给出三个数（1-6），对三个数求和计算，根据和的大小来分配不同的奖品\n        //1.给出三个数：\n        int num1 = 6;\n        int num2 = 4;\n        int num3 = 2;\n        //2.求和\n        int sum = 0;\n        sum += num1;\n        sum += num2;\n        sum += num3;\n        System.out.println(\"和为：\"+sum);\n\n        //3.根据和判断奖品：\n        /\\*\n            利用一个多分支\n            【1】结构：\n            if()&#123;\n\n            &#125;else if()&#123;\n\n            &#125;else if()&#123;\n\n            &#125;...\n                else&#123;\n\n                &#125;\n        【2】else:隐藏了一个条件，跟上面分支条件表达式相反的功能 (详见数轴分析)\n            【3】多分支：好处：只要满足一个 分支以后，后面的分支就不需要判断了 --》效率高\n            【4】我们写代码的时候，尽量保证else的存在--》else分支相当于“兜底”“备胎”的作用，别的分支都不走，就会走这个分支了\n            \\*/\n            if(sum\\>=14)&#123;\n                System.out.println(\"一等奖\");\n            &#125;else if(sum\\>=10)&#123;//隐藏了sum\\&lt;14\n                System.out.println(\"二等奖\");\n            &#125;else if(sum\\>=6)&#123;//隐藏了sum\\&lt;10\n                System.out.println(\"三等奖\");\n            &#125;else&#123;//隐藏了sum\\&lt;6\n                System.out.println(\"四等奖\");\n            &#125;\n\n\n\n    &#125;\n&#125;\n\n# 双分支\n【1】语法结构:\n\n\n\nif (布尔表达式){  语句块 1  } else\n\n\n\n当布尔表达式为真时，执行语句块 1，否则，执行语句块 2。也就是 else 部分。流程图如图所示：\n\n# 随机数\n随机数：这个数在生成之前我们不确定这个数是多少，不可知\n在 java 中依靠一个类：Math 类帮助我们生成，这个类中有一个方法专门用来生成随机数：\n\nMath.random() -------&gt; [0.0,1.0)\nMath.random()*6 -----&gt;[0.0,6.0)\n(int)(Math.random()*6) -----&gt;[0,5]\n(int)(Math.random()*6) +1 -----&gt;[1,6]\n应用到程序中：\nint num1 = (int)(Math.random()\\*6) +1;\nint num2 = (int)(Math.random()\\*6) +1;\nint num3 = (int)(Math.random()\\*6) +1;\n练习：\n[32,98] - [0,66]+32 - (int)(Math.random()*67) + 32\n# 分支的嵌套使用\n分支结构练习 1\n练习：\n会员购物时，不同积分享受的折扣不同，规则如下：\n\n计算会员购物时获得的折扣，效果如下：\n\n本题主要考的是 程序的优化：\nimport java.util.Scanner;\npublic class TestIf04&#123;\n    public static void main(String[] args)&#123;\n        //1.给出积分：\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"请输入会员积分：\");\n\n        //先判断键盘录入的数据是不是int类型的\n        if(sc.hasNextInt()==true)&#123;//是int类型数据：\n            //将这个int类型的数据接收：\n            int score = sc.nextInt();\n            //判断这个积分是否是正数：\n            if(score\\>=0)&#123;\n                String discount = \"\";\n                //2.根据积分判断折扣：\n                if(score\\>=8000)&#123;\n                    discount = \"0.6\";\n                &#125;else if(score\\>=4000)&#123;\n                    discount = \"0.7\";\n                &#125;else if(score\\>=2000)&#123;\n                    discount = \"0.8\";\n                &#125;else&#123;\n                    discount = \"0.9\";\n                &#125;\n                System.out.println(\"该会员享受的折扣为：\"+discount);\n\n            &#125;else&#123;//score\\&lt;0\n                System.out.println(\"对不起，你录入的积分是负数！不符合需求！\");\n            &#125;\n        &#125;else&#123;//不是int类型的数据\n            System.out.println(\"你录入的积分不是整数！\");\n        &#125;\n\n    &#125;\n&#125;\n\n分支结构练习 2\n练习：\n小朋友搬桌子：\n年龄大于 7 岁，可以搬桌子；\n如果年龄大于 5 岁，性别是男，可以搬桌子；\n否则不可以搬动桌子，提示：你还太小了\n本题主要考的是：逻辑\n方式 1：性别用 0 或者 1 接收：\nimport java.util.Scanner;\npublic class TestIf05&#123;\n    public static void main(String[] args)&#123;\n        //1.录入小朋友的年龄：\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请录入小朋友的年龄：\");\n        int age = sc.nextInt();\n\n        //2.根据年龄判断：\n        if(age\\>=7)&#123;\n            System.out.println(\"yes\");\n        &#125;else if(age\\>=5)&#123;\n            //录入小朋友的性别；\n            System.out.println(\"请录入小朋友的性别：男：1 女 ：0\");\n            int sex = sc.nextInt();\n            if(sex==1)&#123;//男生\n                System.out.println(\"yes\");\n            &#125;else&#123;//女孩\n                System.out.println(\"no\");\n            &#125;\n        &#125;else&#123;//age\\&lt;5\n            System.out.println(\"no\");\n        &#125;\n    &#125;\n&#125;\n\n方式 2：性别用男或者女接收：\nimport java.util.Scanner;\npublic class TestIf06&#123;\n    public static void main(String[] args)&#123;\n        //1.录入小朋友的年龄：\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请录入小朋友的年龄：\");\n        int age = sc.nextInt();\n\n        //2.根据年龄判断：\n        if(age\\>=7)&#123;\n            System.out.println(\"yes\");\n        &#125;else if(age\\>=5)&#123;\n            //录入小朋友的性别；\n            System.out.println(\"请录入小朋友的性别：\");\n            String str = sc.next();\n            char sex = str.charAt(0);\n            if(sex=='男')&#123;\n                System.out.println(\"yes\");\n            &#125;else&#123;\n                System.out.println(\"no\");\n            &#125;\n        &#125;else&#123;//age\\&lt;5\n            System.out.println(\"no\");\n        &#125;\n    &#125;\n&#125;\n\n# switch\n【1】switch 多分支结构 (多值情况)\n语法结构：\n\n\n\nswitch (表达式)\n\n\n\nswitch 语句会根据表达式的值从相匹配的 case 标签处开始执行，一直执行到 break 语句处或者是 switch 语句的末尾。如果表达式的值与任一 case 值不匹配，则进入 default 语句（如果存在 default 语句的情况）。根据表达式值的不同可以执行许多不同的操作。switch 语句中 case 标签在 JDK1.5 之前必须是整数（long 类型除外）或者枚举，不能是字符串，在 JDK1.7 之后允许使用字符串 (String)。大家要注意，当布尔表达式是等值判断的情况，可以使用 if-else if-else 多分支结构或者 switch 结构，如果布尔表达式区间判断的情况，则只能使用 if-else if-else 多分支结构。switch 多分支结构的流程图如图所示：\n\n【2】练习\npublic class TestSwitch&#123;\n    public static void main(String[] args)&#123;\n        /\\*\n            实现一个功能：\n            根据给出的学生分数，判断学生的等级：\n            \\>=90 -----A\n            \\>=80 -----B\n            \\>=70 -----C\n            \\>=60 -----D\n            \\&lt;60 -----E\n\n            用if分支：\n            if(score\\>=90)&#123;\n\n            &#125;else if(score\\>=80)&#123;\n\n            &#125;\n        \\*/\n            //1.给出学生的成绩：\n            int score = 167;\n        //2.根据成绩判断学生的等级：\n        switch(score/10)&#123;\n            case 10 :\n            case 9 : System.out.println(\"A级\");break;\n            case 8 : System.out.println(\"B级\");break;\n            case 7 : System.out.println(\"C级\");break;\n            case 6 : System.out.println(\"D级\");break;\n            default:System.out.println(\"成绩错误\");break;\n            case 5 :\n            case 4 :\n            case 3 :\n            case 2 :\n            case 1 :\n            case 0 : System.out.println(\"E级\");break;\n\n        &#125;\n        /\\*\n            【1】语法结构：\n            switch()&#123;\n                case \\* :\n                case \\* :\n                    .......\n            &#125;\n        【2】switch后面是一个()，()中表达式返回的结果是一个等值，这个等值的类型可以为：\n            int,byte,short,char,String,枚举类型\n            【3】这个()中的等值会依次跟case后面的值进行比较，如果匹配成功，就执行:后面的代码\n            【4】为了防止代码的“穿透”效果：在每个分支后面加上一个关键词break，遇到break这个分支就结束了\n            【5】类似else的“兜底”“备胎”的分支：default分支\n            【6】default分支可以写在任意的位置上，但是如果没有在最后一行，后面必须加上break关键字，\n            如果在最后一行的话，break可以省略\n            【7】相邻分支逻辑是一样的，那么就可以只保留最后一个分支，上面的都可以省去不写了\n            【8】switch分支和if分支区别：\n            表达式是等值判断的话--》if ，switch都可以\n            如果表达式是区间判断的情况---》if最好\n            【9】switch应用场合：就是等值判断，等值的情况比较少的情况下\n            \\*/\n    &#125;\n&#125;\n\n# 循环结构\n# while\n【1】语法结构：\n\n\n\nwhile (布尔表达式)\n\n\n\n在循环刚开始时，会计算一次 “布尔表达式” 的值，若条件为真，执行循环体。而对于后来每一次额外的循环，都会在开始前重新计算一次。\n语句中应有使循环趋向于结束的语句，否则会出现无限循环–––&quot;死&quot; 循环。\nwhile 循环结构流程图如图所示:\n\n【2】练习：1+2+3+4+5\npublic class TestWhile&#123;\n    public static void main(String[] args)&#123;\n        //功能：1+2+3+4+5\n        //1.定义变量：\n        int num1 = 1;\n        int num2 = 2;\n        int num3 = 3;\n        int num4 = 4;\n        int num5 = 5;\n        //2.定义一个求和变量，用来接收和：\n        int sum = 0;\n        sum += num1;\n        sum += num2;\n        sum += num3;\n        sum += num4;\n        sum += num5;\n\n        //3.输出和\n        System.out.println(sum);\n    &#125;\n&#125;\n\n上述代码缺点：变量的定义个数太多了\n解决：\npublic class TestWhile&#123;\n    public static void main(String[] args)&#123;\n        //功能：1+2+3+4+5\n        //1.定义变量：\n        int num = 1;\n        //2.定义一个求和变量，用来接收和：\n        int sum = 0;\n        sum += num;\n        num++;\n        sum += num;\n        num++;\n        sum += num;\n        num++;\n        sum += num;\n        num++;\n        sum += num;\n        num++;\n\n        //3.输出和\n        System.out.println(sum);\n    &#125;\n&#125;\n\n上述代码缺点：重复写的代码太多了\n解决：—》引入 java 中循环结构：\npublic class TestWhile&#123;\n    public static void main(String[] args)&#123;\n        //功能：1+2+3+4+5\n        //1.定义变量：\n        int num = 1;**[1]条件初始化**\n            //2.定义一个求和变量，用来接收和：\n            int sum = 0;\n        while(num\\&lt;=5)&#123;**[2]条件判断**\n            sum += num;**[3]循环体**\n                num++;**[4]迭代**\n                      &#125;\n        //3.输出和\n        System.out.println(sum);\n    &#125;\n&#125;\n\n总结：\n【1】循环作用：将部分代码重复执行。\n循环只是提高了程序员编写代码的效率，但是底层执行的时候依然是重复执行。\n【2】循环四要素：\n\n初始化谁，就判断谁，判断谁，就迭代谁\n执行过程：[1][2][3][4] [2][3][4] [2][3][4]。。。。\n【3】循环的执行过程：\n\n【4】验证循环的执行过程：\n\n# 练习\n【1】1+2+3+4+5+。。。。+100\n【2】2+4+6+8+。。。。+998+1000\n【3】5+10+15+20+。。。+100\n【4】99+97+95+。。5+3+1\n【5】1*3*5*7*9*11*13\npublic class TestWhile02&#123;\n    public static void main(String[] args)&#123;\n        /\\*\n            【1】1+2+3+4+5+。。。。+100\n            int i = 1;\n        int sum = 0;\n        while(i\\&lt;=100)&#123;\n            sum += i;\n            i++;\n        &#125;\n        System.out.println(sum);\n        【2】2+4+6+8+。。。。+998+1000\n            int i = 2;\n        int sum = 0;\n        while(i\\&lt;=1000)&#123;\n            sum += i;\n            i = i+2;\n        &#125;\n        System.out.println(sum);\n        【3】5+10+15+20+。。。+100\n            int i = 5;\n        int sum = 0;\n        while(i\\&lt;=100)&#123;\n            sum += i;\n            i = i+5;\n        &#125;\n        System.out.println(sum);\n\n        【4】99+97+95+。。5+3+1\n            int i = 99;\n        int sum = 0;\n        while(i\\>=1)&#123;\n            sum += i;\n            i = i-2;\n        &#125;\n        System.out.println(sum);\n        【5】1\\*3\\*5\\*7\\*9\\*11\\*13\n\n            \\*/\n            int i = 1;\n        int result = 1;\n        while(i\\&lt;=13)&#123;\n            result \\*= i;\n            i = i+2;\n        &#125;\n        System.out.println(result);\n    &#125;\n&#125;\n\n# do-while\n【1】语法结构：\n\n\n\ndo {循环体；} while (布尔表达式) ;\n\n\n\ndo-while 循环结构会先执行循环体，然后再判断布尔表达式的值，若条件为真，执行循环体，当条件为假时结束循环。do-while 循环的循环体至少执行一次。do-while 循环结构流程图如图所示：\n\n【2】代码：\npublic class TestDoWhile&#123;\n    public static void main(String[] args)&#123;\n        //1+2+3+4+...100\n        //while方式:\n        /\\*\n            int i = 101;\n        int sum = 0;\n        while(i\\&lt;=100)&#123;\n            sum += i;\n            i++;\n        &#125;\n        System.out.println(i);//101\n        System.out.println(sum);//0\n        \\*/\n            //do-while方式：\n\n            int i = 101;\n        int sum = 0;\n        do&#123;\n            sum += i;\n            i++;\n        &#125;while(i\\&lt;=100);//一定要注意写这个分号，否则编译出错\n        System.out.println(i);//102\n        System.out.println(sum);//101\n        /\\*\n            【1】while和do-while的区别:\n        while:先判断，再执行\n            do-while:先执行，再判断---》至少被执行一次，从第二次开始才进行判断\n                【2】什么场合使用do-while:\n\n        while(考试是否通过)&#123;\n            考试；\n        &#125;\n        \\---》不合适\n            do&#123;\n                考试；\n            &#125;while(考试是否通过);\n        \\---》合适\n            \\*/\n\n    &#125;\n&#125;\n\n# for\n【1】语法结构：\n\n\n\nfor (初始表达式；布尔表达式；迭代因子)\n\n\n\nfor 循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。for 循环在第一次反复之前要进行初始化，即执行初始表达式；随后，对布尔表达式进行判定，若判定结果为 true，则执行循环体，否则，终止循环；最后在每一次反复的时候，进行某种形式的 “步进”，即执行迭代因子。\n\n初始化部分设置循环变量的初值\n条件判断部分为任意布尔表达式\n迭代因子控制循环变量的增减\n\nfor 循环在执行条件判定后，先执行的循环体部分，再执行步进。\nfor 循环结构的流程图如图所示：\n\n【2】代码：\npublic class TestFor01&#123;\n    public static void main(String[] args)&#123;\n        //1+2+3+..+100\n        //while:\n        /\\*int i = 1;\n        int sum = 0;\n        while(i\\&lt;=100)&#123;\n            sum += i;\n            i++;\n        &#125;\n        System.out.println(sum);\n        \\*/\n\n            //for:\n            int sum = 0;\n        int i;\n        for(i = 1;i\\&lt;=100;i++)&#123;\n            sum += i;\n        &#125;\n        System.out.println(sum);\n        System.out.println(i);\n\n        /\\*\n            【1】for的结构：\n            for(条件初始化;条件判断;迭代)&#123;\n                循环体；\n            &#125;\n\n        【2】i的作用域：作用范围：离变量最近&#123;&#125; ---\\>可以自己去控制\n            【3】for循环格式特别灵活：格式虽然很灵活，但是我们自己写代码的时候不建议灵活着写。\n            for(;;)&#123;&#125; --\\>死循环\n\n                int i = 1;\n        for(;i\\&lt;=100;)&#123;\n            sum += i;\n            i++;\n        &#125;\n\n        【4】死循环：\n            for(;;)&#123;&#125;\n\n        while(true)&#123;&#125;\n\n        do&#123;\n\n        &#125;while(true);\n\n        【5】循环分为两大类：\n            第一类：当型 while()&#123;&#125; for(;;)&#123;&#125;\n        第二类：直到型 do&#123;&#125;while();\n\n        【6】以后常用：for循环\n            【7】do-while,while,for循环谁的效率高？ 一样高\n                \\*/\n                &#125;\n&#125;\n\n# 关键字\n在任何循环语句的主体部分，均可用 break 控制循环的流程。break 用于强行退出循环，不执行循环中剩余的语句。\ncontinue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。\nreturn 的作用，结束当前所在方法的执行.\n# break\n【1】通过练习感受 break 的作用：作用：停止循环：\npublic class TestFor02&#123;\n    public static void main(String[] args)&#123;\n        //功能：求1-100的和，当和第一次超过300的时候，停止程序\n        int sum = 0;\n        for(int i=1;i\\&lt;=100;i++)&#123;\n            sum += i;\n            if(sum\\>300)&#123;//当和第一次超过300的时候\n                //停止循环\n                break;//停止循环\n            &#125;\n            System.out.println(sum);\n        &#125;\n\n    &#125;\n&#125;\n\n【2】加深理解：\npublic class TestFor03&#123;\n    public static void main(String[] args)&#123;\n        //break的作用：停止最近的循环\n        /\\*\n            for(int i=1;i\\&lt;=100;i++)&#123;\n                System.out.println(i);\n                if(i==36)&#123;\n                    break;//1-36\n                &#125;\n            &#125;\n        \\*/\n            for(int i=1;i\\&lt;=100;i++)&#123;\n                System.out.println(i);\n                while(i==36)&#123;\n                    break; //1-100 ---》break停止的是while循环，而不是外面的for循环\n                &#125;\n            &#125;\n    &#125;\n&#125;\n\n【3】break 带标签的使用：\npublic class TestFor04&#123;\n    public static void main(String[] args)&#123;\n        outer: ----》定义标签结束的位置\n            for(int i=1;i\\&lt;=100;i++)&#123;\n                System.out.println(i);\n                while(i==36)&#123;\n                    break outer; ----》根据标签来结束循环\n                &#125;\n            &#125;\n    &#125;\n&#125;\n\n多层循环也可以使用标签，按照自己的需求去设定即可：\n\n# continue\n【1】通过案例感受 continue 的作用：结束本次循环，继续下一次循环\npublic class TestFor05&#123;\n    public static void main(String[] args)&#123;\n        //功能：输出1-100中被6整除的数：\n        //方式1：\n        /\\*\n            for(int i=1;i\\&lt;=100;i++)&#123;\n                if(i%6==0)&#123;//被6整除\n                    System.out.println(i);\n                &#125;\n            &#125;\n        \\*/\n\n            //方式2：\n            for(int i=1;i\\&lt;=100;i++)&#123;\n                if(i%6!=0)&#123;//不被6整除\n                    continue;//停止本次循环，继续下一次循环\n                &#125;\n                System.out.println(i);\n            &#125;\n    &#125;\n&#125;\n\n【2】加深理解：\npublic class TestFor06&#123;\n    public static void main(String[] args)&#123;\n        //continue:结束本次离它近的循环，继续下一次循环\n        /\\*\n            for(int i=1;i\\&lt;=100;i++)&#123;\n                if(i==36)&#123;\n                    continue;//1-100中间没有36\n                &#125;\n                System.out.println(i);\n            &#125;\n        \\*/\n\n            for(int i=1;i\\&lt;=100;i++)&#123;\n                while(i==36)&#123;\n                    System.out.println(\"------\");\n                    continue; //1-35+死循环\n                &#125;\n                System.out.println(i);\n            &#125;\n    &#125;\n&#125;\n\n【3】continue 带标签的使用：\npublic class TestFor07&#123;\n    public static void main(String[] args)&#123;\n\n        outer:\n        for(int i=1;i\\&lt;=100;i++)&#123;\n            while(i==36)&#123;\n                continue outer; //1-100没有36\n            &#125;\n            System.out.println(i);\n        &#125;\n    &#125;\n&#125;\n\n\n# return\nreturn 的作用：跟循环无关，就是程序中遇到 return 那么 return 所在的那个方法就停止执行了：\npublic class TestFor08&#123;\n    public static void main(String[] args)&#123;\n        //return:遇到return结束当前正在执行的方法\n        for(int i=1;i\\&lt;=100;i++)&#123;\n            while(i==36)&#123;\n                return;\n            &#125;\n            System.out.println(i);\n        &#125;\n\n        System.out.println(\"-----\");\n    &#125;\n&#125;\n\n# 循环练习\n【1】练习 1：\npublic class TestFor09&#123;\n    public static void main(String[] args)&#123;\n        /\\* 输出1-100中被5整除的数,每行输出6个\\*/\n            //引入一个计数器：\n            int count = 0;//初始值为0\n        for(int i=1;i\\&lt;=100;i++)&#123;\n            if(i%5==0)&#123;//被5整除的数\n                System.out.print(i+\"\\\\t\");\n                count++;//每在控制台输出一个数，count就加1操作\n                if(count%6==0)&#123;\n                    System.out.println();//换行\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n【2】练习 2：\nimport java.util.Scanner;\npublic class TestFor10&#123;\n    public static void main(String[] args)&#123;\n        /\\*\n            实现一个功能：\n            【1】请录入10个整数，当输入的数是666的时候，退出程序。\n            【2】判断其中录入正数的个数并输出。\n            【3】判断系统的退出状态：是正常退出还是被迫退出。\n            \\*/\n            //引入一个计数器：\n            int count = 0;\n        //引入一个布尔类型的变量：\n        boolean flag = true; //---》理解为一个“开关”，默认情况下开关是开着的\n        Scanner sc = new Scanner(System.in);\n        for(int i=1;i\\&lt;=10;i++)&#123;//i:循环次数\n            System.out.println(\"请录入第\"+i+\"个数：\");\n            int num = sc.nextInt();\n            if(num\\>0)&#123;//录入的正数\n                count++;\n            &#125;\n            if(num==666)&#123;\n                flag = false;//当遇到666的时候，“开关”被关上了\n                //退出循环：\n                break;\n            &#125;\n\n        &#125;\n\n        System.out.println(\"你录入的正数的个数为：\"+count);\n\n\n        if(flag)&#123;//flag==true\n            System.out.println(\"正常退出！\");\n        &#125;else&#123;//flag==false\n            System.out.println(\"被迫退出！\");\n        &#125;\n\n\n\n    &#125;\n&#125;\n\n# 循环的嵌套使用\n# 双重循环\n乘法口诀\n乘法口诀：\n1*1=1\n1*2=2 2*2=4\n1*3=3 2*3=6 3*3=9\n1*4=4 2*4=8 3*4=12 4*4=16\n1*5=5 2*5=10 3*5=15 4*5=20 5*5=25\n1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36\n1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49\n1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64\n1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81\n代码：\npublic class TestFor11&#123;\n    public static void main(String[] args)&#123;\n        //1\\*6=6 2\\*6=12 3\\*6=18 4\\*6=24 5\\*6=30 6\\*6=36\n        /\\*\n            System.out.print(\"1\\*6=6\"+\"\\\\t\");\n        System.out.print(\"2\\*6=12\"+\"\\\\t\");\n        System.out.print(\"3\\*6=18\"+\"\\\\t\");\n        System.out.print(\"4\\*6=24\"+\"\\\\t\");\n        System.out.print(\"5\\*6=30\"+\"\\\\t\");\n        System.out.print(\"6\\*6=36\"+\"\\\\t\");\n\n        for(int i=1;i\\&lt;=6;i++)&#123;\n            System.out.print(i+\"\\*6=\"+i\\*6+\"\\\\t\");\n        &#125;\n        //换行\n        System.out.println();\n\n        //1\\*7=7 2\\*7=14 3\\*7=21 4\\*7=28 5\\*7=35 6\\*7=42 7\\*7=49\n        for(int i=1;i\\&lt;=7;i++)&#123;\n            System.out.print(i+\"\\*7=\"+i\\*7+\"\\\\t\");\n        &#125;\n        //换行\n        System.out.println();\n\n        //1\\*8=8 2\\*8=16 3\\*8=24 4\\*8=32 5\\*8=40 6\\*8=48 7\\*8=56 8\\*8=64\n        for(int i=1;i\\&lt;=8;i++)&#123;\n            System.out.print(i+\"\\*8=\"+i\\*8+\"\\\\t\");\n        &#125;\n        //换行\n        System.out.println();\n        \\*/\n\n            for(int j=1;j\\&lt;=9;j++)&#123;\n                for(int i=1;i\\&lt;=j;i++)&#123;\n                    System.out.print(i+\"\\*\"+j+\"=\"+i\\*j+\"\\\\t\");\n                &#125;\n                //换行\n                System.out.println();\n            &#125;\n    &#125;\n&#125;\n\n1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81\n1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64\n1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49\n1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36\n1*5=5 2*5=10 3*5=15 4*5=20 5*5=25\n1*4=4 2*4=8 3*4=12 4*4=16\n1*3=3 2*3=6 3*3=9\n1*2=2 2*2=4\n1*1=1\n代码：\npublic class TestFor12&#123;\n    public static void main(String[] args)&#123;\n\n        /\\*\n            //1\\*8=8 2\\*8=16 3\\*8=24 4\\*8=32 5\\*8=40 6\\*8=48 7\\*8=56 8\\*8=64\n            for(int i=1;i\\&lt;=8;i++)&#123;\n                System.out.print(i+\"\\*8=\"+i\\*8+\"\\\\t\");\n            &#125;\n        //换行\n        System.out.println();\n\n\n        //1\\*7=7 2\\*7=14 3\\*7=21 4\\*7=28 5\\*7=35 6\\*7=42 7\\*7=49\n        for(int i=1;i\\&lt;=7;i++)&#123;\n            System.out.print(i+\"\\*7=\"+i\\*7+\"\\\\t\");\n        &#125;\n        //换行\n        System.out.println();\n\n        //1\\*6=6 2\\*6=12 3\\*6=18 4\\*6=24 5\\*6=30 6\\*6=36\n        for(int i=1;i\\&lt;=6;i++)&#123;\n            System.out.print(i+\"\\*6=\"+i\\*6+\"\\\\t\");\n        &#125;\n        //换行\n        System.out.println();\n\n\n\n\n        \\*/\n\n            for(int j=9;j\\>=1;j--)&#123;\n                for(int i=1;i\\&lt;=j;i++)&#123;\n                    System.out.print(i+\"\\*\"+j+\"=\"+i\\*j+\"\\\\t\");\n                &#125;\n                //换行\n                System.out.println();\n            &#125;\n    &#125;\n&#125;\n\n打印各种形状\n【1】长方形：\n\nfor(int j=1;j\\&lt;=4;j++)&#123;//j:控制行数\n    //\\*\\*\\*\\*\\*\\*\\*\\*\\*\n    for(int i=1;i\\&lt;=9;i++)&#123;//i:控制\\*的个数\n        System.out.print(\"\\*\");\n    &#125;\n    //换行：\n    System.out.println();\n&#125;\n【2】距离前面有一定空隙的长方形：\n\n\nfor (int j=1;j&lt;=4;j++){//j: 控制行数\n// 加入空格：\nfor (int i=1;i&lt;=5;i++){//i: 控制空格的个数\nSystem.out.print(&quot; &quot;);\n}\n//*********\nfor (int i=1;i&lt;=9;i++){//i: 控制 * 的个数\nSystem.out.print(&quot;*&quot;);\n}\n// 换行：\nSystem.out.println();\n}\n\n【3】平行四边形：\n\n\nfor (int j=1;j&lt;=4;j++){//j: 控制行数\n// 加入空格：\nfor (int i=1;i&lt;=(9-j);i++){//i: 控制空格的个数\nSystem.out.print(&quot; &quot;);\n}\n//*********\nfor (int i=1;i&lt;=9;i++){//i: 控制 * 的个数\nSystem.out.print(&quot;*&quot;);\n}\n// 换行：\nSystem.out.println();\n}\n\n【4】三角形：\n\n\nfor (int j=1;j&lt;=4;j++){//j: 控制行数\n// 加入空格：\nfor (int i=1;i&lt;=(9-j);i++){//i: 控制空格的个数\nSystem.out.print(&quot; &quot;);\n}\n//*********\nfor (int i=1;i&lt;=(2*j-1);i++){//i: 控制 * 的个数\nSystem.out.print(&quot;*&quot;);\n}\n// 换行：\nSystem.out.println();\n}\n\n【5】菱形：\n\n\n// 上面三角形：\nfor (int j=1;j&lt;=4;j++){//j: 控制行数\n// 加入空格：\nfor (int i=1;i&lt;=(9-j);i++){//i: 控制空格的个数\nSystem.out.print(&quot; &quot;);\n}\n//*********\nfor (int i=1;i&lt;=(2*j-1);i++){//i: 控制 * 的个数\nSystem.out.print(&quot;*&quot;);\n}\n// 换行：\nSystem.out.println();\n}\n\n// 下面三角形：\nfor (int j=1;j&lt;=3;j++){//j: 控制行数\n// 加入空格：\nfor (int i=1;i&lt;=(j+5);i++){//i: 控制空格的个数\nSystem.out.print(&quot; &quot;);\n}\n//*********\nfor (int i=1;i&lt;=(7-2*j);i++){//i: 控制 * 的个数\nSystem.out.print(&quot;*&quot;);\n}\n// 换行：\nSystem.out.println();\n}\n\n【6】空心菱形：\n\n\n// 上面三角形：\nfor (int j=1;j&lt;=4;j++){//j: 控制行数\n// 加入空格：\nfor (int i=1;i&lt;=(9-j);i++){//i: 控制空格的个数\nSystem.out.print(&quot; &quot;);\n}\n//*********\nfor (int i=1;i&lt;=(2*j-1);i++){//i: 控制 * 的个数\nif(i1||i(2*j-1)){\nSystem.out.print(&quot;*&quot;);\n}else{\nSystem.out.print(&quot; &quot;);\n}\n}\n// 换行：\nSystem.out.println();\n}\n\n// 下面三角形：\nfor (int j=1;j&lt;=3;j++){//j: 控制行数\n// 加入空格：\nfor (int i=1;i&lt;=(j+5);i++){//i: 控制空格的个数\nSystem.out.print(&quot; &quot;);\n}\n//*********\nfor (int i=1;i&lt;=(7-2*j);i++){//i: 控制 * 的个数\nif(i1||i(7-2*j)){\nSystem.out.print(&quot;*&quot;);\n}else{\nSystem.out.print(&quot; &quot;);\n}\n}\n// 换行：\nSystem.out.println();\n}\n\n扩展：菱形打印方式 2\n【1】实心菱形：\n\npublic class TestFor14&#123;\n    public static void main(String[] args)&#123;\n        //先打印出一个正方形，然后某些位置上打印\\* 某些位置上打印空格：\n        int size = 17;\n        int startNum = size/2+1;//起始列号\n        int endNum = size/2+1;//结束列号\n        //引入一个布尔类型的变量---》理解为“开关”\n        boolean flag = true;\n        for(int j=1;j\\&lt;=size;j++)&#123;\n            //\\*\\*\\*\\*\\*\n            for(int i=1;i\\&lt;=size;i++)&#123;\n                if(i\\>=startNum&amp;&amp;i\\&lt;=endNum)&#123;\n                    System.out.print(\"\\*\");\n                &#125;else&#123;\n                    System.out.print(\" \");\n                &#125;\n            &#125;\n            //换行\n            System.out.println();\n            if(endNum==size)&#123;\n                flag = false;\n            &#125;\n\n            if(flag)&#123;//flag是true相当于在菱形的上半侧 flag是false相当于在菱形的下半侧\n                startNum--;\n                endNum++;\n            &#125;else&#123;\n                startNum++;\n                endNum--;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n【2】空心菱形：\n\npublic class TestFor14&#123;\n    public static void main(String[] args)&#123;\n        //先打印出一个正方形，然后某些位置上打印\\* 某些位置上打印空格：\n        int size = 17;\n        int startNum = size/2+1;//起始列号\n        int endNum = size/2+1;//结束列号\n        //引入一个布尔类型的变量---》理解为“开关”\n        boolean flag = true;\n        for(int j=1;j\\&lt;=size;j++)&#123;\n            //\\*\\*\\*\\*\\*\n            for(int i=1;i\\&lt;=size;i++)&#123;\n                if(i==startNum\\|\\|i==endNum)&#123;\n                    System.out.print(\"\\*\");\n                &#125;else&#123;\n                    System.out.print(\" \");\n                &#125;\n            &#125;\n            //换行\n            System.out.println();\n            if(endNum==size)&#123;\n                flag = false;\n            &#125;\n\n            if(flag)&#123;//flag是true相当于在菱形的上半侧 flag是false相当于在菱形的下半侧\n                startNum--;\n                endNum++;\n            &#125;else&#123;\n                startNum++;\n                endNum--;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n# 三重循环\n百钱买百鸡\n【1】二重循环可以帮我们解决：二元一次方程组的问题：\npublic   class   TestFor15 &#123;\n    public   static   void   main (String[] args)&#123;\n        for ( int  a=1;a\\&lt;=5;a++)&#123;\n            for ( int  b=3;b\\&lt;=6;b++)&#123;\n                if (a+b==7)&#123;\n                    System. out .println(a+\"----\"+b);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n【2】三重循环可以帮我们解决：三元一次方程组的问题：\n","slug":"第4章_流程控制","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,流程控制","tags_index":"-JavaSE","author_index":"雾都"},{"id":"f1f69ca9615d50d9f4d1f372228160f6","title":"第5章_方法的定义_调用_重载","content":"# 方法的定义和调用\n【1】什么是方法？\n方法 (method) 就是一段用来完成特定功能的代码片段，类似于其它语言的函数 (function)。\n方法用于定义该类或该类的实例的行为特征和功能实现。 方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。\n【2】方法声明格式：\n\n\n\n[修饰符 1 修饰符 2 …] 返回值类型 方法名 (形式参数列表)\n\n\n\n【3】方法的调用方式：\n\n\n\n对象名。方法名 (实参列表)\n\n\n\n【4】方法的详细说明\n\n形式参数：在方法声明时用于接收外界传入的数据。\n实参：调用方法时实际传给方法的数据。\n返回值：方法在执行完毕后返还给调用它的环境的数据。\n返回值类型：事先约定的返回值的数据类型，如无返回值，必须显示指定为为 void。\n\n【5】代码：\npublic class TestMethod01&#123;\n\n    //方法的定义：（写方法）\n    public static int add(int num1,int num2)&#123;\n        int sum = 0;\n        sum += num1;\n        sum += num2;\n        return sum;//将返回值返回到方法的调用处\n    &#125;\n\n    public static void main(String[] args)&#123;\n        //10+20:\n        //方法的调用：（用方法）\n        int num = add(10,20);\n        System.out.println(num);\n        /\\*\n            int num1 = 10;\n        int num2 = 20;\n        int sum = 0;\n        sum += num1;\n        sum += num2;\n        System.out.println(sum);\n        \\*/\n            //30+90:\n            int sum = add(30,90);\n        System.out.println(sum);\n        /\\*\n            int num3 = 30;\n        int num4 = 90;\n        int sum1 = 0 ;\n        sum1 += num3;\n        sum1 += num4;\n        System.out.println(sum1);\n        \\*/\n            //50+48:\n            System.out.println(add(50,48));\n\n    &#125;\n\n\n&#125;\n\n【6】总结：\n1. 方法是：对特定的功能进行提取，形成一个代码片段，这个代码片段就是我们所说的方法\n2. 方法和方法是并列的关系，所以我们定义的方法不能写到 main 方法中\n3. 方法的定义–》格式：\n修饰符 方法返回值类型 方法名 (形参列表){\n方法体；\nreturn 方法返回值；\n}\n4. 方法的作用：提高代码的复用性\n5. 总结方法定义的格式：\n\n\n修饰符：暂时使用 public static —&gt; 面向对象一章讲解\n\n\n方法返回值类型：方法的返回值对应的数据类型\n\n\n数据类型： 可以是基本数据类型（byte,short,int,long,float,double,char,boolean） 也可以是引用数据类型\n\n\n方法名：见名知意，首字母小写，其余遵循驼峰命名， eg: addNum , 一般尽量使用英文来命名\n\n\n形参列表：方法定义的时候需要的形式参数 ： int num1, int num2 --&gt; 相当于告诉方法的调用者：需要传入几个参数，需要传入的参数的类型\n\n\n实际参数：方法调用的时候传入的具体的参数： 10,20 --&gt; 根据形式参数的需要传入的\n5) 方法体：具体的业务逻辑代码\n\nreturn 方法返回值；\n\n方法如果有返回值的话： return + 方法返回值，将返回值返回到方法的调用处\n方法没有返回值的话：return 可以省略不写了，并且方法的返回值类型为：void\npublic class TestMethod02&#123;\n\n    public static void add(int num1,int num2)&#123;\n        int sum = 0;\n        sum += num1;\n        sum += num2;\n        System.out.println(sum);\n        //return;\n    &#125;\n\n    public static void main(String[] args)&#123;\n        //10+20:\n        //方法的调用：（用方法）\n        add(10,20);\n        //30+90:\n        add(30,90);\n        //50+48:\n        //System.out.println(add(50,48));//报错：TestMethod02.java:22: 错误: 此处不允许使用 '空' 类型\n\n    &#125;\n\n&#125;\n\n什么时候有返回值，什么时候没有返回值？ 看心情–》看需求\n6. 方法的定义需要注意什么？\n1）形参列表要怎么写：定义几个参数，分别是什么类型的 —》不确定因素我们会当做方法的形参\n\n方法到底是否需要返回值 ，如果需要的话，返回值的类型是什么\n\n7. 方法的调用需要注意什么？\n1）实际参数要怎么传入：传入几个参数，传入什么类型的\n2） 方法是否有返回值需要接受\n# 练习\n【1】基本功能：\nimport java.util.Scanner;\npublic class TestMethod03&#123;\n    public static void main(String[] args)&#123;\n        //功能：我心里有一个数，你来猜，看是否猜对\n        //1.你猜一个数\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请你猜一个数：\");\n        int yourGuessNum = sc.nextInt();\n        //2.我心里有一个数\n        int myHeartNum = 5;\n        //3.将两个数比对：\n        System.out.println(yourGuessNum==myHeartNum?\"猜对了\":\"猜错了\");\n    &#125;\n&#125;\n\n对猜数功能提取为一个方法：\nimport java.util.Scanner;\npublic class TestMethod03&#123;\n    public static void main(String[] args)&#123;\n        //功能：我心里有一个数，你来猜，看是否猜对\n        //1.你猜一个数\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请你猜一个数：\");\n        int yourGuessNum = sc.nextInt();\n\n        //调用猜数的方法：\n        guessNum(yourGuessNum);\n    &#125;\n\n    //方法的定义：功能：实现猜数功能：\n    public static void guessNum(int yourNum)&#123;\n        //我心里有一个数(1-6)\n        int myHeartNum = (int)(Math.random()\\*6)+1;\n        //将两个数比对：\n        System.out.println(yourNum==myHeartNum?\"猜对了\":\"猜错了\");\n    &#125;\n&#125;\n\n# 面试题：两个数交换是否成功\n【1】面试题：请问下面代码中两个数是否交换成功：\n\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n结果：没有交换成功：\n\n原因：\n\n# 方法的重载\n【1】什么是方法的重载：\n方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法。 调用时，会根据不同的参数自动匹配对应的方法。\n注意本质：重载的方法，实际是完全不同的方法，只是名称相同而已！\n【2】构成方法重载的条件：\n❀不同的含义：形参类型、形参个数、形参顺序不同\n❀ 只有返回值不同不构成方法的重载\n如：int a (String str){} 与 void a (String str){} 不构成方法重载\n❀ 只有形参的名称不同，不构成方法的重载\n如：int a (String str){} 与 int a (String s){} 不构成方法重载\n【3】代码：\npublic class TestMethod05&#123;\n    public static void main(String[] args)&#123;\n        //10+20:\n        int sum = add(10,20);\n        System.out.println(sum);\n\n        //20+40+80:\n        //System.out.println(add(add(20,40),80));\n        System.out.println(add(20,40,80));\n        //30+60+90+120:\n        //System.out.println(add(add(30,60),add(90,120)));\n        System.out.println(add(30,60,90,120));\n        //9.8+4.7:\n        //System.out.println(add(9.8,4.7));\n        System.out.println(add(9.8,4.7));\n    &#125;\n\n    //定义一个方法：两个数相加：两个int类型数据相加\n    public static int add(int num1,int num2)&#123;\n        return num1+num2;\n    &#125;\n\n    //定义一个方法：三个数相加：\n    public static int add(int num1,int num2,int num3)&#123;\n        return num1+num2+num3;\n    &#125;\n\n    //定义一个方法：四个数相加：\n    public static int add(int num1,int num2,int num3,int num4)&#123;\n        return num1+num2+num3+num4;\n    &#125;\n    //定义一个方法：两个数相加：两个double类型的数据相加\n    public static double add(double num1,double num2)&#123;\n        return num1+num2;\n    &#125;\n\n\n&#125;\n\n总结：\n1. 方法的重载：在同一个类中，方法名相同，形参列表不同的多个方法，构成了方法的重载。\n2. 方法的重载只跟：方法名和形参列表有关，与修饰符，返回值类型无关。\n3. 注意：形参列表不同指的是什么？\n（1）个数不同\nadd() add(int num1) add(int num1,int num2)\n（2）顺序不同\nadd(int num1,double num2) add(double num1,int num2)\n（3）类型不同\nadd(int num1) add(double num1)\n4. 请问下面的方法是否构成了方法的重载？\n(1) add (int a) 和 add (int b) —&gt; 不构成，相当于方法的重复定义\n(2) public static int add (int a) 和 public static void add (int b) —&gt; 不构成\n【4】扩充：\npublic class TestMethod06&#123;\n    public static void main(String[] args)&#123;\n        add(5);\n        //级别：byte,short,char--\\>int--\\>long--\\>float---\\>double\n    &#125;\n    \n    public static void add(double num1)&#123;\n        System.out.println(\"------2\");\n    &#125;\n    public static void add(float num1)&#123;\n        System.out.println(\"------3\");\n    &#125;\n    public static void add(long num1)&#123;\n        System.out.println(\"------4\");\n    &#125;\n    /\\*\n        public static void add(int num1)&#123;\n        System.out.println(\"------1\");\n    &#125;\n    \\*/\n&#125;\n","slug":"第5章_方法的定义_调用_重载","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,方法的定义_调用_重载","tags_index":"JavaSE","author_index":"雾都"},{"id":"b0f2b0609a4c36e280aede31990da527","title":"第6章_数组","content":"# 数组的引入\n【1】习题引入：\nimport java.util.Scanner;\npublic class TestArray01&#123;\n    public static void main(String[] args)&#123;\n        //功能：键盘录入十个学生的成绩，求和，求平均数：\n        //定义一个求和的变量：\n        int sum = 0;\n        Scanner sc = new Scanner(System.in);\n\n        for(int i=1;i\\&lt;=10;i++)&#123;//i:控制循环次数\n            System.out.print(\"请录入第\"+i+\"个学生的成绩：\");\n            int score = sc.nextInt();\n            sum += score;\n        &#125;\n\n        System.out.println(\"十个学生的成绩之和为：\"+sum);\n        System.out.println(\"十个学生的成绩平均数为：\"+sum/10);\n\n        //本题的缺点：\n        //求第6个学生的成绩：？？？？？---》不能\n\n    &#125;\n&#125;\n\n缺点：就是不能求每个学生的成绩具体是多少\n解决：将成绩进行存储 ----》 引入 ： 数组\n感受到数组的作用：数组用来存储数据的，在程序设计中，为了处理方便，数组用来将相同类型的若干数据组织起来。\n这个若干数据的集合我们称之为数组。\n# 数组的学习\n【1】数组的定义\n数组是相同类型数据的有序集合。数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。其中，每一个数据称作一个元素，每个元素可以通过一个索引（下标）来访问它们。\n数组的四个基本特点：\n1. 长度是确定的。数组一旦被创建，它的大小就是不可以改变的。\n2. 其元素的类型必须是相同类型，不允许出现混合类型。\n3. 数组类型可以是任何数据类型，包括基本类型和引用类型。\n4. 数组有索引的：索引从 0 开始，到 数组.length-1 结束\n5. 数组变量属于引用类型，数组也是对象。\nPS: 数组变量属于引用类型，数组也是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java 中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。\n【2】数组的学习：\npublic class TestArray02&#123;\n    public static void main(String[] args)&#123;\n        //数组的作用：用来存储相同类型的数据\n        //以int类型数据为案例：数组用来存储int类型数据\n        //1.声明(定义数组)\n        int[] arr; //定义一个int类型的数组，名字叫arr\n        //int arr2[];\n        //如果数组只声明，没有后续操作，那么这个数组相当于没定义\n        //int[] arr3 = null;//空 辨别：数组赋值为null和什么都没有赋值 不一样的效果\n\n        //2.创建\n        arr = new int[4];//给数组开辟了一个长度为4的空间\n        //编译期声明和创建会被合为一句话: int[] arr = new int[4];\n\n        //3.赋值\n        arr[0] = 12;\n        arr[3] = 47;\n        arr[2] = 98;\n        arr[1] = 56;\n        arr[2] = 66;\n        /\\*\n            arr[4] = 93;\n        出现异常：Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 4\n            Array 数组\n            Index 索引\n            OutOf 超出\n            Bounds 界限\n            Exception 异常\n            \\---》数组索引越界异常\n            \\*/\n\n            //4.使用\n            System.out.println(arr[2]);\n        System.out.println(arr[0]+100);\n        //通过数组一个属性来获取 length 长度\n        System.out.println(\"数组的长度是：\"+arr.length);\n    &#125;\n&#125;\n\n# 内存分析\n\n# 完善引入的习题_数组的遍历\n【1】代码：\nimport java.util.Scanner;\npublic class TestArray03&#123;\n    public static void main(String[] args)&#123;\n        //功能：键盘录入十个学生的成绩，求和，求平均数：\n        //定义一个int类型的数组，长度为10 ：\n        int[] scores = new int[10];\n        //定义一个求和的变量：\n        int sum = 0;\n        Scanner sc = new Scanner(System.in);\n\n        for(int i=1;i\\&lt;=10;i++)&#123;//i:控制循环次数\n            System.out.print(\"请录入第\"+i+\"个学生的成绩：\");\n            int score = sc.nextInt();\n            scores[i-1] = score;\n            sum += score;\n        &#125;\n\n        System.out.println(\"十个学生的成绩之和为：\"+sum);\n        System.out.println(\"十个学生的成绩平均数为：\"+sum/10);\n\n\n        //求第6个学生的成绩：\n        //System.out.println(scores[5]);\n        /\\*\n            System.out.println(scores[0]);\n        System.out.println(scores[1]);\n        System.out.println(scores[2]);\n        System.out.println(scores[3]);\n        //....\n        System.out.println(scores[9]);\n        \\*/\n            //将数组中的每个元素进行查看--》数组的遍历：\n            //方式1：普通for循环---》正向遍历：\n            for(int i=0;i\\&lt;=9;i++)&#123;\n                System.out.println(\"第\"+(i+1)+\"个学生的成绩为：\"+scores[i]);\n            &#125;\n\n        //方式2：增强for循环:\n        //对scores数组进行遍历，遍历出来每个元素都用int类型的num接收：\n        int count = 0;\n        for(int num:scores)&#123;\n            count++;\n            //每次都将num在控制台输出\n            System.out.println(\"第\"+count+\"个学生的成绩为：\"+num);\n        &#125;\n\n        /\\*\n            增强for循环：\n            优点：代码简单\n            缺点：单纯的增强for循环不能涉及跟索引相关的操作\n            \\*/\n\n            //方式3：利用普通for循环： 逆向遍历：\n            for(int i=9;i\\>=0;i--)&#123;\n                System.out.println(\"第\"+(i+1)+\"个学生的成绩为：\"+scores[i]);\n            &#125;\n\n    &#125;\n&#125;\n\n【2】用 IDEA 验证数组的确将数据进行存储了：\n\n# 数组的三种初始化方式\n数组的初始化方式总共有三种：静态初始化、动态初始化、默认初始化。\n\n静态初始化\n\n除了用 new 关键字来产生数组以外，还可以直接在定义数组的同时就为数组元素分配空间并赋值。\neg:\nint[] arr = &#123;12,23,45&#125;;\n\nint[] arr = new int[]&#123;12,23,45&#125;;\n\n注意：\n\n1.new int[3]&#123;12,23,45&#125;;--\\>错误\n\n2.int[] arr ;\n\narr = &#123;12,23,45&#125;; ---\\>错误\n\n动态初始化\n\n数组定义与为数组元素分配空间并赋值的操作分开进行。\neg:\nint[] arr ;\n\narr = new int[3]\n\narr[0] = 12;\n\narr[1] = 23;\n\narr[2] = 45;\n\n默认初始化\n\n数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。\nint [] arr = new int [3]; —&gt; 数组有默认的初始化值\n\n# 数组的应用题\n# 最值问题\n【1】实现一个功能：给定一个数组 int [] arr = {12,3,7,4,8,125,9,45}; ，求出数组中最大的数。\n思路图：\n\npublic class TestArray04&#123;\n    public static void main(String[] args)&#123;\n        //实现一个功能：给定一个数组int[] arr = &#123;12,3,7,4,8,125,9,45&#125;; ，求出数组中最大的数。\n        //1.给定一个数组\n        int[] arr = &#123;12,3,7,4,8,125,9,45,666,36&#125;;\n\n        //2.求出数组中的最大值：\n        //先找一个数上擂台，假定认为这个数最大：\n        int maxNum = arr[0];\n        for(int i=0;i\\&lt;arr.length;i++)&#123;\n            if(arr[i]\\>maxNum)&#123;\n                maxNum = arr[i];\n            &#125;\n        &#125;\n        System.out.println(\"当前数组中最大的数为：\"+maxNum);\n\n    &#125;\n&#125;\n\n【2】将求最大值的方法提取出来：\npublic class TestArray04&#123;\n    public static void main(String[] args)&#123;\n        //实现一个功能：给定一个数组int[] arr = &#123;12,3,7,4,8,125,9,45&#125;; ，求出数组中最大的数。\n        //1.给定一个数组\n        int[] arr = &#123;12,3,7,4,8,725,9,45,666,36&#125;;\n\n        //2.求出数组中的最大值：\n        //调用方法：\n        int num = getMaxNum(arr);\n        System.out.println(\"当前数组中最大的数为：\"+num);\n    &#125;\n\n    /\\*\n        想提取一个方法：求数组中的最大值\n        求哪个数组中的最大值 ---》不确定因素：哪个数组 (形参)---》返回值：最大值\n        \\*/\n        public static int getMaxNum(int[] arr)&#123;\n        //先找一个数上擂台，假定认为这个数最大：\n        int maxNum = arr[0];\n        for(int i=0;i\\&lt;arr.length;i++)&#123;\n            if(arr[i]\\>maxNum)&#123;\n                maxNum = arr[i];\n            &#125;\n        &#125;\n        return maxNum;\n\n    &#125;\n&#125;\n\n【3】画内存：\n方法的实参传递给形参的时候一定要注意：一切都是值传递：\n如果是基本数据类型，那么传递的就是字面值\n如果是引用数据类型，那么传递的就是地址值\n\n# 查询问题\n【1】查询指定位置的元素\npublic class TestArray05&#123;\n    public static void main(String[] args)&#123;\n        //查询指定位置的元素\n        //给定一个数组：\n        int[] arr = &#123;12,34,56,7,3,10&#125;;\n        //查找索引为2的位置上对应的元素是什么？\n        System.out.println(arr[2]);\n    &#125;\n&#125;\n\n上面代码体现了数组的一个优点：\n在按照位置查询的时候，直接一步到位，效率非常高\n【2】查询指定元素的位置–》找出元素对应的索引\npublic class TestArray06&#123;\n    public static void main(String[] args)&#123;\n        //查询指定元素的位置--》找出元素对应的索引\n        //给定一个数组：\n        int[] arr = &#123;12,34,56,7,3,56&#125;;\n        // 0 1 2 3 4 5\n\n        //功能：查询元素888对应的索引：\n        int index = -1; //这个初始值只要不是数组的索引即可\n        for(int i=0;i\\&lt;arr.length;i++)&#123;\n            if(arr[i]==12)&#123;\n                index = i;//只要找到了元素，那么index就变成为i\n                break;//只要找到这个元素，循环就停止\n            &#125;\n        &#125;\n        if(index!=-1)&#123;\n            System.out.println(\"元素对应的索引：\"+index);\n        &#125;else&#123;//index==-1\n            System.out.println(\"查无次数！\");\n        &#125;\n    &#125;\n&#125;\n\n【3】将查指定元素对应的索引的功能提取为方法：\npublic class TestArray06&#123;\n    public static void main(String[] args)&#123;\n        //查询指定元素的位置--》找出元素对应的索引\n        //给定一个数组：\n        int[] arr = &#123;12,34,56,7,3,56&#125;;\n        // 0 1 2 3 4 5\n\n        //功能：查询元素888对应的索引：\n        //调用方法：\n        int index = getIndex(arr,999);\n        //后续对index的值进行判断：\n        if(index!=-1)&#123;\n            System.out.println(\"元素对应的索引：\"+index);\n        &#125;else&#123;//index==-1\n            System.out.println(\"查无次数！\");\n        &#125;\n    &#125;\n\n    /\\*\n        定义一个方法：查询数组中指定的元素对应的索引：\n        不确定因素：哪个数组，哪个指定元素 （形参）\n        返回值：索引\n\n        \\*/\n        public static int getIndex(int[] arr,int ele)&#123;\n        int index = -1; //这个初始值只要不是数组的索引即可\n        for(int i=0;i\\&lt;arr.length;i++)&#123;\n            if(arr[i]==ele)&#123;\n                index = i;//只要找到了元素，那么index就变成为i\n                break;//只要找到这个元素，循环就停止\n            &#125;\n        &#125;\n        return index;\n    &#125;\n&#125;\n\n# 添加元素\n【1】实现一个功能：\n添加逻辑：\n\npublic class TestArray07&#123;\n    public static void main(String[] args)&#123;\n        //功能：给定一个数组,在数组下标为2的位置上添加一个元素91\n\n        //1.给定一个数组：\n        int[] arr = &#123;12,34,56,7,3,10,55,66,77,88,999,89&#125;;\n        // 0 1 2 3 4 5\n        //2.输出增加元素前的数组：\n        System.out.print(\"增加元素前的数组：\");\n        for(int i=0;i\\&lt;arr.length;i++)&#123;\n            if(i!=arr.length-1)&#123;\n                System.out.print(arr[i]+\",\");\n            &#125;else&#123;//i==arr.length-1 最后一个元素不用加,\n                System.out.print(arr[i]);\n            &#125;\n        &#125;\n\n        //3.增加元素\n        /\\*\n            arr[5] = arr[4];\n        arr[4] = arr[3];\n        arr[3] = arr[2];\n        \\*/\n            int index = 1;//在这个指定位置添加 元素\n        for(int i=arr.length-1;i\\>=(index+1);i--)&#123;\n            arr[i] = arr[i-1];\n        &#125;\n        arr[index] = 666;\n\n\n        //4.输出增加元素后的数组：\n        System.out.print(\"\\\\n增加元素后的数组：\");\n        for(int i=0;i\\&lt;arr.length;i++)&#123;\n            if(i!=arr.length-1)&#123;\n                System.out.print(arr[i]+\",\");\n            &#125;else&#123;//i==arr.length-1 最后一个元素不用加,\n                System.out.print(arr[i]);\n            &#125;\n        &#125;\n\n    &#125;\n&#125;\n\n【2】将添加功能提取为一个 方法：\nimport java.util.Scanner;\npublic class TestArray07&#123;\n    public static void main(String[] args)&#123;\n        //功能：给定一个数组,在数组下标为2的位置上添加一个元素91\n\n        //1.给定一个数组：\n        int[] arr = &#123;12,34,56,7,3,10,55,66,77,88,999,89&#125;;\n        // 0 1 2 3 4 5\n        //2.输出增加元素前的数组：\n        /\\*\n            System.out.print(\"增加元素前的数组：\");\n        for(int i=0;i\\&lt;arr.length;i++)&#123;\n            if(i!=arr.length-1)&#123;\n                System.out.print(arr[i]+\",\");\n            &#125;else&#123;//i==arr.length-1 最后一个元素不用加,\n                System.out.print(arr[i]);\n            &#125;\n        &#125;\n        \\*/\n\n            //从键盘接收数据：\n            Scanner sc = new Scanner(System.in);\n        System.out.println(\"请录入你要添加元素的指定下标：\");\n        int index = sc.nextInt();\n        System.out.println(\"请录入你要添加的元素：\");\n        int ele = sc.nextInt();\n\n        //3.增加元素\n        //调用方法：\n        insertEle(arr,index,ele);\n\n\n\n        //4.输出增加元素后的数组：\n        System.out.print(\"\\\\n增加元素后的数组：\");\n        for(int i=0;i\\&lt;arr.length;i++)&#123;\n            if(i!=arr.length-1)&#123;\n                System.out.print(arr[i]+\",\");\n            &#125;else&#123;//i==arr.length-1 最后一个元素不用加,\n                System.out.print(arr[i]);\n            &#125;\n        &#125;\n\n    &#125;\n\n\n    /\\*\n        提取一个添加元素的方法：\n        在数组的指定位置上添加一个指定的元素。\n        在哪个数组的哪个位置添加哪个元素！\n        不确定因素：形参：哪个数组，哪个位置，哪个元素\n        返回值：无\n\n        \\*/\n        public static void insertEle(int[] arr,int index,int ele)&#123;\n        for(int i=arr.length-1;i\\>=(index+1);i--)&#123;\n            arr[i] = arr[i-1];\n        &#125;\n        arr[index] = ele;\n    &#125;\n&#125;\n\n# 删除元素\n【1】实现一个功能：删除指定位置上的元素\n逻辑：\n\nimport java.util.Arrays;\npublic class TestArray08&#123;\n    public static void main(String[] args)&#123;\n        //功能：给定一个数组,删除下标为2元素\n\n        //1.给定一个数组：\n        int[] arr = &#123;12,34,56,7,3,10,34,45,56,7,666&#125;;\n        // 0 1 2 3 4 5\n        //2.输出删除前的数组：\n        System.out.println(\"删除元素前的数组：\"+Arrays.toString(arr));\n\n        //3.删除\n        /\\*\n            arr[2] = arr[3];\n        arr[3] = arr[4];\n        arr[4] = arr[5];\n        \\*/\n            int index = 0;\n        for(int i=index;i\\&lt;=arr.length-2;i++)&#123;\n            arr[i] = arr[i+1];\n        &#125;\n        arr[arr.length-1] = 0;\n\n        //4.输出删除后的数组：\n        System.out.println(\"删除元素后的数组：\"+Arrays.toString(arr));\n    &#125;\n&#125;\n\n【2】实现一个功能：删除指定元素\nimport java.util.Arrays;\npublic class TestArray09&#123;\n    public static void main(String[] args)&#123;\n        //功能：给定一个数组,删除元素3：\n\n        //1.给定一个数组：\n        int[] arr = &#123;12,34,56,7,3,10,34,45,56,7,666&#125;;\n\n        //2.输出删除前的数组：\n        System.out.println(\"删除元素前的数组：\"+Arrays.toString(arr));\n\n\n        //找到要删除的元素对应的索引即可：\n        int index = -1 ;\n        for(int i=0;i\\&lt;arr.length;i++)&#123;\n            if(arr[i]==1200)&#123;\n                index = i;\n                break;\n            &#125;\n        &#125;\n\n        //3.删除\n\n        if(index!=-1)&#123;\n            for(int i=index;i\\&lt;=arr.length-2;i++)&#123;\n                arr[i] = arr[i+1];\n            &#125;\n            arr[arr.length-1] = 0;\n        &#125;else&#123;//index==-1\n            System.out.println(\"根本没有你要删除的元素！\");\n        &#125;\n\n\n        //4.输出删除后的数组：\n        System.out.println(\"删除元素后的数组：\"+Arrays.toString(arr));\n    &#125;\n&#125;\n\n# 详述 main 方法\n【1】main 方法：程序的入口，在同一个类中，如果有多个方法，那么虚拟机就会识别 main 方法，从这个方法作为程序的入口\n【2】main 方法格式严格要求：\npublic static void main(String[] args){}\npublic static —&gt; 修饰符 ，暂时用这个 --&gt; 面向对象一章\nvoid —&gt; 代表方法没有返回值 对应的类型 void\nmain —&gt; 见名知意名字\nString [] args —&gt; 形参 —》不确定因素\n【3】问题：程序中是否可以有其他的方法也叫 main 方法？\n可以，构成了方法的重载。\npublic class TestArray10&#123;\n    public static void main(String[] args)&#123;\n\n    &#125;\n    public static void main(String str)&#123;\n\n    &#125;\n&#125;\n\n【4】形参为 String [] 那么实参到底是什么？\npublic class TestArray10&#123;\n    public static void main(String[] args)&#123;\n        //从侧面验证：\n        //int[] arr1; //如果对数组只声明，没有后续操作，那么相当于 白定义了。\n        //int[] arr2 = null;\n        //System.out.println(arr2.length);//Exception in thread \"main\" java.lang.NullPointerException\n        //int[] arr3 = new int[0];\n        //System.out.println(arr3.length);\n        //int[] arr4 = new int[4];\n        //System.out.println(arr4.length);\n\n        //System.out.println(args.length);//0\n        //从这个结果证明，参数是String[],实参是 new String[0]\n        //默认情况下，虚拟机在调用main方法的时候就是传入了一个长度为0的数组\n\n        System.out.println(args.length);\n        for(String str:args)&#123;\n            System.out.println(str);\n        &#125;\n    &#125;\n&#125;\n\n手动传入实参：\n有特殊符号的时候可以加上 “”\n\n没有特殊符号用空格隔开即可：\n\n# 可变参数\npublic class TestArray12&#123;\n    /\\*\n        1.可变参数：作用提供了一个方法，参数的个数是可变的 ,解决了部分方法的重载问题\n        int...num\n        double...num\n        boolean...num\n\n\n        2.可变参数在JDK1.5之后加入的新特性\n        3.方法的内部对可变参数的处理跟数组是一样\n        4.可变参数和其他数据一起作为形参的时候，可变参数一定要放在最后\n        5.我们自己在写代码的时候，建议不要使用可变参数。\n        \\*/\n        public static void main(String[] args)&#123;\n        //method01(10);\n        //method01();\n        //method01(20,30,40);\n        method01(30,40,50,60,70);\n        //method01(new int[]&#123;11,22,33,44&#125;);\n    &#125;\n    public static void method01(int num2,int...num)&#123;\n        System.out.println(\"-----1\");\n        for(int i:num)&#123;\n            System.out.print(i+\"\\\\t\");\n        &#125;\n        System.out.println();\n\n        System.out.println(num2);\n    &#125;\n&#125;\n\n# Arrays 工具类\n为了方便我们对数组进行操作，系统提供一个类 Arrays，我们将它当做工具类来使用。\nimport java.util.Arrays;\npublic class TestArray13&#123;\n    public static void main(String[] args)&#123;\n        //给定一个数组：\n        int[] arr = &#123;1,3,7,2,4,8&#125;;\n        //toString:对数组进行遍历查看的，返回的是一个字符串，这个字符串比较好看\n        System.out.println(Arrays.toString(arr));\n\n        //binarySearch:二分法查找：找出指定数组中的指定元素对应的索引：\n        //这个方法的使用前提：一定要查看的是一个有序的数组：\n        //sort：排序 --\\>升序\n        Arrays.sort(arr);\n        System.out.println(Arrays.toString(arr));\n        System.out.println(Arrays.binarySearch(arr,4));\n\n        int[] arr2 = &#123;1,3,7,2,4,8&#125;;\n        //copyOf:完成数组的复制：\n        int[] newArr = Arrays.copyOf(arr2,4);\n        System.out.println(Arrays.toString(newArr));\n\n        //copyOfRange:区间复制：\n        int[] newArr2 = Arrays.copyOfRange(arr2,1,4);//[1,4)--\\>1,2,3位置\n        System.out.println(Arrays.toString(newArr2));\n\n        //equals:比较两个数组的值是否一样：\n        int[] arr3 = &#123;1,3,7,2,4,8&#125;;\n        int[] arr4 = &#123;1,3,7,2,4,8&#125;;\n        System.out.println(Arrays.equals(arr3,arr4));//true\n        System.out.println(arr3==arr4);//false ==比较左右两侧的值是否相等，比较的是左右的地址值，返回结果一定是false\n\n        //fill：数组的填充：\n        int[] arr5 = &#123;1,3,7,2,4,8&#125;;\n        Arrays.fill(arr5,10);\n        System.out.println(Arrays.toString(arr5));\n    &#125;\n&#125;\n\n# 数组的复制操作\n\n\n原理：\n\n代码：\nimport java.util.Arrays;\npublic class TestArray14&#123;\n    public static void main(String[] args)&#123;\n        //给一个源数组：\n        int[] srcArr = &#123;11,22,33,44,55,66,77,88&#125;;\n        //给一个目标数组：\n        int[] destArr = new int[10];\n\n        //复制：\n        System.arraycopy(srcArr,1,destArr,3,3);\n        //遍历查看目标数组：\n        System.out.println(Arrays.toString(destArr));\n    &#125;\n\n&#125;\n\n结果：\n\n# 二维数组\n【1】引入：本质上全部都是一维数组：\n\n【2】基本代码：\npublic class TestArray15&#123;\n    public static void main(String[] args)&#123;\n        //定义一个二维数组：\n        int[][] arr = new int[3][];//本质上定义了一个一维数组，长度为3\n\n        int[] a1 = &#123;1,2,3&#125;;\n        arr[0] = a1;\n\n        arr[1] = new int[]&#123;4,5,6,7&#125;;\n\n        arr[2] = new int[]&#123;9,10&#125;;\n\n    &#125;\n&#125;\n\n对应内存：\n\n【3】四种遍历方式：\npublic class TestArray15&#123;\n    public static void main(String[] args)&#123;\n        //定义一个二维数组：\n        int[][] arr = new int[3][];//本质上定义了一个一维数组，长度为3\n\n        int[] a1 = &#123;1,2,3&#125;;\n        arr[0] = a1;\n\n        arr[1] = new int[]&#123;4,5,6,7&#125;;\n\n        arr[2] = new int[]&#123;9,10&#125;;\n\n        //读取6这个元素：\n        //System.out.println(arr[1][2]);\n\n        //对二维数组遍历：\n        //方式1：外层普通for循环+内层普通for循环：\n        for(int i=0;i\\&lt;arr.length;i++)&#123;\n            for(int j=0;j\\&lt;arr[i].length;j++)&#123;\n                System.out.print(arr[i][j]+\"\\\\t\");\n            &#125;\n            System.out.println();\n        &#125;\n\n        //方式2：外层普通for循环+内层增强for循环：\n        for(int i=0;i\\&lt;arr.length;i++)&#123;\n            for(int num:arr[i])&#123;\n                System.out.print(num+\"\\\\t\");\n            &#125;\n            System.out.println();\n        &#125;\n\n        //方式3：外层增强for循环+内层增强for循环：\n        for(int[] a:arr)&#123;\n            for(int num:a)&#123;\n                System.out.print(num+\"\\\\t\");\n            &#125;\n            System.out.println();\n        &#125;\n\n        //方式4：外层增强for循环+内层普通for循环：\n        for(int[] a:arr)&#123;\n            for(int i=0;i\\&lt;a.length;i++)&#123;\n                System.out.print(a[i]+\"\\\\t\");\n            &#125;\n            System.out.println();\n        &#125;\n\n    &#125;\n&#125;\n\n# 二维数组的初始化方式\n数组的初始化方式总共有三种：静态初始化、动态初始化、默认初始化。\n\n静态初始化\n\n除了用 new 关键字来产生数组以外，还可以直接在定义数组的同时就为数组元素分配空间并赋值。\neg:\nint[][] arr = &#123;&#123;1,2&#125;,&#123;4,5,6&#125;,&#123;4,5,6,7,8,9,9&#125;&#125;;\n\nint[][] arr =new int[][] &#123;&#123;1,2&#125;,&#123;4,5,6&#125;,&#123;4,5,6,7,8,9,9&#125;&#125;;\n\n动态初始化\n\n数组定义与为数组元素分配空间并赋值的操作分开进行。\neg:\nint[][] arr = new int[3][]; //本质上定义了一维数组长度为3，每个“格子”中放入的是一个数组\n\narr[0] = new int[]&#123;1,2&#125;;\n\narr[1] = new int[]&#123;3,4,5,6&#125;;\n\narr[2] = new int[]&#123;34,45,56&#125;;\neg:\nint[][] arr = new int[3][2];\n\n默认初始化\n\n数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。\n","slug":"第6章_数组","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,数组","tags_index":"JavaSE","author_index":"雾都"},{"id":"f9af075652e34da99f9e9313498965b6","title":"第7章_IDEA的使用","content":"# IDE\n集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。如微软的 Visual Studio 系列，Borland 的 C++ Builder、Delphi 系列等。该程序可以独立运行，也可以和其它程序并用。IDE 多被用于开发 HTML 应用软件。例如，许多人在设计网站时使用 IDE（如 HomeSite、DreamWeaver 等），因为很多项任务会自动生成。编程开发软件将编辑、编译、调试等功能集成在一个桌面环境中，这样就大大方便了用户。\n❀优点\n节省时间和精力。IDE 的目的就是要让开发更加快捷方便，通过提供工具和各种性能来帮助开发者组织资源，减少失误，提供捷径。\n建立统一标准。当一组程序员使用同一个开发环境时，就建立了统一的工作标准，当 IDE 提供预设的模板，或者不同团队分享代码库时，这一效果就更加明显了。\n管理开发工作。首先，IDE 提供文档工具，可以自动输入开发者评论，或者迫使开发者在不同区域编写评论。其次，IDE 可以展示资源，更便于发现应用所处位置，无需在文件系统里面艰难的搜索。\n❀缺点\n学习曲线问题。IDE 基本上是比较复杂的工具，为了更好的熟练使用，需要一定的时间和耐心。\n初学者的困难。对初学者来说，使用 IDE 来学习开发有相当的难度，不适合学习一种新语言时使用。\n无法修复坏代码或设计。开发者不能完全依赖工具的便捷，还是必须保持专业水准和熟练度，开发的成果好坏主要还是看开发员的技术。\n# JetBrains 公司介绍\n【1】IntelliJ IDEA 就是 Java 的 IDE。\n【2】市场占有率竹节攀升，超过了 Eclipse。\n【3】JetBrains 公司介绍：\nJetBrains 是一家捷克的软件开发公司，该公司位于捷克的布拉格，并在俄罗斯的圣彼得堡及美国麻州波士顿都设有办公室，该公司最为人所熟知的产品是 Java 编程语言开发撰写时所用的集成开发环境：IntelliJ IDEA。公司旗下还有其它产品，比如：\n➢WebStorm: 用于开发 JavaScript、HTML5、 CS3 等前端技术；\n➢PyCharm: 用于开发 python（python 语言热度排行榜排名第一，在人工智能大数据领域应用）\n➢PhpStorm: 用于开发 PHP\n➢RubyMine: 用于开发 Ruby/Rails\n➢AppCode: 用于开发 Objective - C/Swift, 替换 xcode 的\n➢CLion: 用于开发 C/C++\n➢DataGrip: 用于开发数据库和 SQL\n➢Rider: 用于开发.NET\n➢GoLand: 用于开发 Go（区块链主流开发语言就是 Go 语言）\n【4】官网：https://www.jetbrains.com/\n\n# IntelliJ_IDEA 介绍\n【1】IDEA 全称 IntelliJ IDEA，是用于 java 语言开发的集成环境 IDE (Integrated Development Environment)，也可用于其他语言。\nIntelliJ 在业界被公认为最好的 java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、Ant、JUnit、CVS 整合、代码审查、 创新的 GUI 设计等方面的功能可以说是超常的。\nIDEA 是 JetBrains 公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。\n【2】IDEA 的支持：\n\n\n【3】IDEA 的优势（相对于 Eclipse）\n①强大的整合能力。比如: Git、 Maven、 Spring 等\n②提示功能的快速、便捷\n③提示功能的范围广\n④好用的快捷键和代码模板\n⑤精准搜索\n# IntelliJ_IDEA 的下载和安装的准备\n\n【2】安装的准备：\n（1）硬件环境：\n内存 8G 以上\nCPU i5 以上\n安装在固态硬盘下\n（2）软件环境：\n需要安装 JDK\n# IDEA 的卸载\n对于免安装的 idea：\n（1）删除安装文件\n（2）到用户下将 idea 的缓存，配置的目录删除掉即可\n安装 idea:\n(1) 可以用控制面板–》程序\n# IDEA 页面展示\n【1】项目下内容：\n➢工程下的 src 类似于 Eclipse 下的 src 目录，用于存放代码。。\n➢工程下的.idea 和 TestProject.iml 文件都是 IDEA 工程特有的。类似于 Eclipse 工程下的 settings、.classpath、.project 等。\n【2】配置：\n\n\n# Module 的概念和使用\n【1】在 Eclipse 中我们有 Workspace (工作空间) 和 Project (工程) 的概念，在 IDEA 中只有 Project (工程) 和 Module (模块) 的概念。\n这里的对应关系为:\n\n\n\nIDEA 官网说明:  An Eclipse workspace is similar to a project in IntelliJ IDEA  An Eclipse project maps to a module in IntelliJ IDEA\n\n\n\n\n翻译:  Eclipse 中 workspace 相当于 IDEA 中的 Project  Eclipse 中 Project 相当于 IDEA 中的 Module\n\n\n\n在 IntelliJ IDEA 中 Project (工程) 是最顶级的级别，次级别是 Module (模块)。\n一个 Project 下可以有多个 Module。\n【2】从 Eclipse 转过来的人总是下意识地要在同一个窗口管理 n 个项目，这在 Intellij IDEA 是无法做到的。Intellij IDEA 提供的解决方案是打开多个项目实例，即打开多个项目窗口。即：一个 Project 打开一个 Window 窗口。\n【3】IDEA 这样设置的原因：\n目前主流的大型项目都是分布式部署的，结构都是类似这种多 Module 的。\n这类项目一般是这样划分的，比如：积分模块、任务模块、活动模块等等，模块之间彼此可以相互依赖。这些 Module 之间都是处于同一个项目业务下的模块，彼此之间是有不可分割的业务关系的。\n\n【4】out 目录的说明：里面存放的是编译后的字节码文件\n\n【5】删除模块：\n\n\n# IDEA 的常用设置\n【1】进入设置：\n\n\n\n【2】设置主题：\n\n【3】编辑区的字体变大或者变小：\n\n【4】鼠标悬浮在代码上有提示：\n\n【5】自动导包和优化多余的包：\n手动导包：快捷键：alt+enter\n自动导包和优化多余的包：\n\n【6】同一个包下的类，超过指定个数的时候，导包合并为 *\n\n\n【7】显示行号 ， 方法和方法间的分隔符：\n\n【8】忽略大小写，进行提示：\n\n【9】多个类不隐藏，多行显示：\n\n【10】设置默认的字体，字体大小，字体行间距：(编辑区和控制台都会变化)\n\n【11】修改代码中注释的字体颜色：\n\n【12】修改类头的文档注释信息：—》注意：对新建的类才有效\n/**\n* @Auther: zhaoss\n* @Date: ${DATE} - ${MONTH} - ${DAY} - $\n* @Description: $\n* @version: 1.0\n*/\n\n【13】设置项目文件编码：\n\n文件右下角可以调节编码格式：\n\n【14】自动编译：\n\n【15】省电模式：\n\n【16】代码显示结构：\n\n【17】导入 jar 包：\n\n【18】生成序列化版本号：\n\n\n# IDEA 的常用快捷键\n【1】创建内容：alt+insert\n【2】main 方法：psvm\n【3】输出语句：sout\n【4】复制行：ctrl+d\n【5】删除行：ctrl+y\n\n【6】代码向上 / 下移动：Ctrl + Shift + Up / Down\n【7】搜索类： ctrl+n\n【8】生成代码 ：alt + Insert（如构造函数等，getter,setter,hashCode,equals,toString）\n【9】百能快捷键 : alt + Enter （导包，生成变量等）\n【10】单行注释或多行注释 ： Ctrl + / 或 Ctrl + Shift + /\n【11】重命名 shift+f6\n【12】for 循环 直接 ：fori 回车即可\n【13】代码块包围：try-catch,if,while 等 ctrl+alt+t\n【14】 代码自动补全提示:\n\n【15】 idea 代码字体大小放大和缩小的快捷键\n\n【16】代码一层一层调用的快捷键：\n点进源码：ctrl + 鼠标悬浮在代码上 + 点进去即可：\n\n【17】显示代码结构 : alt + 7\n【18】显示导航栏： alt +1\n【19】撤回：ctrl+z\n【20】REDO 操作：\n如果跟搜狗输入法的快捷键冲突，可以选择将搜狗的快捷键取消。\n\n【21】缩进：tab 取消缩进： shift+tab\n# 模板的使用\n# 代码模板是什么\n它的原理就是配置一些常用代码字母缩写，在输入简写时可以出现你预定义的固定模式的代码，使得开发效率大大提高，同时也可以增加个性化。最简单的例子就是在 Java 中输入 sout 会出现 System.out.println ();\n（一）所处位置：\n（1）Live Templates\n（2）Postfix Completion\n\n（二）区别：\n【1】\nLive Templates 中可以做用户的个性化定制。\nPostfix Completion 中只能用，不能修改。\n【2】使用方式不同\n\n\n# 修改现有模板\n【1】案例 1：改 main 方法： psvm\n\n\n【2】案例 2：修饰属性的修饰符：\n\n\n# 常用的代码模板\n【1】模板 1： main 方法：\nmain 或者 psvm\n【2】模板 2：输出语句：\nsout 或者 .sout\n一些变型：\nsoutp: 打印方法的形参\nsoutm: 打印方法的名字\nsoutv: 打印变量\n【3】模板 3： 循环\n普通 for 循环： fori（正向） 或者 .fori （正向） . forr (逆向)\n增强 for 循环： iter 或者 .for\n（可以用于数组的遍历，集合的遍历）\n【4】模板 4： 条件判断\nifn 或者 .null ：判断是否为 null （if null）\ninn 或者 .nn ：判断不等于 null (if not null)\n【5】模板 5： 属性修饰符：\nprsf : private static final\npsf :public static final\n# 自定义模板\n【1】测试方法：\n\n【2】常用属性：($$ 中的内容其实就是在定义光标的位置，光标可以切换，用回车切换)\n\n【3】方法注释模板：\n/**\n* 功能描述:\n* @param: $param$\n* @return: $return$\n* @auther: $user$\n* @date: $date$ $time$\n*/\n\n# IDEA 中的断点调试\n# 常用断点调试快捷键\n调试在开发中大量应用：\n【1】Debug 的优化设置：更加节省内存空间：\n设置 Debug 连接方式，默认是 Socket。 Shared memory 是 Windows 特有的一个属性，一般在 Windows 系统下建议使用此设置，\n内存占用相对较少。\n\n【2】常用断点调试快捷键：\n一步一步的向下运行代码，不会走入任何方法中。\n一步一步的向下运行代码，不会走入系统类库的方法中，但是会走入自定义的方法中。\n一步一步的向下运行代码，会走入系统类库的方法中，也会走入自定义的方法中。\n跳出方法\n结束程序\n进入到下一个断点，如果没有下一个断点了，就直接运行到程序结束。\n 在当前次取消未执行的断点。\n# 条件判断，查看表达式的值\n【1】条件判断：\n说明:\n调试的时候，在循环里增加条件判断，可以极大的提高效率，心情也能惧悦。\n具体操作:\n在断点处右击调出条件断点。可以在满足某个条件下，实施断点。\n\n【2】查看表达式的值：\n选择行，alt+f8。\n\n","slug":"第7章_IDEA的使用","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,IDEA的使用","tags_index":"JavaSE","author_index":"雾都"},{"id":"a9c033b7d80ad30fa176598f67ef440a","title":"第8章_面向对象","content":"# 面向过程和面向对象的区别\n面向过程：当事件比较简单的时候，利用面向过程，注重的是事件的具体的步骤 / 过程，注重的是过程中的具体的行为，以函数为最小单位，考虑怎么做。\n面向对象：注重找 “参与者”, 将功能封装进对象，强调具备了功能的对象，以类 / 对象为最小单位，考虑谁来做。\n案例：\n人把大象装进冰箱：\n面向过程：\n函数 1：打开冰箱 ()\n函数 2：储存大象 ()\n函数 3：关闭冰箱 ()\n面向对象：\n人 {\n打开 (冰箱){\n冰箱。打开 ();\n}\n存储 (大象){\n大象。进入 ();\n}\n关闭 (冰箱){\n冰箱。关闭 ();\n}\n}\n冰箱 {\n打开（）\n关闭（）{}\n}\n柜子 {\n}\n大象 {\n进入 (冰箱){\n}\n}\n面向过程 —&gt; 面向对象，其实就是由执行者 —&gt; 指挥者的 一个过渡\n面向过程：编年体\n面向对象：纪传体\n二者相辅相成，并不是对立的。解决复杂问题，通过面向对象方式便于我们从宏观上把握事物之间复杂的关系、方便我们分析整个系统；具体到微观操作，仍然使用面向过程方式来处理\n# 类和对象的关系\n【1】万事万物皆对象\n【2】\n对象：具体的事物，具体的实体，具体的实例，模板下具体的产品\n类：对对象向上抽取出像的部分，公共的部分，形成类，类是抽象的，是一个模板\n【3】一般在写代码的时候先写类，然后在根据类创建对应的对象。\n# 面向对象三个阶段\n面向对象三个阶段：\n【1】面向对象分析 OOA – Object Oriented Analysis\n对象：张三，王五，朱六，你，我\n抽取出一个类 ----》人类\n类里面有什么：\n动词–》动态特性–》方法\n名词–》静态特性–》属性\n【2】面向对象设计 OOD – Object Oriented Design\n先有类，再有对象：\n类：人类： Person\n对象：zhangsan ，lisi，zhuliu\n【3】面向对象编程 OOP – Object Oriented Programming\n创建类：\n（1）属性（field 成员变量）\n属性用于定义该类或该类对象包含的数据或者说静态特征。属性作用范围是整个类体。\n属性定义格式：\n\n\n\n[修饰符] 方法返回值类型 方法名 (形参列表)\n\n\n\n（2）方法\n方法用于定义该类或该类实例的行为特征和功能实现。方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。\n方法定义格式：\n\n\n\n[修饰符] 方法返回值类型 方法名 (形参列表)\n\n\n\nvoid 代表没有返回值；方法的作用：重用代码，封装功能，便于修改\n代码：\n\n\n\npackage com.msb;\n\npublic class Person &#123;\n    //名词---》属性---》成员变量---》放在类中方法外（注意：我们只把有需要的内容写到代码里，不相关的东西不要放在代码中）\n    int age ;//年龄\n    String name;//姓名\n    double height;//身高\n    double weight;//体重\n\n    //动词---》方法\n    //吃饭\n    public void eat()&#123;\n        int num = 10;//局部变量：放在方法中\n        System.out.println(\"我喜欢吃饭\");\n    &#125;\n    //睡觉：\n    public void sleep(String address)&#123;\n        System.out.println(\"我在\"+address+\"睡觉\");\n    &#125;\n    //自我介绍：\n    public String introduce()&#123;\n        return \"我的名字是：\"+name+\"，我的年龄是：\"+age+\",我的身高是：\"+height+\",我的体重是：\"+weight;\n    &#125;\n&#125;\n\n\n# 创建对象\n\n\n\npackage com.msb;\n\npublic class Test &#123;//测试类\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //创建一个人类的具体的对象/实例：\n        //创建一个对象，对象的名字叫：zs\n        //Person 属于 引用数据类型\n        //第一次加载类的时候，会进行类的加载，初始化创建对象的时候，对象的属性没有给赋值，有默认的初始化的值。\n        Person zs = new Person();\n        zs.name = \"张三\";\n        zs.age = 19;\n        zs.height = 180.4;\n        zs.weight = 170.4;\n\n        //再创建一个对象：\n        //再次创建类的时候，就不会进行类的加载了，类的加载只在第一次需要的时候加载一次\n        Person ls = new Person();\n        ls.name = \"李四\";\n        ls.age = 18;\n        ls.height = 170.6;\n        ls.weight = 160.5;\n\n        //对属性值进行读取：\n        System.out.println(zs.name);\n        System.out.println(ls.age);\n\n        //对方法进行操作：\n        //不同的对象，属性有自己的特有的值，但是方法都是调用类中通用的方法。\n        //属性：各个对象的属性是独立的，\n        //方法：各个对象的方法是共享的。\n        zs.eat();\n        ls.eat();\n        zs.sleep(\"教室\");\n        /\\*String str = zs.introduce();\n        System.out.println(str);\\*/\n            System.out.println(zs.introduce());\n    &#125;\n&#125;\n\n\n# 局部变量和成员变量的区别\n** 区别 1：** 代码中位置不同\n成员变量：类中方法外定义的变量\n局部变量：方法中定义的变量 代码块中定义的变量\n** 区别 2：** 代码的作用范围\n成员变量：当前类的很多方法\n局部变量：当前一个方法（当前代码块）\n** 区别 3：** 是否有默认值\n成员变量：有\n局部变量：没有\n\n引用数据类型： null\n** 区别 4：** 是否要初始化\n成员变量：不需要，不建议初始化，后续使用的时候再赋值即可\n局部变量：一定需要，不然直接使用的时候报错\n区别 5：内存中位置不同\n成员变量：堆内存\n局部变量：栈内存\n** 区别 6：** 作用时间不同\n成员变量：当前对象从创建到销毁\n局部变量：当前方法从开始执行到执行完毕\n代码：\n\npackage com.msb;\n\n/**\n* @Auther: msb-zhaoss\n*/\n\npublic class Student &#123;\n    byte e;\n    short s;\n    int c ;//成员变量：在类中方法外\n    long num2;\n    float f ;\n    double d;\n    char ch;\n    boolean bo;\n    String name;\n    public void study()&#123;\n        int num = 10 ; //局部变量：在方法中\n        System.out.println(num);//10\n        //int num ;重复命名，出错了\n        &#123;\n            int a;//局部变量：在代码块中\n        &#125;\n        int a;\n        if(1==3)&#123;\n            int b;\n        &#125;\n        System.out.println(c);\n    &#125;\n    public void eat()&#123;\n        System.out.println(c);\n    &#125;\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Student s = new Student();\n        System.out.println(s.c);\n        System.out.println(s.bo);\n        System.out.println(s.ch);\n        System.out.println(s.d);\n        System.out.println(s.e);\n        System.out.println(s.f);\n        System.out.println(s.name);\n        System.out.println(s.num2);\n        System.out.println(s.s);\n\n        s.d = 10.4;\n    &#125;\n&#125;\n\n\n运行结果：\n\n# 构造器\npublic class Person &#123;\n    //构造器：没有任何参数的构造器我们叫做：空参构造器--》空构造器\n    public Person()&#123;\n        /\\*age = 19;\n        name = \"lili\";\n        height = 169.5;\\*/\n    &#125;\n    //属性：\n    String name;\n    int age;\n    double height;\n    //方法：\n    public void eat()&#123;\n        System.out.println(\"我喜欢吃饭\");\n    &#125;\n&#125;\n\npackage com.msb2;\n\n/\\*\\*\n    \\* @Auther: msb-zhaoss\n        \\*/\n        public class Test &#123;\n            //这是一个main方法，是程序的入口：\n            public static void main(String[] args) &#123;\n                //创建一个Person类的具体的对象/实例/实体：\n                /\\*\n                    创建对象的过程：\n                    1.第一次遇到Person的时候，进行类的加载（只加载一次）\n                    2.创建对象，为这个对象在堆中开辟空间\n                    3.为对象进行属性的初始化动作\n\n                    new关键字实际上是在调用一个方法，这个方法叫构造方法（构造器）\n                    调用构造器的时候，如果你的类中没有写构造器，那么系统会默认给你分配一个构造器，只是我们看不到罢了。\n                    可以自己显式 的将构造器编写出来：\n                    构造器的格式：\n                    [修饰符] 构造器的名字()&#123;\n\n                &#125;\n                构造器和方法的区别：\n                    1.没有方法的返回值类型\n                    2.方法体内部不能有return语句\n                    3.构造器的名字很特殊，必须跟类名一样\n\n                    构造器的作用：不是为了创建对象，因为在调用构造器之前，这个对象就已经创建好了，并且属性有默认的初始化的值。\n                    调用构造器的目的是给属性进行赋值操作的。\n\n                    注意：我们一般不会在空构造器中进行初始化操作，因为那样的话每个对象的属性就一样了。\n                    实际上，我们只要保证空构造器的存在就可以了，里面的东西不用写\n                    \\*/\n                    Person p = new Person();\n                System.out.println(p.age);\n                System.out.println(p.name);\n                System.out.println(p.height);\n\n                Person p2 = new Person();\n                System.out.println(p2.age);\n                System.out.println(p2.name);\n                System.out.println(p2.height);\n            &#125;\n        &#125;\n\n\n# 构造器的重载\npublic class Person &#123;\n\n    //属性：\n    String name;\n    int age;\n    double height;\n\n    //空构造器\n    public Person()&#123;\n\n    &#125;\n    public Person(String name,int age,double height)&#123;\n        //当形参名字和属性名字重名的时候，会出现就近原则：\n        //在要表示对象的属性前加上this.来修饰 ，因为this代表的就是你创建的那个对象\n        this.name = name;\n        this.age = age;\n        this.height = height;\n    &#125;\n    public Person(String a,int b)&#123;\n        name = a;\n        age = b;\n    &#125;\n\n    //方法：\n    public void eat()&#123;\n        System.out.println(\"我喜欢吃饭\");\n    &#125;\n&#125;\npackage com.msb3.msb2;\n\n/\\*\\*\n    \\* @Auther: msb-zhaoss\n        \\*/\n        public class Test &#123;\n            //这是一个main方法，是程序的入口：\n            public static void main(String[] args) &#123;\n                /\\*\n                    1.一般保证空构造器的存在，空构造器中一般不会进行属性的赋值操作\n                    2.一般我们会重载构造器，在重载的构造器中进行属性赋值操作\n                    3.在重载构造器以后，假如空构造器忘写了，系统也不会给你分配默认的空构造器了，那么你要调用的话就会出错了。\n                    4\\. 当形参名字和属性名字重名的时候，会出现就近原则：\n                    在要表示对象的属性前加上this.来修饰 ，因为this代表的就是你创建的那个对象\n\n                    \\*/\n\n                    Person p = new Person();\n                /\\*p.age = 19;\n                p.name = \"lili\";\n                p.height = 180.4;\\*/\n\n                    Person p2 = new Person(\"lili\",19,180.4);\n                System.out.println(p2.age);\n                System.out.println(p2.height);\n                System.out.println(p2.name);\n\n            &#125;\n        &#125;\n\n# 内存分析\n# 代码 1\n\n\n\npublic class Person {   int id;   int age;    public static void main(String args[]){   Person p1= new Person();   }  }\n\n\n\n内存分析：\n\n# 代码 2\npublic class Person &#123;\n    int id;\n    int age;\n    String school;\n    public Person (int a,int b,String c)&#123;\n        id=a;\n        age=b;\n        school=c;\n    &#125;\n    public static void main(String args[])&#123;\n        Person p= new Person(1,20, \"海淀\");\n    &#125;\n&#125;\n\n\n# 代码 3\n\n\n\nclass Person{   int id;   int age;   String school;   Person (int a,int b,String c){   id=a;   age=b;   school=c;   }    public void setAge(int a){   age=a;   }  }\n\n\n\n\n|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n\nthis\n【1】创建对象的过程：\n（1）在第一次遇到一个类的时候，对这个类要进行加载，只加载一次。\n（2）创建对象，在堆中开辟空间\n（3）对对象进行初始化操作，属性赋值都是默认的初始值。\n（4）new 关键字调用构造器，执行构造方法，在构造器中对属性重新进行赋值\nthis:\n\n\n从上面的效果能够看到：this 指代的就是当前对象：\n内存：\n\nthis 关键字 用法：\n（1）this 可以修饰属性：\n总结：当属性名字和形参发生重名的时候，或者 属性名字 和局部变量重名的时候，都会发生就近原则，所以如果我要是直接使用变量名字的话就指的是离的近的那个形参或者局部变量，这时候如果我想要表示属性的话，在前面要加上：this. 修饰\n如果不发生重名问题的话，实际上你要是访问属性也可以省略 this.\npublic class Person &#123;\n    //属性\n    int age;\n    String name;\n    double height;\n    //空构造器\n    public Person()&#123;\n\n    &#125;\n    //有参构造器\n    public Person(int age,String name,double height)&#123;\n        this.age = age;\n        this.name = name;\n        this.height = height;\n    &#125;\n    //方法：\n    public void eat()&#123;\n        int age = 10;\n        System.out.println(age);//就近原则，age指的是离它近的age--》局部变量的age\n        System.out.println(this.age);//这里指代的就是属性的age\n        System.out.println(\"我喜欢吃饭\");\n    &#125;\n&#125;\n\n\n（2）this 修饰方法：\n总结：在同一个类中，方法可以互相调用，this. 可以省略不写。\npublic class Person &#123;\n    //属性\n    int age;\n    String name;\n    double height;\n    //空构造器\n    public Person()&#123;\n\n    &#125;\n    //有参构造器\n    public Person(int age,String name,double height)&#123;\n        this.age = age;\n        this.name = name;\n        this.height = height;\n    &#125;\n    //方法：\n    /\\*public void eat()&#123;\n        int age = 10;\n        System.out.println(age);//就近原则，age指的是离它近的age--》局部变量的age\n        System.out.println(this.age);//这里指代的就是属性的age\n        System.out.println(\"我喜欢吃饭\");\n    &#125;\\*/\n\n        public void play()&#123;\n        /\\*this.\\*/eat();\n        System.out.println(\"上网\");\n        System.out.println(\"洗澡\");\n    &#125;\n\n    public void eat()&#123;\n        System.out.println(/\\*this.\\*/age);\n        System.out.println(\"吃饭\");\n    &#125;\n&#125;\n\n\n（3）this 可以修饰构造器：\n总结：同一个类中的构造器可以相互用 this 调用，注意：this 修饰构造器必须放在第一行\npublic class Person &#123;\n    //属性\n    int age;\n    String name;\n    double height;\n    //空构造器\n    public Person()&#123;\n\n    &#125;\n    //有参构造器\n    public Person(int age,String name,double height)&#123;\n        this(age,name);\n        this.height = height;\n\n    &#125;\n    public Person(int age,String name)&#123;\n        this(age);\n        this.name = name;\n    &#125;\n    public Person(int age)&#123;\n        this.age = age;\n    &#125;\n    //方法：\n    /\\*public void eat()&#123;\n        int age = 10;\n        System.out.println(age);//就近原则，age指的是离它近的age--》局部变量的age\n        System.out.println(this.age);//这里指代的就是属性的age\n        System.out.println(\"我喜欢吃饭\");\n    &#125;\\*/\n\n        public void play()&#123;\n        /\\*this.\\*/eat();\n        System.out.println(\"上网\");\n        System.out.println(\"洗澡\");\n    &#125;\n\n    public void eat()&#123;\n        System.out.println(/\\*this.\\*/age);\n        System.out.println(\"吃饭\");\n    &#125;\n&#125;\n\n\n# static\n【1】static 可以修饰：属性，方法，代码块，内部类。\n【2】static 修饰属性；\npublic class Test &#123;\n    //属性：\n    int id;\n    static int sid;\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //创建一个Test类的具体的对象\n        Test t1 = new Test();\n        t1.id = 10;\n        t1.sid = 10;\n\n        Test t2 = new Test();\n        t2.id = 20;\n        t2.sid = 20;\n\n        Test t3 = new Test();\n        t3.id = 30;\n        t3.sid = 30;\n\n        //读取属性的值：\n        System.out.println(t1.id);\n        System.out.println(t2.id);\n        System.out.println(t3.id);\n\n        System.out.println(t1.sid);\n        System.out.println(t2.sid);\n        System.out.println(t3.sid);\n\n    &#125;\n&#125;\n\n\n内存分析：\n\n一般官方的推荐访问方式：可以通过类名。属性名的方式去访问：\n\nstatic 修饰属性总结：\n（1）在类加载的时候一起加载入方法区中的静态域中\n（2）先于对象存在\n（3）访问方式： 对象名。属性名 类名。属性名（推荐）\nstatic 修饰属性的应用场景：某些特定的数据想要在内存中共享，只有一块 --》这个情况下，就可以用 static 修饰的属性\npublic class MsbStudent &#123;\n    //属性：\n    String name;\n    int age;\n    static String school;\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        MsbStudent.school = \"马士兵教育\";\n        //创建学生对象：\n        MsbStudent s1 = new MsbStudent();\n        s1.name = \"张三\";\n        s1.age = 19;\n        //s1.school = \"马士兵教育\";\n\n        MsbStudent s2 = new MsbStudent();\n        s2.name = \"李四\";\n        s2.age = 21;\n        //s2.school = \"马士兵教育\";\n\n        System.out.println(s2.school);\n\n\n\n\n    &#125;\n\n&#125;\n\n\n属性：\n静态属性 （类变量）\n非静态属性（实例变量）\n【3】static 修饰方法；\npublic class Demo &#123;\n    int id;\n    static int sid;\n\n    public void a()&#123;\n        System.out.println(id);\n        System.out.println(sid);\n        System.out.println(\"------a\");\n    &#125;\n    //1.static和public都是修饰符，并列的没有先后顺序，先写谁后写谁都行\n    static public void b()&#123;\n        //System.out.println(this.id);//4.在静态方法中不能使用this关键字\n        //a();//3.在静态方法中不能访问非静态的方法\n        //System.out.println(id);//2.在静态方法中不能访问非静态的属性\n        System.out.println(sid);\n        System.out.println(\"------b\");\n    &#125;\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //5.非静态的方法可以用对象名.方法名去调用\n        Demo d = new Demo();\n        d.a();\n        //6.静态的方法可以用 对象名.方法名去调用 也可以 用 类名.方法名 （推荐）\n        Demo.b();\n        d.b();\n        ![](img/4bb83b402c7aad5b29b09c46fe3a60b9.png)\n    &#125;\n&#125;\n\n\n# 代码块\n【1】类的组成：属性，方法，构造器，代码块，内部类\n【2】代码块分类：普通块，构造块，静态块，同步块（多线程）\n【3】代码：\npublic class Test &#123;\n    //属性\n    int a;\n    static int sa;\n\n    //方法\n    public void a()&#123;\n        System.out.println(\"-----a\");\n        &#123;\n            //普通块限制了局部变量的作用范围\n            System.out.println(\"这是普通块\");\n            System.out.println(\"----000000\");\n            int num = 10;\n            System.out.println(num);\n        &#125;\n        //System.out.println(num);\n        //if()&#123;&#125;\n        //while()&#123;&#125;\n    &#125;\n    public static void b()&#123;\n        System.out.println(\"------b\");\n    &#125;\n\n    //构造块\n    &#123;\n        System.out.println(\"------这是构造块\");\n    &#125;\n    //静态块\n    static&#123;\n        System.out.println(\"-----这是静态块\");\n        //在静态块中只能方法：静态属性，静态方法\n        System.out.println(sa);\n        b();\n    &#125;\n\n\n    //构造器\n    public Test()&#123;\n        System.out.println(\"这是空构造器\");\n    &#125;\n    public Test(int a)&#123;\n        this.a = a;\n    &#125;\n\n\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Test t = new Test();\n        t.a();\n\n        Test t2 = new Test();\n        t2.a();\n    &#125;\n\n\n\n&#125;\n\n\n总结：\n（1）代码块执行顺序：\n最先执行静态块，只在类加载的时候执行一次，所以一般以后实战写项目：创建工厂，数据库的初始化信息都放入静态块。\n一般用于执行一些全局性的初始化操作。\n再执行构造块，（不常用）\n再执行构造器，\n再执行方法中的普通块。\n# 包，import\n【1】生活案例：\n邮寄快递：中国。北京。通州区.**** 小区.5 号楼.3 单元.101 房。赵珊珊\n历史：常山赵子龙\n【2】包的作用：\n为了解决重名问题（实际上包对应的就是盘符上的目录）\n解决权限问题\n【3】创建包：\n\n\n包名定义：\n（1）名字全部小写\n（2）中间用。隔开\n（3）一般都是公司域名倒着写 ： com.jd com.msb\n（4）加上模块名字：\ncom.jd.login com.jd.register\n（5）不能使用系统中的关键字：nul,con,com1—com9…\n（6）包声明的位置一般都在非注释性代码的第一行：\n\n【4】导包问题：\nimport com.msb2.Person; //导包：就是为了进行定位\n\nimport java.util.Date;\n\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        new Person();\n        new Date();\n        new java.sql.Date(1000L);//在导包以后，还想用其他包下同名的类，就必须要手动自己写所在的包。\n        new Demo();\n    &#125;\n&#125;\n\n\n总结：\n\n（2）在导包以后，还想用其他包下同名的类，就必须要手动自己写所在的包。\n（3）同一个包下的类想使用不需要导包，可以直接使用。\n（4）在 java.lang 包下的类，可以直接使用无需导包：\n\n（5）IDEA 中导包快捷键：alt+enter\n可以自己设置自动导包\n（6）可以直接导入 *：\n\n【5】在 Java 中的导包没有包含和被包含的关系：\n设置目录平级的格式（不是包含和被包含的显示）：\n\n\n【6】静态导入：\n\npackage com.msb11;\n// 静态导入：\n\nimport static java.lang.Math.\\*;\n//导入：java.lang下的Math类中的所有静态的内容\n\npublic class Test &#123;\n//这是一个main方法，是程序的入口：\npublic static void main(String[] args) &#123;\nSystem.out.println(random());\nSystem.out.println(PI);\nSystem.out.println(round(5.6));\n&#125;\n//在静态导入后，同一个类中有相同的方法的时候，会优先走自己定义的方法。\npublic static int round(double a)&#123;\nreturn 1000;\n&#125;\n&#125;\n\n\n# 三大特性\n# 封装 (Encapsulation)\n【1】生活案例：\nATM , 电线\n【2】Java 中封装的理解：\n将某些东西进行隐藏，然后提供相应的方式进行获取。\n\n我们程序设计追求 “高内聚，低耦合”。\n➢高内聚：类的内部数据操作细节自己完成，不允许外部干涉；\n➢低耦合：仅对外暴露少量的方法用于使用。\n隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提\n高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露\n的暴露出来。这就是封装性的设计思想。\n【3】封装的好处：\n提高代码的安全性\n【4】代码：通过一个属性感受封装：\n\npackage com.msb.test01;\n\n/**\n* @Auther: msb-zhaoss\n*/\n\npublic class Girl &#123;//女孩\n    //属性：\n    private int age;\n\n    //读取年龄：\n    public int duquAge()&#123;\n        return age;\n    &#125;\n\n    //设置年龄：\n    public void shezhiAge(int age)&#123;\n        if(age \\>= 30 )&#123;\n            this.age = 18;\n        &#125;else&#123;\n            this.age = age;\n        &#125;\n\n    &#125;\n\n\n&#125;\n\npackage com.msb.test01;\n\n\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //创建一个Girl类的对象：\n        Girl g = new Girl();\n        /\\*g.age = 33;\n        System.out.println(g.age);\\*/\n            //设置年龄：\n            g.shezhiAge(31);\n        //读取年龄：\n        System.out.println(g.duquAge());\n\n    &#125;\n&#125;\n\n\n上面的代码，对于属性 age 来说，我加了修饰符 private，这样外界对它的访问就受到了限制，现在我还想加上其他的限制条件，但是在属性本身上没有办法再加了，所以我们通过定义方法来进行限制条件的添加。\n以属性为案例：\n进行封装：\n（1）将属性私有化，被 private 修饰–》加入权限修饰符\n一旦加入了权限修饰符，其他人就不可以随意的获取这个属性\n（2）提供 public 修饰的方法让别人来访问 / 使用\n（3）即使外界可以通过方法来访问属性了，但是也不能随意访问，因为咱们在方法中可以加入 限制条件。\n【5】实际开发中，方法一般会写成 setter，getter 方法：\n可以利用 IDEA 快捷键生成：alt+insert --&gt;getter and setter:\npublic class Girl &#123;//女孩\n    //属性：\n    private int age;\n\n    //读取年龄：\n    public int getAge()&#123;\n        return age;\n    &#125;\n\n    //设置年龄：\n    public void setAge(int age)&#123;\n        if(age \\>= 30 )&#123;\n            this.age = 18;\n        &#125;else&#123;\n            this.age = age;\n        &#125;\n    &#125;\n&#125;\n\n\n【6】加深练习：\npublic class Student &#123;\n    //属性：\n    private int age;\n    private String name;\n    private String sex;\n\n    //加入对应的setter和getter方法：\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public String getSex() &#123;\n        return sex;\n    &#125;\n\n    public void setSex(String sex) &#123;\n        if(\"男\".equals(sex) \\|\\| \"女\".equals(sex) )&#123;//sex是男 或者 是 女\n            this.sex = sex;\n        &#125;else&#123;\n            this.sex = \"男\";\n        &#125;\n    &#125;\n\n    //加入构造器：\n    public Student()&#123;\n\n    &#125;\n\n    public Student(int age,String name,String sex)&#123;\n        this.age = age;\n        this.name = name;\n        //this.sex = sex;\n        this.setSex(sex);\n    &#125;\n&#125;\n\npackage com.msb.test2;\n\n\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //创建一个Student对象：\n        Student s1 = new Student();\n        s1.setName(\"nana\");\n        s1.setAge(19);\n        s1.setSex(\"女\");\n        System.out.println(s1.getName()+\"---\"+s1.getAge()+\"----\"+s1.getSex());\n\n        Student s2 = new Student(18,\"菲菲\",\"asdfasdfsadf\");\n        System.out.println(s2.getName()+\"---\"+s2.getAge()+\"----\"+s2.getSex());\n    &#125;\n&#125;\n\n\n# 继承 (Inheritance)\n【1】类是对对象的抽象：\n举例：\n荣耀 20 ，小米 红米 3，华为 p40 pro —&gt; 类：手机类\n【2】继承是对类的抽象：\n举例：\n学生类：Student：\n属性：姓名，年龄，身高，学生编号\n方法：吃饭，睡觉，喊叫，学习\n教师类：Teacher:\n属性：姓名，年龄，身高，教师编号\n方法：吃饭，睡觉，喊叫，教学\n员工类：Emploee:\n属性：姓名，年龄，身高，员工编号\n方法：吃饭，睡觉，喊叫，工作\n共同的东西：\n人类：\n属性：姓名，年龄，身高\n方法：吃饭，睡觉，喊叫\n学生类 / 教师类 / 员工类 继承 自 人类\n以后定义代码：\n先定义人类：\n人类： —》父类，基类，超类\n属性：姓名，年龄，身高\n方法：吃饭，睡觉，喊叫\n再定义 ： —》子类，派生类\n学生类：Student：\n属性：学生编号\n方法：学习\n教师类：Teacher:\n属性：教师编号\n方法：教学\n员工类：Emploee:\n属性：员工编号\n方法：工作\n子类 继承自 父类\n狗类：\n属性：姓名，年龄，身高\n方法：吃饭，睡觉，喊叫\n我们的继承关系，是在合理的范围中进行的抽取 ，抽取出子类父类的关系：\n上面的案例中：\n学生类 / 教师类 / 员工类 继承 自 人类 —》合理\n学生类 / 教师类 / 员工类 继承 自 狗类 —》不合理\n区分：\n学生是一个人\n教师是一个人\n员工是一个人 —》合理\n学生是一个狗 —》不合理\n总结：继承 就是 is - a 的关系\n【3】代码层面的解释：\n先写父类，再写子类：\n父类：人类 Person\n子类：学生类 Student\n\npackage com.msb.test03;\n\n/**\n* @Auther: msb-zhaoss\n*/\n\npublic class Person &#123;\n    //属性：\n    private int age;\n    private String name;\n    private double height;\n\n    //提供setter getter方法：\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public double getHeight() &#123;\n        return height;\n    &#125;\n\n    public void setHeight(double height) &#123;\n        this.height = height;\n    &#125;\n\n    //方法：\n    public void eat()&#123;\n        System.out.println(\"可以吃饭。。。\");\n    &#125;\n\n    public void sleep()&#123;\n        System.out.println(\"可以睡觉。。。\");\n    &#125;\n\n&#125;\n\n\npackage com.msb.test03;\n\npublic class Student extends Person &#123;//子类Student 继承 父类Person\n    //属性：\n    private int sno;//学号\n\n    public int getSno() &#123;\n        return sno;\n    &#125;\n\n    public void setSno(int sno) &#123;\n        this.sno = sno;\n    &#125;\n\n    //方法：\n    public void study()&#123;\n        System.out.println(\"学生可以学习\");\n    &#125;\n\n&#125;\npackage com.msb.test03;\n\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //创建子类Student的对象\n        Student s = new Student();\n        s.setSno(1001);\n        s.setAge(18);\n        s.setName(\"菲菲\");\n        s.setHeight(180.4);\n\n        System.out.println(\"学生名字为：\"+s.getName()+\",学生的年纪：\"+s.getAge());\n\n        //访问方法：\n        s.study();\n        s.eat();\n        s.sleep();\n    &#125;\n&#125;\n**【4】继承的好处：** 提高代码的复用性\n父类定义的内容，子类可以直接拿过来用就可以了，不用代码上反复重复定义了\n需要注意的点：\n父类 private 修饰的内容，子类实际上也继承，只是因为封装的特性阻碍了直接调用，但是提供了间接调用的方式，可以间接调用。\n【5】总结：\n（1）继承关系 ：\n父类 / 基类 / 超类\n子类 / 派生类\n子类继承父类一定在合理的范围进行继承的 子类 extends 父类\n（2）继承的好处：\n1. 提高了代码的复用性，父类定义的内容，子类可以直接拿过来用就可以了，不用代码上反复重复定义了\n2. 便于代码的扩展\n3. 为了以后多态的使用。是多态的前提。\n（3）父类 private 修饰的内容，子类也继承过来了。\n（4）一个父类可以有多个子类。\n（5）一个子类只能有一个直接父类。\n但是可以间接的继承自其它类。\n\n（6）继承具有传递性：\nStudent --》继承自 Person —》继承自 Object\nObject 类是所有类的根基父类。\n所有的类都直接或者间接的继承自 Object。\n# 内存分析\n\n# 权限修饰符\n\n【1】private：权限：在当前类中可以访问\n\n\n\n【2】default: 缺省修饰符：权限：到同一个包下的其他类都可以访问\n\n\n\n【3】protected：权限：最大到不同包下的子类\n\n\n\n【4】public：在整个项目中都可以访问\n总结：\n属性，方法：修饰符：四种：private，缺省，protected，public\n类：修饰符：两种：缺省，public\n以后写代码\n一般属性：用 private 修饰 ，方法：用 public 修饰\n# 方法的重写\n【1】重写：\n发生在子类和父类中，当子类对父类提供的方法不满意的时候，要对父类的方法进行重写。\n【2】重写有严格的格式要求：\n子类的方法名字和父类必须一致，参数列表（个数，类型，顺序）也要和父类一致。\n【3】代码：\npublic class Person &#123;\n    public void eat()&#123;\n        System.out.println(\"吃食物\");\n    &#125;\n    public void sleep()&#123;\n        System.out.println(\"睡觉\");\n    &#125;\n&#125;\n\npublic class Student extends Person &#123;\n    public void study()&#123;\n        System.out.println(\"学习\");\n    &#125;\n    @override\n    public void eat()&#123;\n        System.out.println(\"我喜欢吃小龙虾喝啤酒。。\");\n    &#125;\n&#125;\n\n\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //创建一个Student类的对象：\n        Student s = new Student();\n        s.eat();\n    &#125;\n&#125;\n\n【4】内存：\n\n【5】重载和重写的区别：\n重载：在同一个类中，当方法名相同，形参列表不同的时候 多个方法构成了重载\n重写：在不同的类中，子类对父类提供的方法不满意的时候，要对父类的方法进行重写。\n\n# super\n【1】super: 指的是： 父类的\n【2】super 可以修饰属性，可以修饰方法；\n在子类的方法中，可以通过 super. 属性 super. 方法 的方式，显示的去调用父类提供的属性，方法。在通常情况下，super. 可以省略不写：\n\n在特殊情况下，当子类和父类的属性重名时，你要想使用父类的属性，必须加上修饰符 super.，只能通过 super. 属性来调用\n在特殊情况下，当子类和父类的方法重名时，你要想使用父类的方法，必须加上修饰符 super.，只能通过 super. 方法来调用\n在这种情况下，super. 就不可以省略不写。\n\n【3】super 修饰构造器：\n其实我们平时写的构造器的第一行都有：super () --&gt; 作用：调用父类的空构造器，只是我们一般都省略不写\n（所有构造器的第一行默认情况下都有 super (), 但是一旦你的构造器中显示的使用 super 调用了父类构造器，那么这个 super () 就不会给你默认分配了。如果构造器中没有显示的调用父类构造器的话，那么第一行都有 super (), 可以省略不写）\n\n如果构造器中已经显示的调用 super 父类构造器，那么它的第一行就没有默认分配的 super (); 了\n\n在构造器中，super 调用父类构造器和 this 调用子类构造器只能存在一个，两者不能共存：\n因为 super 修饰构造器要放在第一行，this 修饰构造器也要放在第一行：\n\n改正二选一即可：\n\n【4】以后写代码构造器的生成可以直接使用 IDEA 提供的快捷键：\nalt+insert\n\n# 继承条件下构造方法的执行过程\n\npublic class Person &#123;\n    int age;\n    String name;\n\n    public Person(int age, String name) &#123;\n        super();\n        this.age = age;\n        this.name = name;\n    &#125;\n\n    public Person() &#123;\n    &#125;\n&#125;\n\npublic class Student extends Person &#123;\n    double height ;\n\n    public Student() &#123;\n    &#125;\n\n    public Student(int age, String name, double height) &#123;\n        super(age, name);\n        this.height = height;\n    &#125;\n&#125;\n\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Student s = new Student(19,\"feifei\",160.8);\n    &#125;\n&#125;\n\n\n# Object 类\n所有类都直接或间接的继承自 Object 类，Object 类是所有 Java 类的根基类。\n也就意味着所有的 Java 对象都拥有 Object 类的属性和方法。\n如果在类的声明中未使用 extends 关键字指明其父类，则默认继承 Object 类。\n\ntoString () 方法\n【1】Object 类的 toString () 的作用：\n\n方法的原理：\n\n现在，使用 toString 方法的时候，打印出来的东西 “不好看”，对于其他人来说不友好，可读性不好\n我们现在是想知道对象的信息，名字，年龄，身高。。。。。。\n现在的格式不好：\n\n出现的问题：子类 Student 对父类 Object 提供的 toString 方法不满意，不满意–》对 toString 方法进行重写：\npublic class Student /\\*extends Object\\*/&#123;\n    private String name;\n    private int age;\n    private double height;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public double getHeight() &#123;\n        return height;\n    &#125;\n\n    public void setHeight(double height) &#123;\n        this.height = height;\n    &#125;\n\n    public Student() &#123;\n    &#125;\n\n    public Student(String name, int age, double height) &#123;\n        this.name = name;\n        this.age = age;\n        this.height = height;\n    &#125;\n\n    public String toString() &#123;\n        return \"这是一个Student对象，这个对象的名字：\"+name+\",年龄：\"+age+\",身高：\"+height;\n    &#125;\n&#125;\n\n\n测试类：\n\n总结：toString 的作用就是对对象进行 “自我介绍”，一般子类对父类提供的 toString 都不满意，都要进行重写。\nIDEA 提供了快捷键：\npublic class Student /\\*extends Object\\*/&#123;\n    private String name;\n    private int age;\n    private double height;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public double getHeight() &#123;\n        return height;\n    &#125;\n\n    public void setHeight(double height) &#123;\n        this.height = height;\n    &#125;\n\n    public Student() &#123;\n    &#125;\n\n    public Student(String name, int age, double height) &#123;\n        this.name = name;\n        this.age = age;\n        this.height = height;\n    &#125;\n\n    /\\*public String toString() &#123;\n        return \"这是一个Student对象，这个对象的名字：\"+name+\",年龄：\"+age+\",身高：\"+height;\n    &#125;\\*/\n\n        @Override\n        public String toString() &#123;\n        return \"Student&#123;\" +\n            \"name='\" + name + '\\\\'' +\n            \", age=\" + age +\n            \", height=\" + height +\n            '&#125;';\n    &#125;\n&#125;\n\n\nequals 方法\npublic class Phone &#123;//手机类：\n    //属性：\n    private String brand;//品牌型号\n    private double price;//价格\n    private int year ;//出产年份\n    //方法：\n\n    public String getBrand() &#123;\n        return brand;\n    &#125;\n\n    public void setBrand(String brand) &#123;\n        this.brand = brand;\n    &#125;\n\n    public double getPrice() &#123;\n        return price;\n    &#125;\n\n    public void setPrice(double price) &#123;\n        this.price = price;\n    &#125;\n\n    public int getYear() &#123;\n        return year;\n    &#125;\n\n    public void setYear(int year) &#123;\n        this.year = year;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"Phone&#123;\" +\n            \"brand='\" + brand + '\\\\'' +\n            \", price=\" + price +\n            \", year=\" + year +\n            '&#125;';\n    &#125;\n\n    //构造器：\n\n    public Phone() &#123;\n    &#125;\n\n    public Phone(String brand, double price, int year) &#123;\n        this.brand = brand;\n        this.price = price;\n        this.year = year;\n    &#125;\n\n\n    //对equals方法进行重写：\n    public boolean equals(Object obj) &#123;//Object obj = new Phone();\n        //将obj转为Phone类型：\n        Phone other = (Phone)obj;//向下转型，为了获取子类中特有的内容\n        if(this.getBrand()==other.getBrand()&amp;&amp;this.getPrice()==other.getPrice()&amp;&amp;this.getYear()==other.getYear())&#123;\n            return true;\n        &#125;\n        return false;\n    &#125;\n&#125;\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n\n        //创建Phone类的对象：\n        Phone p1 = new Phone(\"华为P40\",2035.98,2020);\n        Phone p2 = new Phone(\"华为P40\",2035.98,2020);\n        //比较两个对象：p1和p2对象：\n        //==的作用：比较左右两侧的值是否想的，要么相等，返回true,要么不相等,返回false\n        System.out.println(p1==p2);//--\\>\\>\\>对于引用数据类型来说，比较的是地址值。---\\>一定返回的是false\n\n        //Object类提供了一个方法 equals方法 ：作用：比较对象具体内容是否相等。\n        boolean flag = p1.equals(p2);//点进源码发现：底层依旧比较的是==，比较的还是地址值。\n        System.out.println(flag);\n\n    &#125;\n&#125;\n总结：\nequals 作用：这个方法提供了对对象的内容是否相等 的一个比较方式，对象的内容指的就是属性。\n父类 Object 提供的 equals 就是在比较 == 地址，没有实际的意义，我们一般不会直接使用父类提供的方法，\n而是在子类中对这个方法进行重写。\ninstanceof\n\n利用集成开发工具生成 equals 方法\n【1】利用 eclipse：\n\n【2】利用 idea：\n\n# 类和类的关系\n代码\n总结：\n**【1】面向对象的思维：** 找参与者，找女孩类，找男孩类\n【2】体会了什么叫方法的性擦，什么叫方法的实参：\n\n具体传入的内容 实参：\n\n【3】类和类可以产生关系：\n（1）将一个类作为另一个类中的方法的形参\n（2）将一个类作为另一个类的属性\npublic class Girl &#123;\n    //属性：\n    String name;\n    double weight;\n    Mom m /\\*= new Mom()\\*/;\n    //方法：\n    public void add(int a)&#123;//参数是基本数据类型\n        System.out.println(a);\n        System.out.println(a+100);\n    &#125;\n    //谈恋爱的方法：\n    public void love(Boy b)&#123;//参数是引用数据类型Boy\n        System.out.println(\"我男朋友的名字是：\"+b.name+\"，我男朋友的年龄是：\"+b.age);\n        b.buy();\n    &#125;\n\n    //女孩跟妈妈聊天：\n    public void wechat()&#123;\n        m.say();\n    &#125;\n\n    //构造器：\n    public Girl(String name, double weight) &#123;\n        this.name = name;\n        this.weight = weight;\n    &#125;\n&#125;\npublic class Boy &#123;\n    //属性：\n    int age;\n    String name;\n    //方法：\n    public void buy()&#123;\n        System.out.println(\"跟我谈恋爱，我给你买买买。。。\");\n    &#125;\n    //构造器：\n    public Boy(int age, String name) &#123;\n        this.age = age;\n        this.name = name;\n    &#125;\n&#125;\npublic class Mom &#123;\n    //方法：\n    public void say()&#123;\n        System.out.println(\"妈妈唠唠叨叨 都是爱，听妈妈的话。。\");\n    &#125;\n&#125;\n\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //创建一个Boy类的具体的对象：\n        Boy boy = new Boy(30,\"鹿晗\");\n        //创建一个Girl类的具体的对象：\n        Girl girl = new Girl(\"关晓彤\",100);\n        //谈恋爱：\n        //girl.love(boy);\n        Boy boy2 = new Boy(35,\"陈伟霆\");\n        girl.love(boy2);\n\n        //还可以跟妈妈微信聊天：\n        girl.m = new Mom();\n        girl.wechat();\n    &#125;\n&#125;\n\n总结\n一、继承关系\n继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。在 Java 中继承关系通过关键字 extends 明确标识，在设计时一般没有争议性。在 UML 类图设计中，继承用一条带空心三角箭头的实线表示，从子类指向父类，或者子接口指向父接口。\n\n二、实现关系\n实现指的是一个 class 类实现 interface 接口（可以是多个）的功能，实现是类与接口之间最常见的关系。在 Java 中此类关系通过关键字 implements 明确标识，在设计时一般没有争议性。在 UML 类图设计中，实现用一条带空心三角箭头的虚线表示，从类指向实现的接口。\n\n三、依赖关系\n简单的理解，依赖就是一个类 A 使用到了另一个类 B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是类 B 的变化会影响到类 A。比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。表现在代码层面，让类 B 作为参数被类 A 在某个 method 方法中使用。在 UML 类图设计中，依赖关系用由类 A 指向类 B 的带箭头虚线表示。\n\n四、关联关系\n关联体现的是两个类之间语义级别的一种强依赖关系，比如我和我的朋友，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。关联可以是单向、双向的。表现在代码层面，为被关联类 B 以类的属性形式出现在关联类 A 中，也可能是关联类 A 引用了一个类型为被关联类 B 的全局变量。在 UML 类图设计中，关联关系用由关联类 A 指向被关联类 B 的带箭头实线表示，在关联的两端可以标注关联双方的角色和多重性标记。\n\n五、聚合关系\n聚合是关联关系的一种特例，它体现的是整体与部分的关系，即 has-a 的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。比如计算机与 CPU、公司与员工的关系等，比如一个航母编队包括海空母舰、驱护舰艇、舰载飞机及核动力攻击潜艇等。表现在代码层面，和关联关系是一致的，只能从语义级别来区分。在 UML 类图设计中，聚合关系以空心菱形加实线箭头表示。\n\n六、组合关系\n组合也是关联关系的一种特例，它体现的是一种 contains-a 的关系，这种关系比聚合更强，也称为强聚合。它同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束，比如人和人的大脑。表现在代码层面，和关联关系是一致的，只能从语义级别来区分。在 UML 类图设计中，组合关系以实心菱形加实线箭头表示。\n\n七、总结\n对于继承、实现这两种关系没多少疑问，它们体现的是一种类和类、或者类与接口间的纵向关系。其他的四种关系体现的是类和类、或者类与接口间的引用、横向关系，是比较难区分的，有很多事物间的关系要想准确定位是很难的。前面也提到，这四种关系都是语义级别的，所以从代码层面并不能完全区分各种关系，但总的来说，后几种关系所表现的强弱程度依次为：组合 &gt; 聚合 &gt; 关联 &gt; 依赖。\n# 多态 (Polymorphism)\n【1】多态跟属性无关，多态指的是方法的多态，而不是属性的多态。\n【2】案例代入：\npublic class Animal &#123;//父类：动物：\n    public void shout()&#123;\n        System.out.println(\"我是小动物，我可以叫。。。\");\n    &#125;\n&#125;\npublic class Cat extends Animal&#123;\n    //喊叫方法：\n    public void shout()&#123;\n        System.out.println(\"我是小猫，可以喵喵叫\");\n    &#125;\n    public void scratch()&#123;\n        System.out.println(\"我是小猫，我可以挠人\");\n    &#125;\n&#125;\npublic class Dog extends Animal&#123;\n    //喊叫：\n    public void shout()&#123;\n        System.out.println(\"我是小狗，我可以汪汪叫\");\n    &#125;\n    public void guard()&#123;\n        System.out.println(\"我是小狗，我可以看家护院，保护我的小主人。。。\");\n    &#125;\n&#125;\npublic class Pig extends Animal&#123;\n    public void shout()&#123;\n        System.out.println(\"我是小猪，我嗯嗯嗯的叫\");\n    &#125;\n    public void eat()&#123;\n        System.out.println(\"我是小猪，我爱吃东西。。\");\n    &#125;\n\n&#125;\npublic class Girl &#123;\n    //跟猫玩耍：\n    /\\*public void play(Cat cat)&#123;\n        cat.shout();\n    &#125;\\*/\n        //跟狗玩耍：\n        /\\*public void play(Dog dog)&#123;\n        dog.shout();\n    &#125;\\*/\n        //跟小动物玩耍：\n        public void play(Animal an)&#123;\n        an.shout();\n    &#125;\n&#125;\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //具体的猫：--》猫的对象\n        //Cat c = new Cat();\n        //具体的小女孩：--》女孩的对象\n        Girl g = new Girl();\n        //小女孩跟猫玩：\n        //g.play(c);\n        //具体的狗---》狗的对象：\n        //Dog d = new Dog();\n        //小女孩跟狗玩：\n        //g.play(d);\n        //具体的动物：--》动物的对象：\n        //Cat c = new Cat();\n        //Dog d = new Dog();\n        Pig p = new Pig();\n        Animal an = p;\n        g.play(an);\n    &#125;\n&#125;\n\n【3】总结：\n（1）先有父类，再有子类：–》继承 先有子类，再抽取父类 ----》泛化\n（2）什么是多态：\n多态就是多种状态：同一个行为，不同的子类表现出来不同的形态。\n多态指的就是同一个方法调用，然后由于对象不同会产生不同的行为。\n（3）多态的好处：\n为了提高代码的扩展性，符合面向对象的设计原则：开闭原则。\n开闭原则：指的就是扩展是 开放的，修改是关闭的。\n注意：多态可以提高扩展性，但是扩展性没有达到最好，以后我们会学习 反射\n（4）多态的要素：\n一，继承： Cat extends Animal ,Pig extends Animal, Dog extends Animal\n二，重写：子类对父类的方法 shout () 重写\n三， 父类引用指向子类对象：\n\nPig p = new Pig();\nAnimal an = p;\n\n将上面的代码合为一句话：\nAnimal an = new Pig();\n= 左侧：编译期的类型\n= 右侧：运行期的类型\nAnimal an = new Pig();\ng.play(an); //\n\npublic void play(Animal an){//Animal an = an = new Pig();\nan.shout();\n}\n\n上面的代码，也是多态的一种非常常见的应用场合：父类当方法的形参，然后传入的是具体的子类的对象，\n然后调用同一个方法，根据传入的子类的不同展现出来的效果也不同，构成了多态。\n# 内存分析\n\n# 向下转型，向上转型\n\n\n现在我就想访问到 eat () 方法和 weight 属性：\npublic class Demo &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Pig p = new Pig();\n        Animal an = p;//转型：向上转型\n        an.shout();\n\n        //加入转型的代码：\n        //将Animal转为Pig类型：\n        Pig pig = (Pig)an ;//转型：向下转型\n        pig.eat();\n        pig.age = 10;\n        pig.weight = 60.8;\n    &#125;\n&#125;\n\n对应内存：\n\n思考之前的 equals 方法：\n\n# 简单工厂设计模式\n不仅可以使用父类做方法的形参，还可以使用父类做方法的返回值类型，真实返回的对象可以是该类的任意一个子类对象。\n简单工厂模式的实现，它是解决大量对象创建问题的一个解决方案。将创建和使用分开，工厂负责创建，使用者直接调用即可。简单工厂模式的基本要求是\n² 定义一个 static 方法，通过类名直接调用\n² 返回值类型是父类类型，返回的可以是其任意子类类型\n² 传入一个字符串类型的参数，工厂根据参数创建对应的子类产品\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Girl g = new Girl();\n\n        //Cat c = new Cat();\n        //Dog d = new Dog();\n        //Pig p = new Pig();\n        Animal an = PetStore.getAnimal(\"狗\");\n\n        g.play(an);\n    &#125;\n&#125;\npublic class PetStore &#123;//宠物店 ---》工厂类\n    //方法：提供动物\n    public static Animal getAnimal(String petName)&#123;//多态的应用场合（二）\n        Animal an = null;\n\n        if(\"猫\".equals(petName))&#123;//petName.equals(\"猫\") --》这样写容易发生空指针异常\n            an = new Cat();\n        &#125;\n\n        if(\"狗\".equals(petName))&#123;\n            an = new Dog();\n        &#125;\n\n        if(\"猪\".equals(petName))&#123;\n            an = new Pig();\n        &#125;\n\n        return an;\n    &#125;\n&#125;\n\n# final\n【1】修饰变量；\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //第1种情况：\n        //final修饰一个变量，变量的值不可以改变，这个变量也变成了一个字符常量，约定俗称的规定：名字大写\n        final int A = 10;//final修饰基本数据类型\n        //A = 20; 报错：不可以修改值\n        //第2种情况：\n        final Dog d = new Dog();//final修饰引用数据类型，那么地址值就不可以改变\n        //d = new Dog(); --\\>地址值不可以更改\n        //d对象的属性依然可以改变：\n        d.age = 10;\n        d.weight = 13.7;\n\n        //第3种情况：\n        final Dog d2 = new Dog();\n        a(d2);\n        //第4种情况：\n        b(d2);\n\n    &#125;\n    public static void a(Dog d)&#123;\n        d = new Dog();\n    &#125;\n    public static void b(final Dog d)&#123;//d被final修饰 ，指向不可以改变\n        //d = new Dog();\n    &#125;\n&#125;\n\n【2】修饰方法；\nfinal 修饰方法，那么这个方法不可以被该类的子类重写：\n\n【3】修饰类；\nfinal 修饰类，代表没有子类，该类不可以被继承：\n一旦一个类被 final 修饰，那么里面的方法也没有必要用 final 修饰了（final 可以省略不写）\n\n**【4】案例：JDK 提供的 Math 类：** 看源码发现：\n（1）使用 Math 类的时候无需导包，直接使用即可：\n\n（2）Math 类没有子类，不能被其他类继承了\n\n（3）里面的属性全部被 final 修饰，方法也是被 final 修饰的，只是省略不写了\n原因：子类没有必要进行重写。\n（4）外界不可以创建对象：\nMath m = new Math();\n\n（5）发现 Math 类中的所有的属性，方法都被 static 修饰\n那么不用创建对象去调用，只能通过类名。属性名 类名。方法名 去调用\n# 抽象类，抽象方法\n【1】抽象类和抽象方法的关系：\n抽象类中可以定义 0-n 个抽象方法。\n【2】抽象类作用：\n在抽象类中定义抽象方法，目的是为了为子类提供一个通用的模板，子类可以在模板的基础上进行开发，先重写父类的抽象方法，然后可以扩展子类自己的内容。抽象类设计避免了子类设计的随意性，通过抽象类，子类的设计变得更加严格，进行某些程度上的限制。\n使子类更加的通用。\n【3】代码：\n//4.一个类中如果有方法是抽象方法，那么这个类也要变成一个抽象类。\n//5.一个抽象类中可以有0-n个抽象方法\npublic abstract class Person &#123;\n    //1.在一个类中，会有一类方法，子类对这个方法非常满意，无需重写，直接使用\n    public void eat()&#123;\n        System.out.println(\"一顿不吃饿得慌\");\n    &#125;\n    //2.在一个类中，会有一类方法，子类对这个方法永远不满意，会对这个方法进行重写。\n    //3.一个方法的方法体去掉，然后被abstract修饰，那么这个方法就变成了一个抽象方法\n    public abstract void say();\n    public abstract void sleep();\n&#125;\n\n//6.抽象类可以被其他类继承：\n//7.一个类继承一个抽象类，那么这个类可以变成抽象类\n//8.一般子类不会加abstract修饰，一般会让子类重写父类中的抽象方法\n//9.子类继承抽象类，就必须重写全部的抽象方法\n//10.子类如果没有重写父类全部的抽象方法，那么子类也可以变成一个抽象类。\nclass Student extends Person&#123;\n\n    @Override\n    public void say() &#123;\n        System.out.println(\"我是东北人，我喜欢说东北话。。\");\n    &#125;\n\n    @Override\n    public void sleep() &#123;\n        System.out.println(\"东北人喜欢睡炕。。\");\n    &#125;\n&#125;\nclass Demo&#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //11.创建抽象类的对象：--\\>抽象类不可以创建对象\n        //Person p = new Person();\n        \n        //12.创建子类对象：\n        Student s = new Student();\n        s.sleep();\n        s.say();\n        \n        //13.多态的写法：父类引用只想子类对象：\n        Person p = new Student();\n        p.say();\n        p.sleep();\n    &#125;\n&#125;\n【4】面试题：\n（1）抽象类不能创建对象，那么抽象类中是否有构造器？\n抽象类中一定有构造器。构造器的作用 给子类初始化对象的时候要先 super 调用父类的构造器。\n（2）抽象类是否可以被 final 修饰？\n不能被 final 修饰，因为抽象类设计的初衷就是给子类继承用的。要是被 final 修饰了这个抽象类了，就不存在继承了，就没有子类。\n# 接口\n【1】接口声明格式：\n\n\n\n[访问修饰符] interface 接口名 [extends 父接口 1，父接口 2…]\n\n\n\n【2】代码：\npackage com.msb.test04;\n\n/**\n    * 1.类是类，接口是接口，它们是同一层次的概念。\n    * 2.接口中没有构造器\n    * 3.接口如何声明：interface\n    * 4.在JDK1.8之前，接口中只有两部分内容：\n    * （1）常量：固定修饰符：public static final\n    * （2）抽象方法：固定修饰符：public abstract\n    * 注意：修饰符可以省略不写，IDE会帮你自动补全，但是初学者建议写上，防止遗忘。\n*/\npublic interface TestInterface01 &#123;\n    //常量：\n    /\\*public static final\\*/ int NUM = 10;\n    //抽象方法：\n    /\\*public abstract\\*/ void a();\n    /\\*public abstract\\*/ void b(int num);\n    /\\*public abstract\\*/ int c(String name);\n&#125;\n\ninterface TestInterface02&#123;\n    void e();\n    void f();\n&#125;\n/\\*\n    5.类和接口的关系是什么？ 实现关系 类实现接口：\n    6.一旦实现一个接口，那么实现类要重写接口中的全部的抽象方法：\n    7.如果没有全部重写抽象方法，那么这个类可以变成一个抽象类。\n    8.java只有单继承，java还有多实现\n    一个类继承其他类，只能直接继承一个父类\n    但是实现类实现接口的话，可以实现多个接口\n    9.写法：先继承 再实现：extends Person implements TestInterface01,TestInterface02\n    \\*/\n    class Student extends Person implements TestInterface01,TestInterface02 &#123;\n        @Override\n        public void a() &#123;\n            System.out.println(\"---1\");\n        &#125;\n\n        @Override\n        public void b(int num) &#123;\n            System.out.println(\"---2\");\n        &#125;\n\n        @Override\n        public int c(String name) &#123;\n            return 100;\n        &#125;\n\n        @Override\n        public void e() &#123;\n            System.out.println(\"---3\");\n        &#125;\n\n        @Override\n        public void f() &#123;\n            System.out.println(\"---4\");\n        &#125;\n    &#125;\n\n\nclass Test&#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //10.接口不能创建对象：\n        //TestInterface02 t = new TestInterface02();\n        TestInterface02 t = new Student();//接口指向实现类 ---》多态\n\n        //11.接口中常量如何访问：\n        System.out.println(TestInterface01.NUM);\n        System.out.println(Student.NUM);\n        Student s = new Student();\n        System.out.println(s.NUM);\n        TestInterface01 t2 = new Student();\n        System.out.println(t2.NUM);\n    &#125;\n&#125;\n【3】接口的作用是什么？\n定义规则，只是跟抽象类不同地方在哪？它是接口不是类。\n接口定义好规则之后，实现类负责实现即可。\n【4】\n继承：子类对父类的继承\n实现：实现类对接口的实现\n手机 是不是 照相机\n继承：手机 extends 照相机 “is-a” 的关系，手机是一个照相机\n上面的写法 不好：\n实现： 手机 implements 拍照功能 “has-a” 的关系，手机具备照相的能力\n案例：飞机，小鸟，风筝\n定义一个接口： Flyable\n【5】多态的应用场合：\n（1）父类当做方法的形参，传入具体的子类的对象\n（2）父类当做方法的返回值，返回的是具体的子类的对象\n（3）接口当做方法的形参，传入具体的实现类的对象\n（4）接口当做方法的返回值，返回的是具体的实现类的对象\n【6】接口和抽象类的区别：\n\n#  JDK1.8 以后的接口新增内容\n在 JDK1.8 之前，接口中只有两部分内容：\n（1）常量：固定修饰符：public static final\n（2）抽象方法：固定修饰符：public abstract\n在 JDK1.8 之后，新增非抽象方法：\n（1）被 public default 修饰的非抽象方法：\n注意 1：default 修饰符必须要加上，否则出错\n注意 2：实现类中要是想重写接口中的非抽象方法，那么 default 修饰符必须不能加，否则出错。\npublic interface TestInterface &#123;\n    //常量：\n    public static final int NUM= 10;\n    //抽象方法：\n    public abstract void a();\n    //public default修饰的非抽象方法：\n    public default void b()&#123;\n        System.out.println(\"-------TestInterface---b()-----\");\n    &#125;\n&#125;\nclass Test implements TestInterface&#123;\n    public void c()&#123;\n        //用一下接口中的b方法：\n        b();//可以\n        //super.b();不可以\n        TestInterface.super.b();//可以\n    &#125;\n    @Override\n    public void a() &#123;\n        System.out.println(\"重写了a方法\");\n    &#125;\n\n    @Override\n    public void b() &#123;\n\n    &#125;\n&#125;\n（2）静态方法：\n注意 1：static 不可以省略不写\n注意 2：静态方法不能重写\npublic interface TestInterface2 &#123;\n    //常量：\n    public static final int NUM = 10;\n    //抽象方法：\n    public abstract void a();\n    //public default非抽象方法；\n    public default void b()&#123;\n        System.out.println(\"-----TestInterface2---b\");\n    &#125;\n    //静态方法：\n    public static void c()&#123;\n        System.out.println(\"TestInterface2中的静态方法\");\n    &#125;\n&#125;\n\nclass Demo implements TestInterface2&#123;\n    @Override\n    public void a() &#123;\n        System.out.println(\"重写了a方法\");\n    &#125;\n    public static void c()&#123;\n        System.out.println(\"Demo中的静态方法\");\n    &#125;\n&#125;\n\nclass A &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        Demo d = new Demo();\n        d.c();\n        Demo.c();\n        TestInterface2.c();\n    &#125;\n&#125;\n疑问：为什么要在接口中加入非抽象方法？？？\n如果接口中只能定义抽象方法的话，那么我要是修改接口中的内容，那么对实现类的影响太大了，所有实现类都会受到影响。\n现在在接口中加入非抽象方法，对实现类没有影响，想调用就去调用即可。\n# 内部类\n# 成员内部类\n/**\n* 1.类的组成：属性，方法，构造器，代码块（普通块，静态块，构造块，同步块），内部类\n* 2.一个类TestOuter的内部的类SubTest叫内部类， 内部类 ：SubTest 外部类：TestOuter\n* 3.内部类：成员内部类 (静态的，非静态的) 和 局部内部类（位置：方法内，块内，构造器内）\n* 4.成员内部类:\n* 里面属性，方法，构造器等\n* 修饰符：private，default，protect，public，final,abstract\n*/\npublic class TestOuter &#123;\n    //非静态的成员内部类：\n    public class D&#123;\n        int age = 20;\n        String name;\n        public void method()&#123;\n            //5.内部类可以访问外部类的内容\n            /\\*System.out.println(age);\n            a();\\*/\n                int age = 30;\n\n            //8.内部类和外部类属性重名的时候，如何进行调用：\n            System.out.println(age);//30\n            System.out.println(this.age);//20\n            System.out.println(TestOuter.this.age);//10\n        &#125;\n    &#125;\n\n    //静态成员内部类：\n    static class E&#123;\n        public void method()&#123;\n            //6.静态内部类中只能访问外部类中被static修饰的内容\n            /\\*System.out.println(age);\n            a();\\*/\n        &#125;\n    &#125;\n    //属性：\n    int age = 10;\n    //方法：\n    public void a()&#123;\n        System.out.println(\"这是a方法\");\n        &#123;\n            System.out.println(\"这是一个普通块\");\n            class B&#123;\n\n            &#125;\n        &#125;\n        class A&#123;\n\n        &#125;\n        //7.外部类想要访问内部类的东西，需要创建内部类的对象然后进行调用\n        D d = new D();\n        System.out.println(d.name);\n        d.method();\n\n    &#125;\n    static&#123;\n        System.out.println(\"这是静态块\");\n    &#125;\n    &#123;\n        System.out.println(\"这是构造块\");\n    &#125;\n    //构造器：\n    public TestOuter()&#123;\n        class C&#123;\n\n        &#125;\n    &#125;\n\n    public TestOuter(int age) &#123;\n        this.age = age;\n    &#125;\n&#125;\n\nclass Demo&#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //创建外部类的对象：\n        TestOuter to = new TestOuter();\n        to.a();\n\n        //9.创建内部类的对象：\n        //静态的成员内部类创建对象：\n        TestOuter.E e = new TestOuter.E();\n        //非静态的成员内部类创建对象：\n        //错误：TestOuter.D d = new TestOuter.D();\n        TestOuter t = new TestOuter();\n        TestOuter.D d = t.new D();\n\n    &#125;\n&#125;\n\n\n# 局部内部类\n\n\n\npublic class TestOuter &#123;\n    //1.在局部内部类中访问到的变量必须是被final修饰的\n    public void method()&#123;\n        final int num = 10;\n        class A&#123;\n            public void a()&#123;\n                //num = 20;\n                System.out.println(num);\n            &#125;\n        &#125;\n    &#125;\n    //2.如果类B在整个项目中只使用一次，那么就没有必要单独创建一个B类，使用内部类就可以了\n    public Comparable method2()&#123;\n        class B implements Comparable&#123;\n            @Override\n            public int compareTo(Object o) &#123;\n                return 100;\n            &#125;\n        &#125;\n        return new B();\n    &#125;\n\n    public Comparable method3()&#123;\n        //3.匿名内部类\n        return new Comparable()&#123;\n\n            @Override\n            public int compareTo(Object o) &#123;\n                return 200;\n            &#125;\n        &#125;;\n    &#125;\n\n    public void teat()&#123;\n        Comparable com = new Comparable()&#123;\n\n            @Override\n            public int compareTo(Object o) &#123;\n                return 200;\n            &#125;\n        &#125;;\n\n        System.out.println(com.compareTo(\"abc\"));\n    &#125;\n&#125;\n\n\n# 面向对象项目\n# 项目需求\n\n# 项目结构分析\n\n# 最终代码\n匹萨父类：\npublic class Pizza &#123;\n    //属性\n    private String name;//名称\n    private int size;//大小\n    private int price;//价格\n\n    //方法\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getSize() &#123;\n        return size;\n    &#125;\n\n    public void setSize(int size) &#123;\n        this.size = size;\n    &#125;\n\n    public int getPrice() &#123;\n        return price;\n    &#125;\n\n    public void setPrice(int price) &#123;\n        this.price = price;\n    &#125;\n\n    //展示匹萨信息：\n    public String showPizza()&#123;\n        return \"匹萨的名字是：\"+name+\"\\\\n匹萨的大小是：\"+size+\"寸\\\\n匹萨的价格：\"+price+\"元\";\n    &#125;\n\n\n    //构造器\n\n    public Pizza() &#123;\n    &#125;\n\n    public Pizza(String name, int size, int price) &#123;\n        this.name = name;\n        this.size = size;\n        this.price = price;\n    &#125;\n&#125;\n\n\n培根匹萨：\npublic class BaconPizza extends Pizza &#123;\n    //属性：\n    private int weight;\n\n    public int getWeight() &#123;\n        return weight;\n    &#125;\n\n    public void setWeight(int weight) &#123;\n        this.weight = weight;\n    &#125;\n\n    //构造器：\n\n    public BaconPizza() &#123;\n    &#125;\n\n    public BaconPizza(String name, int size, int price, int weight) &#123;\n        super(name, size, price);\n        this.weight = weight;\n    &#125;\n\n    //重写父类showPizza方法：\n\n    @Override\n    public String showPizza() &#123;\n        return super.showPizza()+\"\\\\n培根的克数是：\"+weight+\"克\";\n    &#125;\n&#125;\n\n\n水果匹萨：\npublic class FruitsPizza extends Pizza&#123;\n    //属性：\n    private String burdening;\n\n    public String getBurdening() &#123;\n        return burdening;\n    &#125;\n\n    public void setBurdening(String burdening) &#123;\n        this.burdening = burdening;\n    &#125;\n\n    //构造器：\n\n    public FruitsPizza() &#123;\n    &#125;\n\n    public FruitsPizza(String name, int size, int price, String burdening) &#123;\n        super(name, size, price);\n        this.burdening = burdening;\n    &#125;\n\n    //重写父类showPizza方法：\n\n    @Override\n    public String showPizza() &#123;\n        return super.showPizza()+\"\\\\n你要加入的水果：\"+burdening;\n    &#125;\n&#125;\n\n\n测试类：\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //选择购买匹萨：\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请选择你想要购买的匹萨（1.培根匹萨 2.水果匹萨）:\");\n        int choice = sc.nextInt();//选择\n        //通过工厂获取匹萨：\n        Pizza pizza = PizzaStore.getPizza(choice);\n        System.out.println(pizza.showPizza());\n\n    &#125;\n&#125;\n\n\n工厂类：\nimport java.util.Scanner;\n\n\npublic class PizzaStore &#123;\n    public static Pizza getPizza(int choice)&#123;\n        Scanner sc = new Scanner(System.in);\n        Pizza p = null;\n        switch (choice)&#123;\n            case 1:\n                &#123;\n                    System.out.println(\"请录入培根的克数：\");\n                    int weight = sc.nextInt();\n                    System.out.println(\"请录入匹萨的大小：\");\n                    int size = sc.nextInt();\n                    System.out.println(\"请录入匹萨的价格：\");\n                    int price = sc.nextInt();\n                    //将录入的信息封装为培根匹萨的对象：\n                    BaconPizza bp = new BaconPizza(\"培根匹萨\",size,price,weight);\n                    p = bp;\n                &#125;\n                break;\n            case 2:\n                &#123;\n                    System.out.println(\"请录入你想要加入的水果：\");\n                    String burdening = sc.next();\n                    System.out.println(\"请录入匹萨的大小：\");\n                    int size = sc.nextInt();\n                    System.out.println(\"请录入匹萨的价格：\");\n                    int price = sc.nextInt();\n                    //将录入的信息封装为水果匹萨的对象：\n                    FruitsPizza fp = new FruitsPizza(\"水果匹萨\",size,price,burdening);\n                    p = fp;\n                &#125;\n                break;\n        &#125;\n        return p;\n    &#125;\n&#125;\n\n\n","slug":"第8章_面向对象","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,面向对象","tags_index":"JavaSE","author_index":"雾都"},{"id":"dfd2b6521673d23cbd9aef76b70cc5b2","title":"第9章_异常","content":"# 习题的引入\n【1】代码：\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //实现一个功能：键盘录入两个数，求商：\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请录入第一个数：\");\n        int num1 = sc.nextInt();\n        System.out.println(\"请录入第二个数：\");\n        int num2 = sc.nextInt();\n        System.out.println(\"商：\"+num1/num2);\n\n    &#125;\n&#125;\n\n运行结果：\n\n测试过程发现问题：\n录入的数据应为 int 类型，但是录入非 int 类型数据的时候，出异常：\n\n除数为 0 的时候：\n\n异常：Exception：在程序的运行过程中，发生了不正常的现象，阻止了程序的运行，我们称之为发生异常。\n# 通过 if-else 解决异常\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //实现一个功能：键盘录入两个数，求商：\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请录入第一个数：\");\n        if(sc.hasNextInt())&#123;\n            int num1 = sc.nextInt();\n            System.out.println(\"请录入第二个数：\");\n            if(sc.hasNextInt())&#123;\n                int num2 = sc.nextInt();\n                if(num2 == 0)&#123;\n                    System.out.println(\"对不起，除数不能为0\");\n                &#125;else&#123;\n                    System.out.println(\"商：\"+num1/num2);\n                &#125;\n            &#125;else&#123;\n                System.out.println(\"对不起，你录入的不是int类型的数据！\");\n            &#125;\n        &#125;else&#123;\n            System.out.println(\"对不起，你录入的不是int类型的数据！\");\n        &#125;\n    &#125;\n&#125;\n\n\n用 if-else 堵漏洞的缺点：\n（1）代码臃肿，业务代码和处理异常的代码混在一起。\n（2）可读性差\n（3）程序员需要花费大量的经历来维护这个漏洞\n（4）程序员很难堵住所有的漏洞。\n# \n# try-catch\n【1】基于 if-else 处理异常缺点太多，所以 java 中专门出了一个异常处理机制：\n“异常三连” try-catch-finally\n【2】异常出现了以后怎么看：\n\n【3】捕获异常： try-catch\n对应代码：\npublic class Test2 &#123;\n    public static void main(String[] args) &#123;\n        //实现一个功能：键盘录入两个数，求商：\n        try&#123;\n            Scanner sc = new Scanner(System.in);\n            System.out.println(\"请录入第一个数：\");\n            int num1 = sc.nextInt();\n            System.out.println(\"请录入第二个数：\");\n            int num2 = sc.nextInt();\n            System.out.println(\"商：\"+num1/num2);\n        &#125;catch(Exception ex)&#123;\n            System.out.println(\"对不起，程序出现异常！\");\n        &#125;\n\n        System.out.println(\"----谢谢你使用计算器111\");\n        System.out.println(\"----谢谢你使用计算器222\");\n        System.out.println(\"----谢谢你使用计算器333\");\n        System.out.println(\"----谢谢你使用计算器444\");\n        System.out.println(\"----谢谢你使用计算器555\");\n        System.out.println(\"----谢谢你使用计算器666\");\n    &#125;\n&#125;\n\n原理：\n把可能出现异常的代码放入 try 代码块中，然后将异常封装为对象，被 catch 后面的 () 中的那个异常对象接收，接收以后：执行 catch 后面的 {} 里面的代码，然后 try-catch 后面的代码，该怎么执行就怎么执行。\n详细说一下：\n（1）try 中没有异常，catch 中代码不执行。\n（2）try 中有异常，catch 进行捕获：\n如果 catch 中异常类型和你出的异常类型匹配的话：走 catch 中的代码–》进行捕获\n如果 catch 中异常类型和你出的异常类型不匹配的话：不走 catch 中的代码–》没有捕获成功，程序相当于遇到异常了，中断了，后续代码不执行\n注意：\n（1）try 中如果出现异常，然后用 catch 捕获成功的话，那么 try 中后续的代码是不会执行的。\n（2）如果 catch 捕获异常成功，那么 try-catch 后面的代码该执行还是执行没有影响。\n# catch 中如何处理异常\npublic class Test3 &#123;\n    public static void main(String[] args) &#123;\n        //实现一个功能：键盘录入两个数，求商：\n        try&#123;\n            Scanner sc = new Scanner(System.in);\n            System.out.println(\"请录入第一个数：\");\n            int num1 = sc.nextInt();\n            System.out.println(\"请录入第二个数：\");\n            int num2 = sc.nextInt();\n            System.out.println(\"商：\"+num1/num2);\n        &#125;catch(Exception ex)&#123;\n            //第一种处理：什么都不写，什么都不做\n\n            //第二种处理：输出自定义异常信息\n            //System.out.println(\"对不起，你的代码有问题！\");\n\n            //第三种处理：打印异常信息：\n            /\\*(1)调用toString方法，显示异常的类名（全限定路径）\\*/\n                /\\*System.out.println(ex);\n            System.out.println(ex.toString());\\*/\n                /\\*(2)显示异常描述信息对应的字符串，如果没有就显示null\n                System.out.println(ex.getMessage());\\*/\n                /\\*(3)显示异常的堆栈信息：将异常信息捕获以后，在控制台将异常的效果给我们展示出来，方便我们查看异常\\*/\n                /\\* ex.printStackTrace();\\*/\n\n                //第四种处理：抛出异常：\n                throw ex;\n        &#125;\n\n        System.out.println(\"----谢谢你使用计算器111\");\n    &#125;\n&#125;\n\n\n# try-catch-finally\n【1】在什么情况下，try-catch 后面的代码不执行？\n（1）throw 抛出异常的情况\n（2）catch 中没有正常的进行异常捕获\n（3）在 try 中遇到 return\n【2】怎么样才可以将 try-catch 后面的代码 必须执行？\n只要将必须执行的代码放入 finally 中，那么这个代码无论如何一定执行。\n【3】return 和 finally 执行顺序？\n先执行 finally 最后执行 return\n【4】什么代码会放在 finally 中呢？\n关闭数据库资源，关闭 IO 流资源，关闭 socket 资源。\n【5】有一句话代码很厉害，它可以让 finally 中代码不执行！\n[System.exit (0);// 终止当前的虚拟机执行](file:///D:\\ 下载 \\System.exit (0);\\ 终止当前的虚拟机执行)\n代码：\nimport java.util.Scanner;\n\npublic class Test3 &#123;\n    public static void main(String[] args) &#123;\n        //实现一个功能：键盘录入两个数，求商：\n        try&#123;\n            Scanner sc = new Scanner(System.in);\n            System.out.println(\"请录入第一个数：\");\n            int num1 = sc.nextInt();\n            System.out.println(\"请录入第二个数：\");\n            int num2 = sc.nextInt();\n            System.out.println(\"商：\"+num1/num2);\n            System.exit(0);//终止当前的虚拟机执行\n            return;\n        &#125;catch(ArithmeticException ex)&#123;\n            //throw ex;\n        &#125;finally &#123;\n            System.out.println(\"----谢谢你使用计算器111\");\n        &#125;\n\n\n    &#125;\n&#125;\n\n\n# 多重 catch\n【1】try 中出现异常以后，将异常类型跟 catch 后面的类型依次比较，按照代码的顺序进行比对，执行第一个与异常类型匹配的 catch 语句\n【2】一旦执行其中一条 catch 语句之后，后面的 catch 语句就会被忽略了！\n【3】在安排 catch 语句的顺序的时候，一般会将特殊异常放在前面（并列），一般化的异常放在后面。\n先写子类异常，再写父类异常。\n【4】在 JDK1.7 以后，异常新处理方式：可以并列用 | 符号连接：\n\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Test4 &#123;\n    public static void main(String[] args) &#123;\n        Integer\n            //实现一个功能：键盘录入两个数，求商：\n            try&#123;\n                Scanner sc = new Scanner(System.in);\n                System.out.println(\"请录入第一个数：\");\n                int num1 = sc.nextInt();\n                System.out.println(\"请录入第二个数：\");\n                int num2 = sc.nextInt();\n                System.out.println(\"商：\"+num1/num2);\n            &#125;catch(ArithmeticException ex)&#123;\n                System.out.println(\"对不起，除数不可以为0\");\n            &#125;catch(InputMismatchException ex)&#123;\n                System.out.println(\"对不起，你录入的数据不是int类型的数据\");\n            &#125;catch(Exception ex)&#123;\n                System.out.println(\"对不起，你的程序出现异常\");\n            &#125;finally &#123;\n                System.out.println(\"----谢谢你使用计算器111\");\n            &#125;\n    &#125;\n&#125;\n\n\n# 异常的分类\n【1】层次结构：\n\n注意：程序中语法错误，逻辑错误 都不属于上面的 Error，Exception\n【2】运行时异常：\npublic class Test5 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //运行时异常：\n        int[] arr = &#123;1,2,3&#125;;\n        System.out.println(arr.length);\n        /\\*int[] arr2 = null;\n        System.out.println(arr2.length);\\*/\n            System.out.println(arr[10]);\n    &#125;\n&#125;\n\n【3】检查异常：\n处理方式 1：try-catch 嵌套 try-catch\npublic class Test6 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //检查异常：\n        try &#123;\n            try &#123;\n                Class.forName(\"com.msb.test01.Test\").newInstance();\n            &#125; catch (InstantiationException e) &#123;\n                e.printStackTrace();\n            &#125; catch (IllegalAccessException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125; catch (ClassNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n处理方式 2：多重 catch\npublic class Test6 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //检查异常：\n        try &#123;\n            Class.forName(\"com.msb.test01.Test\").newInstance();\n        &#125; catch (ClassNotFoundException \\| InstantiationException \\| IllegalAccessException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n处理方式 3：throws\npublic class Test6 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;\n        //检查异常：\n        Class.forName(\"com.msb.test01.Test\").newInstance();\n    &#125;\n&#125;\n\n# throw 和 throws 的区别\nimport java.util.Scanner;\n\npublic class Test7 &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) throws Exception &#123;\n        //实现一个功能：两个数相除，当除数为0的时候，程序出现异常。\n        /\\*try &#123;\n            devide();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\\*/\n            devide();\n    &#125;\n    public static void devide() throws Exception &#123;\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请录入第一个数：\");\n        int num1 = sc.nextInt();\n        System.out.println(\"请录入第二个数：\");\n        int num2 = sc.nextInt();\n        if(num2 == 0 )&#123;//除数为0 ，制造异常。\n            //制造运行时异常：\n            /\\*throw new RuntimeException();\\*/\n                //制造检查异常：\n                /\\*try &#123;\n                    throw new Exception();\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\\*/\n                    throw new Exception();\n        &#125;else&#123;\n            System.out.println(\"商：\"+num1/num2);\n        &#125;\n    &#125;\n&#125;\n\n\n总结：\nthrow 和 throws 的区别：\n（1）位置不同：\nthrow：方法内部\nthrows: 方法的签名处，方法的声明处\n（2）内容不同：\nthrow + 异常对象（检查异常，运行时异常）\nthrows + 异常的类型（可以多个类型，用，拼接）\n（3）作用不同：\nthrow：异常出现的源头，制造异常。\nthrows: 在方法的声明处，告诉方法的调用者，这个方法中可能会出现我声明的这些异常。然后调用者对这个异常进行处理：\n要么自己处理要么再继续向外抛出异常\n# 练习：\n\npublic class Student &#123;\n    private String name;\n    private int age;\n    private String sex;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public String getSex() &#123;\n        return sex;\n    &#125;\n\n    public void setSex(String sex) throws Exception &#123;\n        if(sex.equals(\"男\")\\|\\|sex.equals(\"女\"))&#123;\n            this.sex = sex;\n        &#125;else&#123;//非男非女\n            //解决办法1：\n            /\\*this.sex = \"男\";\\*/\n                //解决办法2：给个友好型提示，但是打印结果为默认的null效果\n                /\\*System.out.println(\"对不起，你的性别错误了\");\\*/\n                //解决办法3：\n                //制造运行时异常：\n                /\\*throw new RuntimeException(\"性别不对！\");\\*/\n                //制造检查异常\n                /\\*try &#123;\n                    throw new Exception();\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                &#125;\\*/\n                    throw new Exception();\n        &#125;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"Student&#123;\" +\n            \"name='\" + name + '\\\\'' +\n            \", age=\" + age +\n            \", sex='\" + sex + '\\\\'' +\n            '&#125;';\n    &#125;\n\n    public Student() &#123;\n    &#125;\n\n    public Student(String name, int age, String sex) &#123;\n        this.name = name;\n        this.age = age;\n        //this.sex = sex;\n        try &#123;\n            this.setSex(sex);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n\n\npublic class Test &#123;\n    //这是一个main方法，是程序的入口：\n    public static void main(String[] args) &#123;\n        //创建一个Student的对象：\n        /\\*Student s = new Student();\n        s.setName(\"菲菲\");\n        s.setAge(19);\n        try &#123;\n            s.setSex(\"asdfasdfasdf\");\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(s);\\*/\n\n            Student s2 = new Student(\"娜娜\",21,\"asdfasdfasdf\");\n        System.out.println(s2);\n    &#125;\n&#125;\n\n\n# 重载和重写的异常\n\n【1】重载：\npublic class Demo &#123;\n    public void a() throws Exception&#123;\n\n    &#125;\n    public void a(int age) throws ArithmeticException&#123;\n\n    &#125;\n&#125;\n\n\n【2】重写：\n\n\n子类 &lt;= 父类\n# 自定义异常\n自定义的异常可以继承：运行时异常\npublic class MyException extends RuntimeException &#123;\n\n    static final long serialVersionUID = -70348971907L;\n\n    public MyException()&#123;\n\n    &#125;\n    public MyException(String msg)&#123;\n        super(msg);\n    &#125;\n&#125;\n\n也可以继承检查异常：\npublic class MyException extends Exception &#123;\n\n    static final long serialVersionUID = -70348971907L;\n\n    public MyException()&#123;\n\n    &#125;\n    public MyException(String msg)&#123;\n        super(msg);\n    &#125;\n&#125;\n\n\n如果继承的是运行时异常，那么在使用的时候无需额外处理\n如果继承的是检查异常，那么使用的时候需要 try-catch 捕获或者 throws 向上抛\n","slug":"第9章_异常","date":"2022-10-06T16:00:00.000Z","categories_index":"JavaSE,异常","tags_index":"JavaSE","author_index":"雾都"},{"id":"45b05c0adc7d6b51711d3e13e977b9ba","title":"hexo","content":"\ntitle: hexo\ndate: 2022-10-06 14:53:52\ncategories:\n- 基础使用\n tags:\n- 环境搭建\n - 博客\n\n# 介绍\nhexo  是一个基于 nodejs 的静态博客网站生成器，作者是来自台湾的 Tommy Chen ，为许多技术博客的博主所青睐，主要有如下的一些优点：\n\n\n支持 Markdown 语法，编辑简单，排版优美；\n\n\n能够快速生成静态 html 文件；\n\n\n部署容易，接口简单； 兼容于各大主流操作系统；\n\n\n社区主题、插件很多，遇到问题的时候能查到的参考材料也很多。\n\n\nHexo 官方文档：https://hexo.io/zh-cn/docs/\nGitee Pages：https://gitee.com/help/articles/4136#article-header0\n# 环境配置\n搭建 hexo 首先需要有 nodejs 的环境，可以从官网直接下载。\n\n# 生成博客\n# 安装\n有了 npm 包管理软件，安装 hexo 就很方便了，只需要一行命令：\nnpm install node # homebrew安装nodejs\n其中 - g 参数表示全局安装，没有这个参数就只在当前目录下安装，建议全局安装。\n# 初始化\n运行命令：\ninstall node # homebrew安装nodejs \nINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git\nINFO  Install dependencies\n# 一些可能的中间信息\nINFO  Start blogging with Hexo!\n然后进入博客目录：\n\n\n\n\n\n\n\n\n\ncd “博客目录”\n安装博客需要的其他支持：\n npm install # 安装的依赖项在package.json文件的dependencies字段中可以看到\n# 博客项目目录结构介绍\n查看目录结构：\n tree -L 1 \n结果如下：\n\n\n\n\n\n\n\n\n\n.\n├── _config.landscape.yml\n├── _config.yml\n├── node_modules\n├── package-lock.json\n├── package.json\n├── scaffolds\n├── source\n└── themes\n各部分的含义：\n\n`_config.yml `\n\n为全局配置文件，网站的很多信息都在这里配置，比如说网站名称，副标题，描述，作者，语言，主题等等。具体可以参考官方文档：https://hexo.io/zh-cn/docs/configuration.html。\n\n\n_scaffolds\n\n骨架文件，是生成新页面或者新博客的模版。可以根据需求编辑，当 hexo  生成新博客的时候，会用这里面的模版进行初始化。\n\n\n_source\n\n这个文件夹下面存放的是网站的 markdown  源文件，里面有一个 _post  文件夹，所有的 .md  博客文件都会存放在这个文件夹下。现在，你应该能看到里面有一个 hello-world.md  文件。_\n\n\n_themes\n\n网站主题目录， hexo  有非常丰富的主题支持，主题目录会存放在这个目录下面。\n我们后续会以默认主题来演示，更多的主题参见：https://hexo.io/themes/\n\n\n\n# 生成新文章\nhexo new post \"test\" # 会在 source/_posts/ 目录下生成文件 ‘test.md’，打开编辑\nhexo generate        # 生成静态HTML文件到 /public 文件夹中\nhexo server          # 本地运行server服务预览，打开 http://localhost:4000 即可预览你的博客\n本地预览效果：\n\n这是 hexo 的默认主题，更多的主题可以从官网下载。\n更详细的 hexo 命令可以查看文档：https://hexo.io/zh-cn/docs/commands\n# Hexo 配置并部署\n\n\n\n\n\n\n\n\n\n提前对要提交的仓库配置 ssh\n# 1. 安装部署工具\nnpm install hexo-deployer-git --save\n# 2. 配置部署信息\n站点配置文件_config.yml\ndeploy:\n  type: git\n  repo: &lt;repository url> # 输入你的仓库地址\n  branch: [branch] # 输入分支\n  token:   #token\n\n\n\n\n\n\n\n\n\ndeploy:\ntype: git\nrepo: git@gitee.com:cysheng/cysheng.git # 输入你的仓库地址\nbranch: master # 输入分支\n# 3. 部署\nhexo clean  \nhexo g  \nhexo d \n\n\nhexo clean\n清除缓存文件 (db.json) 和已生成的静态文件 (public)。\n\n\nhexo g\nhexo 解析站点文件夹，生成一个 public 文件夹（只包含浏览器可以解析的 html、css、js），也就是我们需要部署的文件夹。\n\n\nhexo d\n部署，即将我们的 public 文件夹推送到我们配置的仓库\n\n\n# 4. 开启 Gitee Pages 服务\n找到新创建的仓库 -&gt;【服务】-&gt;【Gitee Pages】  \n如图，选择部署分支，部署目录\n\n\n部署分支，与本地 hexo 配置一致\n\n\n部署目录，不填即整个仓库\n\n\n强制使用 https\n一个是进行加密，还有一个是我在用 next 主题时使用 http 访问会有跨域问题导致图标显示不出来\n\n\n点击启动\n\n\n访问给出的网站地址（以我的为例：https://cysheng.gitee.io）\n\n\n# hexo 框架常用的指令：\n\n\n\n指令\n说明\n\n\n\n\nhexo clean &amp;&amp; hexo g\n清除本地项目并重新生成 （重新部署时使用）\n\n\nhexo g\n重新生成\n\n\nHexo s\n开启本地预览\n\n\nHexo d\n推送到 github\n\n\n\n# 功能设置\n# 标题和分类\n在文章开头我们可以设置 FontMatter，例如\n---\ntitle: jQuery对表单的操作及更多应用 # 标题\ndate: 2022-01-07 22:53:43 # 创建时间\ncategories: # 分类，级别递减\n- web前端 # 一级分类\n- web前端2 # 二级分类\ntags: # 标签，没有级别\n    - a1\n    - a2\n---\n​\t为了简化我们的操作，所以我们可以以设置模板，在  /scaffolds  下的  draft.md  、 page.md  、  post.md   我们用来设置模板，例如我们最常使用的 post  目录下的文件，所以我们配置一下 post.md\n---\ntitle: &#123;&#123; title &#125;&#125;\ndate: &#123;&#123; date &#125;&#125;\ncomments:\ntags:\n---\n问题\n如果我们在没有找到 tags 、categories 、link 、about 文件时，我们手动创建\nhexo new page tags\nhexo new page categories \nhexo new page link \nhexo new page about\n成功后，提示\nINFO  Created: ~/Documents/blog/source/xxx/index.md\n根据上面的路径，找到 index.md  这个文件，打开后默认内容是这样的：\n---\ntitle: 文章分类\ndate: 2022-01-07 22:53:43\ntype: \"categories\" # 哪个文件就是那个类型\nlayout: \"categories\" # 哪个文件就是那个类型\n---\n最后清除缓存，重新启动就行了\nhexo cl &amp;&amp; hexo g &amp;&amp; hexo s\n# 搜索\n# 1、注册账号\n官网：https://www.algolia.com/users/sign_in\n# 2、之后在左侧导航栏中找到 Search\n\n# 3、创建 Index\n\n\n随便写\n# 4、创建 APPID\n\n\n这两个后面有用\n\n\n\n\n\n\n\n\n\n\nIndices 是我们上面创建 index\n\n# 5、到博客根目录下安装 hexo-algolia\nnpm install hexo-algolia --save\n# 6、前往站点根目录打开_config.yml 添加以下代码\n\n\n\n\n\n\n\n\n\n** 注意：** 这是对全局的配置，所以是根目录的配置\nalgolia:\n  appId:  \"***\"  #上面的application ID\n  apiKey:  \"****\"  # 上面的 Search-Only API Key\n  adminApiKey:  \"***\"  #上面的 Admin API Keys\n  chunkSize:  5000\n  indexName:  \"test001\" # Indices的index\n  fields: # 要搜索的词条范围\n    - title #必须配置\n    - path #必须配置\n    - categories #推荐配置\n    - content:strip:truncate,0,2000\n    - tags\n例如：\nalgolia:\n  appId: \"Z7A3XW4R2I\"\n  apiKey: \"12db1ad54372045549ef465881c17e743\"\n  adminApiKey: \"40321c7c207e7f73b63a19aa24c4761b\"\n  chunkSize: 5000\n  indexName: \"my-hexo-blog\"\n  fields:\n    - content:strip:truncate,0,500\n    - excerpt:strip\n    - gallery\n    - permalink\n    - photos\n    - slug\n    - tags\n    - title\n# 7、设置 HEXO_ALGOLIA_INDEXING_KEY\n在博客根目录右击 git bash\n# export HEXO_ALGOLIA_INDEXING_KEY=\"你刚才新创建的 APPKEY、appId、adminApiKey \"一个试一下 \nexport HEXO_ALGOLIA_INDEXING_KEY=\"******\" \n# 将我们的信息上川岛algolia\nhexo algolia\n# 8、修改主题内的_config.yml\n\n\n\n\n\n\n\n\n\n注意： 这是是对主题的配置\n#Algolia Search\nalgolia_search:\n  enable: true\n  hits:\n    per_page: 6\n  labels:\n    input_placeholder: Search for Posts !\n    hits_empty: '我们没有找到任何搜索结果：$&#123;query&#125;'\n    hits_stats: '找到约$&#123;hits&#125;条结果 (用时$&#123;time&#125;ms)'\n\n# local searach\nlocal_sreach:\n  enable : false\n# 9、启动即可\nhexo s\n# 10、测试\n\n参考：https://blog.csdn.net/qq_45173404/article/details/122861321\n# 目录\ntoc 插件是：添加生成文章目录的一个插件\n一、安装 (这里是 hexo 的路径下，也就是博客根目录下)\nnpm install hexo-toc --save\n二、配置博客根目录下的_config.yml 文件：\ntoc:  \n  maxdepth: 3 \n在最后的空白处添加\n三、在 markdown 里使用\n在 Markdown 中需要显示文章目录的地方添加\n&lt;!-- toc -->\n然后就会将他后面的内容按照标题级别分层\n# 主题\n\naurora\nshoka\nbutterfly\nnext\n\n# 问题\n# 1、图片无法显示\ntyproa 设置\n打开 typora，选择：偏好设置 - 图像 - 插入图片时，做如下更改：\n\n复制到指定路径\n./$\n\n当插入图片时，会生成一个和文件名相同的文件夹，并将图片存入这个文件夹内。\nHexo 设置\n\n安装  hexo-renderer-marked\n\nnpm install hexo-renderer-marked --save\n\n之后更改 _config.yml 配置\n\npost_asset_folder: true \n安装插件 hexo-image-link \nnpm install hexo-image-link --save\n此时，在 typora 文件中正常显示的图片，在 hexo 发布后依旧能正常显示。\nNOTE：\n\n如果想用插件  Hexo-renderer-markdown-it  （推荐）代替  Hexo-renderer-marked \n\nnpm uninstall hexo-renderer-marker --save  #卸载 marked \n\nnpm install hexo-renderer-markdown-it --save  #安装markdown-it\n\n路径转换的解释\n\n假设：\n文件名: ./test.md\n图片路径: ./test/image.jpg\n当插入图片 image.jpg 到 test.md 中时，typora 的引用路径为\n &#123;% asset_img image.jpg  %&#125; \n\nHexo 发布后的引用路径为\n![](image.jpg) \n因此，typora 的 md 文件引入 hexo 时，应转换路径。即删掉图片路径中的 &quot;test/&quot; 部分；（此时 md 文件已不能正常显示图片，而 hexo server 可正常显示）\n插件 hexo-image-link 帮助实现了这种路径转换。\n安装后，typora 文件中正常显示的图片，在 hexo 发布后依旧能正常显示。\n","slug":"hexo","date":"2022-10-06T06:50:57.000Z","categories_index":"基础使用","tags_index":"博客,框架","author_index":"雾都"}]